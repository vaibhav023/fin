"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-fetch-native";
exports.ids = ["vendor-chunks/node-fetch-native"];
exports.modules = {

/***/ "(rsc)/./node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs":
/*!*************************************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n__webpack_require__(/*! node:fs */ \"node:fs\");\n__webpack_require__(/*! node:path */ \"node:path\");\nconst abortController = __webpack_require__(/*! ../shared/node-fetch-native.8afd3fea.cjs */ \"(rsc)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs\");\n__webpack_require__(/*! node:http */ \"node:http\");\n__webpack_require__(/*! node:https */ \"node:https\");\n__webpack_require__(/*! node:zlib */ \"node:zlib\");\n__webpack_require__(/*! node:stream */ \"node:stream\");\n__webpack_require__(/*! node:buffer */ \"node:buffer\");\n__webpack_require__(/*! node:util */ \"node:util\");\n__webpack_require__(/*! node:url */ \"node:url\");\n__webpack_require__(/*! node:net */ \"node:net\");\nlet s = 0;\nconst S = {\n    START_BOUNDARY: s++,\n    HEADER_FIELD_START: s++,\n    HEADER_FIELD: s++,\n    HEADER_VALUE_START: s++,\n    HEADER_VALUE: s++,\n    HEADER_VALUE_ALMOST_DONE: s++,\n    HEADERS_ALMOST_DONE: s++,\n    PART_DATA_START: s++,\n    PART_DATA: s++,\n    END: s++\n};\nlet f = 1;\nconst F = {\n    PART_BOUNDARY: f,\n    LAST_BOUNDARY: f *= 2\n};\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\nconst lower = (c)=>c | 0x20;\nconst noop = ()=>{};\nclass MultipartParser {\n    /**\n\t * @param {string} boundary\n\t */ constructor(boundary){\n        this.index = 0;\n        this.flags = 0;\n        this.onHeaderEnd = noop;\n        this.onHeaderField = noop;\n        this.onHeadersEnd = noop;\n        this.onHeaderValue = noop;\n        this.onPartBegin = noop;\n        this.onPartData = noop;\n        this.onPartEnd = noop;\n        this.boundaryChars = {};\n        boundary = \"\\r\\n--\" + boundary;\n        const ui8a = new Uint8Array(boundary.length);\n        for(let i = 0; i < boundary.length; i++){\n            ui8a[i] = boundary.charCodeAt(i);\n            this.boundaryChars[ui8a[i]] = true;\n        }\n        this.boundary = ui8a;\n        this.lookbehind = new Uint8Array(this.boundary.length + 8);\n        this.state = S.START_BOUNDARY;\n    }\n    /**\n\t * @param {Uint8Array} data\n\t */ write(data) {\n        let i = 0;\n        const length_ = data.length;\n        let previousIndex = this.index;\n        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;\n        const boundaryLength = this.boundary.length;\n        const boundaryEnd = boundaryLength - 1;\n        const bufferLength = data.length;\n        let c;\n        let cl;\n        const mark = (name)=>{\n            this[name + \"Mark\"] = i;\n        };\n        const clear = (name)=>{\n            delete this[name + \"Mark\"];\n        };\n        const callback = (callbackSymbol, start, end, ui8a)=>{\n            if (start === undefined || start !== end) {\n                this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n            }\n        };\n        const dataCallback = (name, clear)=>{\n            const markSymbol = name + \"Mark\";\n            if (!(markSymbol in this)) {\n                return;\n            }\n            if (clear) {\n                callback(name, this[markSymbol], i, data);\n                delete this[markSymbol];\n            } else {\n                callback(name, this[markSymbol], data.length, data);\n                this[markSymbol] = 0;\n            }\n        };\n        for(i = 0; i < length_; i++){\n            c = data[i];\n            switch(state){\n                case S.START_BOUNDARY:\n                    if (index === boundary.length - 2) {\n                        if (c === HYPHEN) {\n                            flags |= F.LAST_BOUNDARY;\n                        } else if (c !== CR) {\n                            return;\n                        }\n                        index++;\n                        break;\n                    } else if (index - 1 === boundary.length - 2) {\n                        if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n                            state = S.END;\n                            flags = 0;\n                        } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n                            index = 0;\n                            callback(\"onPartBegin\");\n                            state = S.HEADER_FIELD_START;\n                        } else {\n                            return;\n                        }\n                        break;\n                    }\n                    if (c !== boundary[index + 2]) {\n                        index = -2;\n                    }\n                    if (c === boundary[index + 2]) {\n                        index++;\n                    }\n                    break;\n                case S.HEADER_FIELD_START:\n                    state = S.HEADER_FIELD;\n                    mark(\"onHeaderField\");\n                    index = 0;\n                // falls through\n                case S.HEADER_FIELD:\n                    if (c === CR) {\n                        clear(\"onHeaderField\");\n                        state = S.HEADERS_ALMOST_DONE;\n                        break;\n                    }\n                    index++;\n                    if (c === HYPHEN) {\n                        break;\n                    }\n                    if (c === COLON) {\n                        if (index === 1) {\n                            // empty header field\n                            return;\n                        }\n                        dataCallback(\"onHeaderField\", true);\n                        state = S.HEADER_VALUE_START;\n                        break;\n                    }\n                    cl = lower(c);\n                    if (cl < A || cl > Z) {\n                        return;\n                    }\n                    break;\n                case S.HEADER_VALUE_START:\n                    if (c === SPACE) {\n                        break;\n                    }\n                    mark(\"onHeaderValue\");\n                    state = S.HEADER_VALUE;\n                // falls through\n                case S.HEADER_VALUE:\n                    if (c === CR) {\n                        dataCallback(\"onHeaderValue\", true);\n                        callback(\"onHeaderEnd\");\n                        state = S.HEADER_VALUE_ALMOST_DONE;\n                    }\n                    break;\n                case S.HEADER_VALUE_ALMOST_DONE:\n                    if (c !== LF) {\n                        return;\n                    }\n                    state = S.HEADER_FIELD_START;\n                    break;\n                case S.HEADERS_ALMOST_DONE:\n                    if (c !== LF) {\n                        return;\n                    }\n                    callback(\"onHeadersEnd\");\n                    state = S.PART_DATA_START;\n                    break;\n                case S.PART_DATA_START:\n                    state = S.PART_DATA;\n                    mark(\"onPartData\");\n                // falls through\n                case S.PART_DATA:\n                    previousIndex = index;\n                    if (index === 0) {\n                        // boyer-moore derrived algorithm to safely skip non-boundary data\n                        i += boundaryEnd;\n                        while(i < bufferLength && !(data[i] in boundaryChars)){\n                            i += boundaryLength;\n                        }\n                        i -= boundaryEnd;\n                        c = data[i];\n                    }\n                    if (index < boundary.length) {\n                        if (boundary[index] === c) {\n                            if (index === 0) {\n                                dataCallback(\"onPartData\", true);\n                            }\n                            index++;\n                        } else {\n                            index = 0;\n                        }\n                    } else if (index === boundary.length) {\n                        index++;\n                        if (c === CR) {\n                            // CR = part boundary\n                            flags |= F.PART_BOUNDARY;\n                        } else if (c === HYPHEN) {\n                            // HYPHEN = end boundary\n                            flags |= F.LAST_BOUNDARY;\n                        } else {\n                            index = 0;\n                        }\n                    } else if (index - 1 === boundary.length) {\n                        if (flags & F.PART_BOUNDARY) {\n                            index = 0;\n                            if (c === LF) {\n                                // unset the PART_BOUNDARY flag\n                                flags &= ~F.PART_BOUNDARY;\n                                callback(\"onPartEnd\");\n                                callback(\"onPartBegin\");\n                                state = S.HEADER_FIELD_START;\n                                break;\n                            }\n                        } else if (flags & F.LAST_BOUNDARY) {\n                            if (c === HYPHEN) {\n                                callback(\"onPartEnd\");\n                                state = S.END;\n                                flags = 0;\n                            } else {\n                                index = 0;\n                            }\n                        } else {\n                            index = 0;\n                        }\n                    }\n                    if (index > 0) {\n                        // when matching a possible boundary, keep a lookbehind reference\n                        // in case it turns out to be a false lead\n                        lookbehind[index - 1] = c;\n                    } else if (previousIndex > 0) {\n                        // if our boundary turned out to be rubbish, the captured lookbehind\n                        // belongs to partData\n                        const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n                        callback(\"onPartData\", 0, previousIndex, _lookbehind);\n                        previousIndex = 0;\n                        mark(\"onPartData\");\n                        // reconsider the current character even so it interrupted the sequence\n                        // it could be the beginning of a new sequence\n                        i--;\n                    }\n                    break;\n                case S.END:\n                    break;\n                default:\n                    throw new Error(`Unexpected state entered: ${state}`);\n            }\n        }\n        dataCallback(\"onHeaderField\");\n        dataCallback(\"onHeaderValue\");\n        dataCallback(\"onPartData\");\n        // Update properties for the next call\n        this.index = index;\n        this.state = state;\n        this.flags = flags;\n    }\n    end() {\n        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n            this.onPartEnd();\n        } else if (this.state !== S.END) {\n            throw new Error(\"MultipartParser.end(): stream ended unexpectedly\");\n        }\n    }\n}\nfunction _fileName(headerValue) {\n    // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n    const m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n    if (!m) {\n        return;\n    }\n    const match = m[2] || m[3] || \"\";\n    let filename = match.slice(match.lastIndexOf(\"\\\\\") + 1);\n    filename = filename.replace(/%22/g, '\"');\n    filename = filename.replace(/&#(\\d{4});/g, (m, code)=>{\n        return String.fromCharCode(code);\n    });\n    return filename;\n}\nasync function toFormData(Body, ct) {\n    if (!/multipart/i.test(ct)) {\n        throw new TypeError(\"Failed to fetch\");\n    }\n    const m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n    if (!m) {\n        throw new TypeError(\"no or bad content-type header, no multipart boundary\");\n    }\n    const parser = new MultipartParser(m[1] || m[2]);\n    let headerField;\n    let headerValue;\n    let entryValue;\n    let entryName;\n    let contentType;\n    let filename;\n    const entryChunks = [];\n    const formData = new abortController.FormData();\n    const onPartData = (ui8a)=>{\n        entryValue += decoder.decode(ui8a, {\n            stream: true\n        });\n    };\n    const appendToFile = (ui8a)=>{\n        entryChunks.push(ui8a);\n    };\n    const appendFileToFormData = ()=>{\n        const file = new abortController.File(entryChunks, filename, {\n            type: contentType\n        });\n        formData.append(entryName, file);\n    };\n    const appendEntryToFormData = ()=>{\n        formData.append(entryName, entryValue);\n    };\n    const decoder = new TextDecoder(\"utf-8\");\n    decoder.decode();\n    parser.onPartBegin = function() {\n        parser.onPartData = onPartData;\n        parser.onPartEnd = appendEntryToFormData;\n        headerField = \"\";\n        headerValue = \"\";\n        entryValue = \"\";\n        entryName = \"\";\n        contentType = \"\";\n        filename = null;\n        entryChunks.length = 0;\n    };\n    parser.onHeaderField = function(ui8a) {\n        headerField += decoder.decode(ui8a, {\n            stream: true\n        });\n    };\n    parser.onHeaderValue = function(ui8a) {\n        headerValue += decoder.decode(ui8a, {\n            stream: true\n        });\n    };\n    parser.onHeaderEnd = function() {\n        headerValue += decoder.decode();\n        headerField = headerField.toLowerCase();\n        if (headerField === \"content-disposition\") {\n            // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n            const m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n            if (m) {\n                entryName = m[2] || m[3] || \"\";\n            }\n            filename = _fileName(headerValue);\n            if (filename) {\n                parser.onPartData = appendToFile;\n                parser.onPartEnd = appendFileToFormData;\n            }\n        } else if (headerField === \"content-type\") {\n            contentType = headerValue;\n        }\n        headerValue = \"\";\n        headerField = \"\";\n    };\n    for await (const chunk of Body){\n        parser.write(chunk);\n    }\n    parser.end();\n    return formData;\n}\nexports.toFormData = toFormData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9jaHVua3MvbXVsdGlwYXJ0LXBhcnNlci5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUixNQUFNQyxrQkFBa0JELG1CQUFPQSxDQUFDO0FBQ2hDQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLElBQUlFLElBQUk7QUFDUixNQUFNQyxJQUFJO0lBQ1RDLGdCQUFnQkY7SUFDaEJHLG9CQUFvQkg7SUFDcEJJLGNBQWNKO0lBQ2RLLG9CQUFvQkw7SUFDcEJNLGNBQWNOO0lBQ2RPLDBCQUEwQlA7SUFDMUJRLHFCQUFxQlI7SUFDckJTLGlCQUFpQlQ7SUFDakJVLFdBQVdWO0lBQ1hXLEtBQUtYO0FBQ047QUFFQSxJQUFJWSxJQUFJO0FBQ1IsTUFBTUMsSUFBSTtJQUNUQyxlQUFlRjtJQUNmRyxlQUFlSCxLQUFLO0FBQ3JCO0FBRUEsTUFBTUksS0FBSztBQUNYLE1BQU1DLEtBQUs7QUFDWCxNQUFNQyxRQUFRO0FBQ2QsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxJQUFJO0FBQ1YsTUFBTUMsSUFBSTtBQUVWLE1BQU1DLFFBQVFDLENBQUFBLElBQUtBLElBQUk7QUFFdkIsTUFBTUMsT0FBTyxLQUFPO0FBRXBCLE1BQU1DO0lBQ0w7O0VBRUMsR0FDREMsWUFBWUMsUUFBUSxDQUFFO1FBQ3JCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFFYixJQUFJLENBQUNDLFdBQVcsR0FBR047UUFDbkIsSUFBSSxDQUFDTyxhQUFhLEdBQUdQO1FBQ3JCLElBQUksQ0FB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UUFBUTtRQUFJO0lBQ2xEO0lBRUFWLE9BQU9wRCxhQUFhLEdBQUcsU0FBVUssSUFBSTtRQUNwQ2dDLGVBQWV1QixRQUFRQyxNQUFNLENBQUN4RCxNQUFNO1lBQUN5RCxRQUFRO1FBQUk7SUFDbEQ7SUFFQVYsT0FBT3ZELFdBQVcsR0FBRztRQUNwQndDLGVBQWV1QixRQUFRQyxNQUFNO1FBQzdCUixjQUFjQSxZQUFZbUIsV0FBVztRQUVyQyxJQUFJbkIsZ0JBQWdCLHVCQUF1QjtZQUMxQyxzRUFBc0U7WUFDdEUsTUFBTWYsSUFBSUQsWUFBWUUsS0FBSyxDQUFDO1lBRTVCLElBQUlELEdBQUc7Z0JBQ05pQixZQUFZakIsQ0FBQyxDQUFDLEVBQUUsSUFBSUEsQ0FBQyxDQUFDLEVBQUUsSUFBSTtZQUM3QjtZQUVBRSxXQUFXSixVQUFVQztZQUVyQixJQUFJRyxVQUFVO2dCQUNiWSxPQUFPbEQsVUFBVSxHQUFHNkQ7Z0JBQ3BCWCxPQUFPakQsU0FBUyxHQUFHOEQ7WUFDcEI7UUFDRCxPQUFPLElBQUlaLGdCQUFnQixnQkFBZ0I7WUFDMUNHLGNBQWNuQjtRQUNmO1FBRUFBLGNBQWM7UUFDZGdCLGNBQWM7SUFDZjtJQUVBLFdBQVcsTUFBTW9CLFNBQVN6QixLQUFNO1FBQy9CSSxPQUFPeEMsS0FBSyxDQUFDNkQ7SUFDZDtJQUVBckIsT0FBTzFCLEdBQUc7SUFFVixPQUFPZ0M7QUFDUjtBQUVBZ0Isa0JBQWtCLEdBQUczQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zpbml4Ly4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gtbmF0aXZlL2Rpc3QvY2h1bmtzL211bHRpcGFydC1wYXJzZXIuY2pzPzRhZmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCdub2RlOmZzJyk7XG5yZXF1aXJlKCdub2RlOnBhdGgnKTtcbmNvbnN0IGFib3J0Q29udHJvbGxlciA9IHJlcXVpcmUoJy4uL3NoYXJlZC9ub2RlLWZldGNoLW5hdGl2ZS44YWZkM2ZlYS5janMnKTtcbnJlcXVpcmUoJ25vZGU6aHR0cCcpO1xucmVxdWlyZSgnbm9kZTpodHRwcycpO1xucmVxdWlyZSgnbm9kZTp6bGliJyk7XG5yZXF1aXJlKCdub2RlOnN0cmVhbScpO1xucmVxdWlyZSgnbm9kZTpidWZmZXInKTtcbnJlcXVpcmUoJ25vZGU6dXRpbCcpO1xucmVxdWlyZSgnbm9kZTp1cmwnKTtcbnJlcXVpcmUoJ25vZGU6bmV0Jyk7XG5cbmxldCBzID0gMDtcbmNvbnN0IFMgPSB7XG5cdFNUQVJUX0JPVU5EQVJZOiBzKyssXG5cdEhFQURFUl9GSUVMRF9TVEFSVDogcysrLFxuXHRIRUFERVJfRklFTEQ6IHMrKyxcblx0SEVBREVSX1ZBTFVFX1NUQVJUOiBzKyssXG5cdEhFQURFUl9WQUxVRTogcysrLFxuXHRIRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU6IHMrKyxcblx0SEVBREVSU19BTE1PU1RfRE9ORTogcysrLFxuXHRQQVJUX0RBVEFfU1RBUlQ6IHMrKyxcblx0UEFSVF9EQVRBOiBzKyssXG5cdEVORDogcysrXG59O1xuXG5sZXQgZiA9IDE7XG5jb25zdCBGID0ge1xuXHRQQVJUX0JPVU5EQVJZOiBmLFxuXHRMQVNUX0JPVU5EQVJZOiBmICo9IDJcbn07XG5cbmNvbnN0IExGID0gMTA7XG5jb25zdCBDUiA9IDEzO1xuY29uc3QgU1BBQ0UgPSAzMjtcbmNvbnN0IEhZUEhFTiA9IDQ1O1xuY29uc3QgQ09MT04gPSA1ODtcbmNvbnN0IEEgPSA5NztcbmNvbnN0IFogPSAxMjI7XG5cbmNvbnN0IGxvd2VyID0gYyA9PiBjIHwgMHgyMDtcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5jbGFzcyBNdWx0aXBhcnRQYXJzZXIge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kYXJ5XG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihib3VuZGFyeSkge1xuXHRcdHRoaXMuaW5kZXggPSAwO1xuXHRcdHRoaXMuZmxhZ3MgPSAwO1xuXG5cdFx0dGhpcy5vbkhlYWRlckVuZCA9IG5vb3A7XG5cdFx0dGhpcy5vbkhlYWRlckZpZWxkID0gbm9vcDtcblx0XHR0aGlzLm9uSGVhZGVyc0VuZCA9IG5vb3A7XG5cdFx0dGhpcy5vbkhlYWRlclZhbHVlID0gbm9vcDtcblx0XHR0aGlzLm9uUGFydEJlZ2luID0gbm9vcDtcblx0XHR0aGlzLm9uUGFydERhdGEgPSBub29wO1xuXHRcdHRoaXMub25QYXJ0RW5kID0gbm9vcDtcblxuXHRcdHRoaXMuYm91bmRhcnlDaGFycyA9IHt9O1xuXG5cdFx0Ym91bmRhcnkgPSAnXFxyXFxuLS0nICsgYm91bmRhcnk7XG5cdFx0Y29uc3QgdWk4YSA9IG5ldyBVaW50OEFycmF5KGJvdW5kYXJ5Lmxlbmd0aCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZGFyeS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dWk4YVtpXSA9IGJvdW5kYXJ5LmNoYXJDb2RlQXQoaSk7XG5cdFx0XHR0aGlzLmJvdW5kYXJ5Q2hhcnNbdWk4YVtpXV0gPSB0cnVlO1xuXHRcdH1cblxuXHRcdHRoaXMuYm91bmRhcnkgPSB1aThhO1xuXHRcdHRoaXMubG9va2JlaGluZCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYm91bmRhcnkubGVuZ3RoICsgOCk7XG5cdFx0dGhpcy5zdGF0ZSA9IFMuU1RBUlRfQk9VTkRBUlk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG5cdCAqL1xuXHR3cml0ZShkYXRhKSB7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGNvbnN0IGxlbmd0aF8gPSBkYXRhLmxlbmd0aDtcblx0XHRsZXQgcHJldmlvdXNJbmRleCA9IHRoaXMuaW5kZXg7XG5cdFx0bGV0IHtsb29rYmVoaW5kLCBib3VuZGFyeSwgYm91bmRhcnlDaGFycywgaW5kZXgsIHN0YXRlLCBmbGFnc30gPSB0aGlzO1xuXHRcdGNvbnN0IGJvdW5kYXJ5TGVuZ3RoID0gdGhpcy5ib3VuZGFyeS5sZW5ndGg7XG5cdFx0Y29uc3QgYm91bmRhcnlFbmQgPSBib3VuZGFyeUxlbmd0aCAtIDE7XG5cdFx0Y29uc3QgYnVmZmVyTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cdFx0bGV0IGM7XG5cdFx0bGV0IGNsO1xuXG5cdFx0Y29uc3QgbWFyayA9IG5hbWUgPT4ge1xuXHRcdFx0dGhpc1tuYW1lICsgJ01hcmsnXSA9IGk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IGNsZWFyID0gbmFtZSA9PiB7XG5cdFx0XHRkZWxldGUgdGhpc1tuYW1lICsgJ01hcmsnXTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgY2FsbGJhY2sgPSAoY2FsbGJhY2tTeW1ib2wsIHN0YXJ0LCBlbmQsIHVpOGEpID0+IHtcblx0XHRcdGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0ICE9PSBlbmQpIHtcblx0XHRcdFx0dGhpc1tjYWxsYmFja1N5bWJvbF0odWk4YSAmJiB1aThhLnN1YmFycmF5KHN0YXJ0LCBlbmQpKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3QgZGF0YUNhbGxiYWNrID0gKG5hbWUsIGNsZWFyKSA9PiB7XG5cdFx0XHRjb25zdCBtYXJrU3ltYm9sID0gbmFtZSArICdNYXJrJztcblx0XHRcdGlmICghKG1hcmtTeW1ib2wgaW4gdGhpcykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xlYXIpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmFtZSwgdGhpc1ttYXJrU3ltYm9sXSwgaSwgZGF0YSk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzW21hcmtTeW1ib2xdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sobmFtZSwgdGhpc1ttYXJrU3ltYm9sXSwgZGF0YS5sZW5ndGgsIGRhdGEpO1xuXHRcdFx0XHR0aGlzW21hcmtTeW1ib2xdID0gMDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aF87IGkrKykge1xuXHRcdFx0YyA9IGRhdGFbaV07XG5cblx0XHRcdHN3aXRjaCAoc3RhdGUpIHtcblx0XHRcdFx0Y2FzZSBTLlNUQVJUX0JPVU5EQVJZOlxuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gYm91bmRhcnkubGVuZ3RoIC0gMikge1xuXHRcdFx0XHRcdFx0aWYgKGMgPT09IEhZUEhFTikge1xuXHRcdFx0XHRcdFx0XHRmbGFncyB8PSBGLkxBU1RfQk9VTkRBUlk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgIT09IENSKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggLSAxID09PSBib3VuZGFyeS5sZW5ndGggLSAyKSB7XG5cdFx0XHRcdFx0XHRpZiAoZmxhZ3MgJiBGLkxBU1RfQk9VTkRBUlkgJiYgYyA9PT0gSFlQSEVOKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gUy5FTkQ7XG5cdFx0XHRcdFx0XHRcdGZsYWdzID0gMDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIShmbGFncyAmIEYuTEFTVF9CT1VOREFSWSkgJiYgYyA9PT0gTEYpIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjaygnb25QYXJ0QmVnaW4nKTtcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRF9TVEFSVDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMgIT09IGJvdW5kYXJ5W2luZGV4ICsgMl0pIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gLTI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMgPT09IGJvdW5kYXJ5W2luZGV4ICsgMl0pIHtcblx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5IRUFERVJfRklFTERfU1RBUlQ6XG5cdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRDtcblx0XHRcdFx0XHRtYXJrKCdvbkhlYWRlckZpZWxkJyk7XG5cdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdC8vIGZhbGxzIHRocm91Z2hcblx0XHRcdFx0Y2FzZSBTLkhFQURFUl9GSUVMRDpcblx0XHRcdFx0XHRpZiAoYyA9PT0gQ1IpIHtcblx0XHRcdFx0XHRcdGNsZWFyKCdvbkhlYWRlckZpZWxkJyk7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFMuSEVBREVSU19BTE1PU1RfRE9ORTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0aWYgKGMgPT09IEhZUEhFTikge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMgPT09IENPTE9OKSB7XG5cdFx0XHRcdFx0XHRpZiAoaW5kZXggPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0Ly8gZW1wdHkgaGVhZGVyIGZpZWxkXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlckZpZWxkJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFMuSEVBREVSX1ZBTFVFX1NUQVJUO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2wgPSBsb3dlcihjKTtcblx0XHRcdFx0XHRpZiAoY2wgPCBBIHx8IGNsID4gWikge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFMuSEVBREVSX1ZBTFVFX1NUQVJUOlxuXHRcdFx0XHRcdGlmIChjID09PSBTUEFDRSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWFyaygnb25IZWFkZXJWYWx1ZScpO1xuXHRcdFx0XHRcdHN0YXRlID0gUy5IRUFERVJfVkFMVUU7XG5cdFx0XHRcdFx0Ly8gZmFsbHMgdGhyb3VnaFxuXHRcdFx0XHRjYXNlIFMuSEVBREVSX1ZBTFVFOlxuXHRcdFx0XHRcdGlmIChjID09PSBDUikge1xuXHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlclZhbHVlJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygnb25IZWFkZXJFbmQnKTtcblx0XHRcdFx0XHRcdHN0YXRlID0gUy5IRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5IRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU6XG5cdFx0XHRcdFx0aWYgKGMgIT09IExGKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRF9TVEFSVDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBTLkhFQURFUlNfQUxNT1NUX0RPTkU6XG5cdFx0XHRcdFx0aWYgKGMgIT09IExGKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FsbGJhY2soJ29uSGVhZGVyc0VuZCcpO1xuXHRcdFx0XHRcdHN0YXRlID0gUy5QQVJUX0RBVEFfU1RBUlQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5QQVJUX0RBVEFfU1RBUlQ6XG5cdFx0XHRcdFx0c3RhdGUgPSBTLlBBUlRfREFUQTtcblx0XHRcdFx0XHRtYXJrKCdvblBhcnREYXRhJyk7XG5cdFx0XHRcdFx0Ly8gZmFsbHMgdGhyb3VnaFxuXHRcdFx0XHRjYXNlIFMuUEFSVF9EQVRBOlxuXHRcdFx0XHRcdHByZXZpb3VzSW5kZXggPSBpbmRleDtcblxuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Ly8gYm95ZXItbW9vcmUgZGVycml2ZWQgYWxnb3JpdGhtIHRvIHNhZmVseSBza2lwIG5vbi1ib3VuZGFyeSBkYXRhXG5cdFx0XHRcdFx0XHRpICs9IGJvdW5kYXJ5RW5kO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBidWZmZXJMZW5ndGggJiYgIShkYXRhW2ldIGluIGJvdW5kYXJ5Q2hhcnMpKSB7XG5cdFx0XHRcdFx0XHRcdGkgKz0gYm91bmRhcnlMZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGkgLT0gYm91bmRhcnlFbmQ7XG5cdFx0XHRcdFx0XHRjID0gZGF0YVtpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaW5kZXggPCBib3VuZGFyeS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmIChib3VuZGFyeVtpbmRleF0gPT09IGMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGluZGV4ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKCdvblBhcnREYXRhJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IGJvdW5kYXJ5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdGlmIChjID09PSBDUikge1xuXHRcdFx0XHRcdFx0XHQvLyBDUiA9IHBhcnQgYm91bmRhcnlcblx0XHRcdFx0XHRcdFx0ZmxhZ3MgfD0gRi5QQVJUX0JPVU5EQVJZO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBIWVBIRU4pIHtcblx0XHRcdFx0XHRcdFx0Ly8gSFlQSEVOID0gZW5kIGJvdW5kYXJ5XG5cdFx0XHRcdFx0XHRcdGZsYWdzIHw9IEYuTEFTVF9CT1VOREFSWTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGluZGV4IC0gMSA9PT0gYm91bmRhcnkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoZmxhZ3MgJiBGLlBBUlRfQk9VTkRBUlkpIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHRpZiAoYyA9PT0gTEYpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB1bnNldCB0aGUgUEFSVF9CT1VOREFSWSBmbGFnXG5cdFx0XHRcdFx0XHRcdFx0ZmxhZ3MgJj0gfkYuUEFSVF9CT1VOREFSWTtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjaygnb25QYXJ0RW5kJyk7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soJ29uUGFydEJlZ2luJyk7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRF9TVEFSVDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChmbGFncyAmIEYuTEFTVF9CT1VOREFSWSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYyA9PT0gSFlQSEVOKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soJ29uUGFydEVuZCcpO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlID0gUy5FTkQ7XG5cdFx0XHRcdFx0XHRcdFx0ZmxhZ3MgPSAwO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpbmRleCA+IDApIHtcblx0XHRcdFx0XHRcdC8vIHdoZW4gbWF0Y2hpbmcgYSBwb3NzaWJsZSBib3VuZGFyeSwga2VlcCBhIGxvb2tiZWhpbmQgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHQvLyBpbiBjYXNlIGl0IHR1cm5zIG91dCB0byBiZSBhIGZhbHNlIGxlYWRcblx0XHRcdFx0XHRcdGxvb2tiZWhpbmRbaW5kZXggLSAxXSA9IGM7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwcmV2aW91c0luZGV4ID4gMCkge1xuXHRcdFx0XHRcdFx0Ly8gaWYgb3VyIGJvdW5kYXJ5IHR1cm5lZCBvdXQgdG8gYmUgcnViYmlzaCwgdGhlIGNhcHR1cmVkIGxvb2tiZWhpbmRcblx0XHRcdFx0XHRcdC8vIGJlbG9uZ3MgdG8gcGFydERhdGFcblx0XHRcdFx0XHRcdGNvbnN0IF9sb29rYmVoaW5kID0gbmV3IFVpbnQ4QXJyYXkobG9va2JlaGluZC5idWZmZXIsIGxvb2tiZWhpbmQuYnl0ZU9mZnNldCwgbG9va2JlaGluZC5ieXRlTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCdvblBhcnREYXRhJywgMCwgcHJldmlvdXNJbmRleCwgX2xvb2tiZWhpbmQpO1xuXHRcdFx0XHRcdFx0cHJldmlvdXNJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRtYXJrKCdvblBhcnREYXRhJyk7XG5cblx0XHRcdFx0XHRcdC8vIHJlY29uc2lkZXIgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGV2ZW4gc28gaXQgaW50ZXJydXB0ZWQgdGhlIHNlcXVlbmNlXG5cdFx0XHRcdFx0XHQvLyBpdCBjb3VsZCBiZSB0aGUgYmVnaW5uaW5nIG9mIGEgbmV3IHNlcXVlbmNlXG5cdFx0XHRcdFx0XHRpLS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5FTkQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHN0YXRlIGVudGVyZWQ6ICR7c3RhdGV9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlckZpZWxkJyk7XG5cdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlclZhbHVlJyk7XG5cdFx0ZGF0YUNhbGxiYWNrKCdvblBhcnREYXRhJyk7XG5cblx0XHQvLyBVcGRhdGUgcHJvcGVydGllcyBmb3IgdGhlIG5leHQgY2FsbFxuXHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XG5cdFx0dGhpcy5mbGFncyA9IGZsYWdzO1xuXHR9XG5cblx0ZW5kKCkge1xuXHRcdGlmICgodGhpcy5zdGF0ZSA9PT0gUy5IRUFERVJfRklFTERfU1RBUlQgJiYgdGhpcy5pbmRleCA9PT0gMCkgfHxcblx0XHRcdCh0aGlzLnN0YXRlID09PSBTLlBBUlRfREFUQSAmJiB0aGlzLmluZGV4ID09PSB0aGlzLmJvdW5kYXJ5Lmxlbmd0aCkpIHtcblx0XHRcdHRoaXMub25QYXJ0RW5kKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN0YXRlICE9PSBTLkVORCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdWx0aXBhcnRQYXJzZXIuZW5kKCk6IHN0cmVhbSBlbmRlZCB1bmV4cGVjdGVkbHknKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gX2ZpbGVOYW1lKGhlYWRlclZhbHVlKSB7XG5cdC8vIG1hdGNoZXMgZWl0aGVyIGEgcXVvdGVkLXN0cmluZyBvciBhIHRva2VuIChSRkMgMjYxNiBzZWN0aW9uIDE5LjUuMSlcblx0Y29uc3QgbSA9IGhlYWRlclZhbHVlLm1hdGNoKC9cXGJmaWxlbmFtZT0oXCIoLio/KVwifChbXigpPD5ALDs6XFxcXFwiL1tcXF0/PXt9XFxzXFx0XSspKSgkfDtcXHMpL2kpO1xuXHRpZiAoIW0pIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBtYXRjaCA9IG1bMl0gfHwgbVszXSB8fCAnJztcblx0bGV0IGZpbGVuYW1lID0gbWF0Y2guc2xpY2UobWF0Y2gubGFzdEluZGV4T2YoJ1xcXFwnKSArIDEpO1xuXHRmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoLyUyMi9nLCAnXCInKTtcblx0ZmlsZW5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKC8mIyhcXGR7NH0pOy9nLCAobSwgY29kZSkgPT4ge1xuXHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXHR9KTtcblx0cmV0dXJuIGZpbGVuYW1lO1xufVxuXG5hc3luYyBmdW5jdGlvbiB0b0Zvcm1EYXRhKEJvZHksIGN0KSB7XG5cdGlmICghL211bHRpcGFydC9pLnRlc3QoY3QpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGZldGNoJyk7XG5cdH1cblxuXHRjb25zdCBtID0gY3QubWF0Y2goL2JvdW5kYXJ5PSg/OlwiKFteXCJdKylcInwoW147XSspKS9pKTtcblxuXHRpZiAoIW0pIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBvciBiYWQgY29udGVudC10eXBlIGhlYWRlciwgbm8gbXVsdGlwYXJ0IGJvdW5kYXJ5Jyk7XG5cdH1cblxuXHRjb25zdCBwYXJzZXIgPSBuZXcgTXVsdGlwYXJ0UGFyc2VyKG1bMV0gfHwgbVsyXSk7XG5cblx0bGV0IGhlYWRlckZpZWxkO1xuXHRsZXQgaGVhZGVyVmFsdWU7XG5cdGxldCBlbnRyeVZhbHVlO1xuXHRsZXQgZW50cnlOYW1lO1xuXHRsZXQgY29udGVudFR5cGU7XG5cdGxldCBmaWxlbmFtZTtcblx0Y29uc3QgZW50cnlDaHVua3MgPSBbXTtcblx0Y29uc3QgZm9ybURhdGEgPSBuZXcgYWJvcnRDb250cm9sbGVyLkZvcm1EYXRhKCk7XG5cblx0Y29uc3Qgb25QYXJ0RGF0YSA9IHVpOGEgPT4ge1xuXHRcdGVudHJ5VmFsdWUgKz0gZGVjb2Rlci5kZWNvZGUodWk4YSwge3N0cmVhbTogdHJ1ZX0pO1xuXHR9O1xuXG5cdGNvbnN0IGFwcGVuZFRvRmlsZSA9IHVpOGEgPT4ge1xuXHRcdGVudHJ5Q2h1bmtzLnB1c2godWk4YSk7XG5cdH07XG5cblx0Y29uc3QgYXBwZW5kRmlsZVRvRm9ybURhdGEgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZmlsZSA9IG5ldyBhYm9ydENvbnRyb2xsZXIuRmlsZShlbnRyeUNodW5rcywgZmlsZW5hbWUsIHt0eXBlOiBjb250ZW50VHlwZX0pO1xuXHRcdGZvcm1EYXRhLmFwcGVuZChlbnRyeU5hbWUsIGZpbGUpO1xuXHR9O1xuXG5cdGNvbnN0IGFwcGVuZEVudHJ5VG9Gb3JtRGF0YSA9ICgpID0+IHtcblx0XHRmb3JtRGF0YS5hcHBlbmQoZW50cnlOYW1lLCBlbnRyeVZhbHVlKTtcblx0fTtcblxuXHRjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuXHRkZWNvZGVyLmRlY29kZSgpO1xuXG5cdHBhcnNlci5vblBhcnRCZWdpbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRwYXJzZXIub25QYXJ0RGF0YSA9IG9uUGFydERhdGE7XG5cdFx0cGFyc2VyLm9uUGFydEVuZCA9IGFwcGVuZEVudHJ5VG9Gb3JtRGF0YTtcblxuXHRcdGhlYWRlckZpZWxkID0gJyc7XG5cdFx0aGVhZGVyVmFsdWUgPSAnJztcblx0XHRlbnRyeVZhbHVlID0gJyc7XG5cdFx0ZW50cnlOYW1lID0gJyc7XG5cdFx0Y29udGVudFR5cGUgPSAnJztcblx0XHRmaWxlbmFtZSA9IG51bGw7XG5cdFx0ZW50cnlDaHVua3MubGVuZ3RoID0gMDtcblx0fTtcblxuXHRwYXJzZXIub25IZWFkZXJGaWVsZCA9IGZ1bmN0aW9uICh1aThhKSB7XG5cdFx0aGVhZGVyRmllbGQgKz0gZGVjb2Rlci5kZWNvZGUodWk4YSwge3N0cmVhbTogdHJ1ZX0pO1xuXHR9O1xuXG5cdHBhcnNlci5vbkhlYWRlclZhbHVlID0gZnVuY3Rpb24gKHVpOGEpIHtcblx0XHRoZWFkZXJWYWx1ZSArPSBkZWNvZGVyLmRlY29kZSh1aThhLCB7c3RyZWFtOiB0cnVlfSk7XG5cdH07XG5cblx0cGFyc2VyLm9uSGVhZGVyRW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdGhlYWRlclZhbHVlICs9IGRlY29kZXIuZGVjb2RlKCk7XG5cdFx0aGVhZGVyRmllbGQgPSBoZWFkZXJGaWVsZC50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKGhlYWRlckZpZWxkID09PSAnY29udGVudC1kaXNwb3NpdGlvbicpIHtcblx0XHRcdC8vIG1hdGNoZXMgZWl0aGVyIGEgcXVvdGVkLXN0cmluZyBvciBhIHRva2VuIChSRkMgMjYxNiBzZWN0aW9uIDE5LjUuMSlcblx0XHRcdGNvbnN0IG0gPSBoZWFkZXJWYWx1ZS5tYXRjaCgvXFxibmFtZT0oXCIoW15cIl0qKVwifChbXigpPD5ALDs6XFxcXFwiL1tcXF0/PXt9XFxzXFx0XSspKS9pKTtcblxuXHRcdFx0aWYgKG0pIHtcblx0XHRcdFx0ZW50cnlOYW1lID0gbVsyXSB8fCBtWzNdIHx8ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHRmaWxlbmFtZSA9IF9maWxlTmFtZShoZWFkZXJWYWx1ZSk7XG5cblx0XHRcdGlmIChmaWxlbmFtZSkge1xuXHRcdFx0XHRwYXJzZXIub25QYXJ0RGF0YSA9IGFwcGVuZFRvRmlsZTtcblx0XHRcdFx0cGFyc2VyLm9uUGFydEVuZCA9IGFwcGVuZEZpbGVUb0Zvcm1EYXRhO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoaGVhZGVyRmllbGQgPT09ICdjb250ZW50LXR5cGUnKSB7XG5cdFx0XHRjb250ZW50VHlwZSA9IGhlYWRlclZhbHVlO1xuXHRcdH1cblxuXHRcdGhlYWRlclZhbHVlID0gJyc7XG5cdFx0aGVhZGVyRmllbGQgPSAnJztcblx0fTtcblxuXHRmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIEJvZHkpIHtcblx0XHRwYXJzZXIud3JpdGUoY2h1bmspO1xuXHR9XG5cblx0cGFyc2VyLmVuZCgpO1xuXG5cdHJldHVybiBmb3JtRGF0YTtcbn1cblxuZXhwb3J0cy50b0Zvcm1EYXRhID0gdG9Gb3JtRGF0YTtcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiYWJvcnRDb250cm9sbGVyIiwicyIsIlMiLCJTVEFSVF9CT1VOREFSWSIsIkhFQURFUl9GSUVMRF9TVEFSVCIsIkhFQURFUl9GSUVMRCIsIkhFQURFUl9WQUxVRV9TVEFSVCIsIkhFQURFUl9WQUxVRSIsIkhFQURFUl9WQUxVRV9BTE1PU1RfRE9ORSIsIkhFQURFUlNfQUxNT1NUX0RPTkUiLCJQQVJUX0RBVEFfU1RBUlQiLCJQQVJUX0RBVEEiLCJFTkQiLCJmIiwiRiIsIlBBUlRfQk9VTkRBUlkiLCJMQVNUX0JPVU5EQVJZIiwiTEYiLCJDUiIsIlNQQUNFIiwiSFlQSEVOIiwiQ09MT04iLCJBIiwiWiIsImxvd2VyIiwiYyIsIm5vb3AiLCJNdWx0aXBhcnRQYXJzZXIiLCJjb25zdHJ1Y3RvciIsImJvdW5kYXJ5IiwiaW5kZXgiLCJmbGFncyIsIm9uSGVhZGVyRW5kIiwib25IZWFkZXJGaWVsZCIsIm9uSGVhZGVyc0VuZCIsIm9uSGVhZGVyVmFsdWUiLCJvblBhcnRCZWdpbiIsIm9uUGFydERhdGEiLCJvblBhcnRFbmQiLCJib3VuZGFyeUNoYXJzIiwidWk4YSIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJpIiwiY2hhckNvZGVBdCIsImxvb2tiZWhpbmQiLCJzdGF0ZSIsIndyaXRlIiwiZGF0YSIsImxlbmd0aF8iLCJwcmV2aW91c0luZGV4IiwiYm91bmRhcnlMZW5ndGgiLCJib3VuZGFyeUVuZCIsImJ1ZmZlckxlbmd0aCIsImNsIiwibWFyayIsIm5hbWUiLCJjbGVhciIsImNhbGxiYWNrIiwiY2FsbGJhY2tTeW1ib2wiLCJzdGFydCIsImVuZCIsInVuZGVmaW5lZCIsInN1YmFycmF5IiwiZGF0YUNhbGxiYWNrIiwibWFya1N5bWJvbCIsIl9sb29rYmVoaW5kIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJFcnJvciIsIl9maWxlTmFtZSIsImhlYWRlclZhbHVlIiwibSIsIm1hdGNoIiwiZmlsZW5hbWUiLCJzbGljZSIsImxhc3RJbmRleE9mIiwicmVwbGFjZSIsImNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ0b0Zvcm1EYXRhIiwiQm9keSIsImN0IiwidGVzdCIsIlR5cGVFcnJvciIsInBhcnNlciIsImhlYWRlckZpZWxkIiwiZW50cnlWYWx1ZSIsImVudHJ5TmFtZSIsImNvbnRlbnRUeXBlIiwiZW50cnlDaHVua3MiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiZGVjb2RlciIsImRlY29kZSIsInN0cmVhbSIsImFwcGVuZFRvRmlsZSIsInB1c2giLCJhcHBlbmRGaWxlVG9Gb3JtRGF0YSIsImZpbGUiLCJGaWxlIiwidHlwZSIsImFwcGVuZCIsImFwcGVuZEVudHJ5VG9Gb3JtRGF0YSIsIlRleHREZWNvZGVyIiwidG9Mb3dlckNhc2UiLCJjaHVuayIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst abortController = __webpack_require__(/*! ./shared/node-fetch-native.8afd3fea.cjs */ \"(rsc)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs\");\nconst node_fs = __webpack_require__(/*! node:fs */ \"node:fs\");\nconst node_path = __webpack_require__(/*! node:path */ \"node:path\");\n__webpack_require__(/*! node:http */ \"node:http\");\n__webpack_require__(/*! node:https */ \"node:https\");\n__webpack_require__(/*! node:zlib */ \"node:zlib\");\n__webpack_require__(/*! node:stream */ \"node:stream\");\n__webpack_require__(/*! node:buffer */ \"node:buffer\");\n__webpack_require__(/*! node:util */ \"node:util\");\n__webpack_require__(/*! node:url */ \"node:url\");\n__webpack_require__(/*! node:net */ \"node:net\");\nconst { stat } = node_fs.promises;\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */ const blobFromSync = (path, type)=>fromBlob(node_fs.statSync(path), path, type);\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */ const blobFrom = (path, type)=>stat(path).then((stat)=>fromBlob(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */ const fileFrom = (path, type)=>stat(path).then((stat)=>fromFile(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */ const fileFromSync = (path, type)=>fromFile(node_fs.statSync(path), path, type);\n// @ts-ignore\nconst fromBlob = (stat, path, type = \"\")=>new abortController._Blob([\n        new BlobDataItem({\n            path,\n            size: stat.size,\n            lastModified: stat.mtimeMs,\n            start: 0\n        })\n    ], {\n        type\n    });\n// @ts-ignore\nconst fromFile = (stat, path, type = \"\")=>new abortController.File([\n        new BlobDataItem({\n            path,\n            size: stat.size,\n            lastModified: stat.mtimeMs,\n            start: 0\n        })\n    ], node_path.basename(path), {\n        type,\n        lastModified: stat.mtimeMs\n    });\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */ class BlobDataItem {\n    #path;\n    #start;\n    constructor(options){\n        this.#path = options.path;\n        this.#start = options.start;\n        this.size = options.size;\n        this.lastModified = options.lastModified;\n        this.originalSize = options.originalSize === undefined ? options.size : options.originalSize;\n    }\n    /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */ slice(start, end) {\n        return new BlobDataItem({\n            path: this.#path,\n            lastModified: this.lastModified,\n            originalSize: this.originalSize,\n            size: end - start,\n            start: this.#start + start\n        });\n    }\n    async *stream() {\n        const { mtimeMs, size } = await stat(this.#path);\n        if (mtimeMs > this.lastModified || this.originalSize !== size) {\n            throw new abortController.nodeDomexception(\"The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.\", \"NotReadableError\");\n        }\n        yield* node_fs.createReadStream(this.#path, {\n            start: this.#start,\n            end: this.#start + this.size - 1\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n}\nconst fetch = globalThis.fetch || abortController.fetch;\nconst Blob = globalThis.Blob || abortController._Blob;\nconst File = globalThis.File || abortController.File;\nconst FormData = globalThis.FormData || abortController.FormData;\nconst Headers = globalThis.Headers || abortController.Headers;\nconst Request = globalThis.Request || abortController.Request;\nconst Response = globalThis.Response || abortController.Response;\nconst AbortController = globalThis.AbortController || abortController.AbortController;\nexports.AbortError = abortController.AbortError;\nexports.FetchError = abortController.FetchError;\nexports.isRedirect = abortController.isRedirect;\nexports.AbortController = AbortController;\nexports.Blob = Blob;\nexports.File = File;\nexports.FormData = FormData;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports.blobFrom = blobFrom;\nexports.blobFromSync = blobFromSync;\nexports[\"default\"] = fetch;\nexports.fetch = fetch;\nexports.fileFrom = fileFrom;\nexports.fileFromSync = fileFromSync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsTUFBTUMsa0JBQWtCQyxtQkFBT0EsQ0FBQztBQUNoQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNRSxZQUFZRixtQkFBT0EsQ0FBQztBQUMxQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixNQUFNLEVBQUVHLElBQUksRUFBRSxHQUFHRixRQUFRRyxRQUFRO0FBRWpDOzs7Q0FHQyxHQUNELE1BQU1DLGVBQWUsQ0FBQ0MsTUFBTUMsT0FBU0MsU0FBU1AsUUFBUVEsUUFBUSxDQUFDSCxPQUFPQSxNQUFNQztBQUU1RTs7OztDQUlDLEdBQ0QsTUFBTUcsV0FBVyxDQUFDSixNQUFNQyxPQUFTSixLQUFLRyxNQUFNSyxJQUFJLENBQUNSLENBQUFBLE9BQVFLLFNBQVNMLE1BQU1HLE1BQU1DO0FBRTlFOzs7O0NBSUMsR0FDRCxNQUFNSyxXQUFXLENBQUNOLE1BQU1DLE9BQVNKLEtBQUtHLE1BQU1LLElBQUksQ0FBQ1IsQ0FBQUEsT0FBUVUsU0FBU1YsTUFBTUcsTUFBTUM7QUFFOUU7OztDQUdDLEdBQ0QsTUFBTU8sZUFBZSxDQUFDUixNQUFNQyxPQUFTTSxTQUFTWixRQUFRUSxRQUFRLENBQUNILE9BQU9BLE1BQU1DO0FBRTVFLGFBQWE7QUFDYixNQUFNQyxXQUFXLENBQUNMLE1BQU1HLE1BQU1DLE9BQU8sRUFBRSxHQUFLLElBQUlSLGdCQUFnQmdCLEtBQUssQ0FBQztRQUFDLElBQUlDLGFBQWE7WUFDdEZWO1lBQ0FXLE1BQU1kLEtB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QyxVQUFVO0FBQy9DL0MsdUJBQXVCLEdBQUc0QztBQUMxQjVDLFlBQVksR0FBR3VDO0FBQ2Z2QyxZQUFZLEdBQUd3QjtBQUNmeEIsZ0JBQWdCLEdBQUd3QztBQUNuQnhDLGVBQWUsR0FBR3lDO0FBQ2xCekMsZUFBZSxHQUFHMEM7QUFDbEIxQyxnQkFBZ0IsR0FBRzJDO0FBQ25CM0MsZ0JBQWdCLEdBQUdhO0FBQ25CYixvQkFBb0IsR0FBR1E7QUFDdkJSLGtCQUFlLEdBQUdxQztBQUNsQnJDLGFBQWEsR0FBR3FDO0FBQ2hCckMsZ0JBQWdCLEdBQUdlO0FBQ25CZixvQkFBb0IsR0FBR2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmluaXgvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9pbmRleC5janM/ZDE5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IGFib3J0Q29udHJvbGxlciA9IHJlcXVpcmUoJy4vc2hhcmVkL25vZGUtZmV0Y2gtbmF0aXZlLjhhZmQzZmVhLmNqcycpO1xuY29uc3Qgbm9kZV9mcyA9IHJlcXVpcmUoJ25vZGU6ZnMnKTtcbmNvbnN0IG5vZGVfcGF0aCA9IHJlcXVpcmUoJ25vZGU6cGF0aCcpO1xucmVxdWlyZSgnbm9kZTpodHRwJyk7XG5yZXF1aXJlKCdub2RlOmh0dHBzJyk7XG5yZXF1aXJlKCdub2RlOnpsaWInKTtcbnJlcXVpcmUoJ25vZGU6c3RyZWFtJyk7XG5yZXF1aXJlKCdub2RlOmJ1ZmZlcicpO1xucmVxdWlyZSgnbm9kZTp1dGlsJyk7XG5yZXF1aXJlKCdub2RlOnVybCcpO1xucmVxdWlyZSgnbm9kZTpuZXQnKTtcblxuY29uc3QgeyBzdGF0IH0gPSBub2RlX2ZzLnByb21pc2VzO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGVwYXRoIG9uIHRoZSBkaXNrXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG1pbWV0eXBlIHRvIHVzZVxuICovXG5jb25zdCBibG9iRnJvbVN5bmMgPSAocGF0aCwgdHlwZSkgPT4gZnJvbUJsb2Iobm9kZV9mcy5zdGF0U3luYyhwYXRoKSwgcGF0aCwgdHlwZSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZmlsZXBhdGggb24gdGhlIGRpc2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gbWltZXR5cGUgdG8gdXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCbG9iPn1cbiAqL1xuY29uc3QgYmxvYkZyb20gPSAocGF0aCwgdHlwZSkgPT4gc3RhdChwYXRoKS50aGVuKHN0YXQgPT4gZnJvbUJsb2Ioc3RhdCwgcGF0aCwgdHlwZSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGVwYXRoIG9uIHRoZSBkaXNrXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG1pbWV0eXBlIHRvIHVzZVxuICogQHJldHVybnMge1Byb21pc2U8RmlsZT59XG4gKi9cbmNvbnN0IGZpbGVGcm9tID0gKHBhdGgsIHR5cGUpID0+IHN0YXQocGF0aCkudGhlbihzdGF0ID0+IGZyb21GaWxlKHN0YXQsIHBhdGgsIHR5cGUpKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlcGF0aCBvbiB0aGUgZGlza1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBtaW1ldHlwZSB0byB1c2VcbiAqL1xuY29uc3QgZmlsZUZyb21TeW5jID0gKHBhdGgsIHR5cGUpID0+IGZyb21GaWxlKG5vZGVfZnMuc3RhdFN5bmMocGF0aCksIHBhdGgsIHR5cGUpO1xuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBmcm9tQmxvYiA9IChzdGF0LCBwYXRoLCB0eXBlID0gJycpID0+IG5ldyBhYm9ydENvbnRyb2xsZXIuX0Jsb2IoW25ldyBCbG9iRGF0YUl0ZW0oe1xuICBwYXRoLFxuICBzaXplOiBzdGF0LnNpemUsXG4gIGxhc3RNb2RpZmllZDogc3RhdC5tdGltZU1zLFxuICBzdGFydDogMFxufSldLCB7IHR5cGUgfSk7XG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGZyb21GaWxlID0gKHN0YXQsIHBhdGgsIHR5cGUgPSAnJykgPT4gbmV3IGFib3J0Q29udHJvbGxlci5GaWxlKFtuZXcgQmxvYkRhdGFJdGVtKHtcbiAgcGF0aCxcbiAgc2l6ZTogc3RhdC5zaXplLFxuICBsYXN0TW9kaWZpZWQ6IHN0YXQubXRpbWVNcyxcbiAgc3RhcnQ6IDBcbn0pXSwgbm9kZV9wYXRoLmJhc2VuYW1lKHBhdGgpLCB7IHR5cGUsIGxhc3RNb2RpZmllZDogc3RhdC5tdGltZU1zIH0pO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBibG9iIGJhY2tlZCB1cCBieSBhIGZpbGUgb24gdGhlIGRpc2tcbiAqIHdpdGggbWluaXVtIHJlcXVpcmVtZW50LiBJdHMgd3JhcHBlZCBhcm91bmQgYSBCbG9iIGFzIGEgYmxvYlBhcnRcbiAqIHNvIHlvdSBoYXZlIG5vIGRpcmVjdCBhY2Nlc3MgdG8gdGhpcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBCbG9iRGF0YUl0ZW0ge1xuICAjcGF0aFxuICAjc3RhcnRcblxuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMuI3BhdGggPSBvcHRpb25zLnBhdGg7XG4gICAgdGhpcy4jc3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xuICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcbiAgICB0aGlzLmxhc3RNb2RpZmllZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkO1xuICAgIHRoaXMub3JpZ2luYWxTaXplID0gb3B0aW9ucy5vcmlnaW5hbFNpemUgPT09IHVuZGVmaW5lZFxuICAgICAgPyBvcHRpb25zLnNpemVcbiAgICAgIDogb3B0aW9ucy5vcmlnaW5hbFNpemU7XG4gIH1cblxuICAvKipcbiAgICogU2xpY2luZyBhcmd1bWVudHMgaXMgZmlyc3QgdmFsaWRhdGVkIGFuZCBmb3JtYXR0ZWRcbiAgICogdG8gbm90IGJlIG91dCBvZiByYW5nZSBieSBCbG9iLnByb3RvdHlwZS5zbGljZVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gbmV3IEJsb2JEYXRhSXRlbSh7XG4gICAgICBwYXRoOiB0aGlzLiNwYXRoLFxuICAgICAgbGFzdE1vZGlmaWVkOiB0aGlzLmxhc3RNb2RpZmllZCxcbiAgICAgIG9yaWdpbmFsU2l6ZTogdGhpcy5vcmlnaW5hbFNpemUsXG4gICAgICBzaXplOiBlbmQgLSBzdGFydCxcbiAgICAgIHN0YXJ0OiB0aGlzLiNzdGFydCArIHN0YXJ0XG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jICogc3RyZWFtICgpIHtcbiAgICBjb25zdCB7IG10aW1lTXMsIHNpemUgfSA9IGF3YWl0IHN0YXQodGhpcy4jcGF0aCk7XG5cbiAgICBpZiAobXRpbWVNcyA+IHRoaXMubGFzdE1vZGlmaWVkIHx8IHRoaXMub3JpZ2luYWxTaXplICE9PSBzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgYWJvcnRDb250cm9sbGVyLm5vZGVEb21leGNlcHRpb24oJ1RoZSByZXF1ZXN0ZWQgZmlsZSBjb3VsZCBub3QgYmUgcmVhZCwgdHlwaWNhbGx5IGR1ZSB0byBwZXJtaXNzaW9uIHByb2JsZW1zIHRoYXQgaGF2ZSBvY2N1cnJlZCBhZnRlciBhIHJlZmVyZW5jZSB0byBhIGZpbGUgd2FzIGFjcXVpcmVkLicsICdOb3RSZWFkYWJsZUVycm9yJylcbiAgICB9XG5cbiAgICB5aWVsZCAqIG5vZGVfZnMuY3JlYXRlUmVhZFN0cmVhbSh0aGlzLiNwYXRoLCB7XG4gICAgICBzdGFydDogdGhpcy4jc3RhcnQsXG4gICAgICBlbmQ6IHRoaXMuI3N0YXJ0ICsgdGhpcy5zaXplIC0gMVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICByZXR1cm4gJ0Jsb2InXG4gIH1cbn1cblxuY29uc3QgZmV0Y2ggPSBnbG9iYWxUaGlzLmZldGNoIHx8IGFib3J0Q29udHJvbGxlci5mZXRjaDtcbmNvbnN0IEJsb2IgPSBnbG9iYWxUaGlzLkJsb2IgfHwgYWJvcnRDb250cm9sbGVyLl9CbG9iO1xuY29uc3QgRmlsZSA9IGdsb2JhbFRoaXMuRmlsZSB8fCBhYm9ydENvbnRyb2xsZXIuRmlsZTtcbmNvbnN0IEZvcm1EYXRhID0gZ2xvYmFsVGhpcy5Gb3JtRGF0YSB8fCBhYm9ydENvbnRyb2xsZXIuRm9ybURhdGE7XG5jb25zdCBIZWFkZXJzID0gZ2xvYmFsVGhpcy5IZWFkZXJzIHx8IGFib3J0Q29udHJvbGxlci5IZWFkZXJzO1xuY29uc3QgUmVxdWVzdCA9IGdsb2JhbFRoaXMuUmVxdWVzdCB8fCBhYm9ydENvbnRyb2xsZXIuUmVxdWVzdDtcbmNvbnN0IFJlc3BvbnNlID0gZ2xvYmFsVGhpcy5SZXNwb25zZSB8fCBhYm9ydENvbnRyb2xsZXIuUmVzcG9uc2U7XG5jb25zdCBBYm9ydENvbnRyb2xsZXIgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlciB8fCBhYm9ydENvbnRyb2xsZXIuQWJvcnRDb250cm9sbGVyO1xuXG5leHBvcnRzLkFib3J0RXJyb3IgPSBhYm9ydENvbnRyb2xsZXIuQWJvcnRFcnJvcjtcbmV4cG9ydHMuRmV0Y2hFcnJvciA9IGFib3J0Q29udHJvbGxlci5GZXRjaEVycm9yO1xuZXhwb3J0cy5pc1JlZGlyZWN0ID0gYWJvcnRDb250cm9sbGVyLmlzUmVkaXJlY3Q7XG5leHBvcnRzLkFib3J0Q29udHJvbGxlciA9IEFib3J0Q29udHJvbGxlcjtcbmV4cG9ydHMuQmxvYiA9IEJsb2I7XG5leHBvcnRzLkZpbGUgPSBGaWxlO1xuZXhwb3J0cy5Gb3JtRGF0YSA9IEZvcm1EYXRhO1xuZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gUmVzcG9uc2U7XG5leHBvcnRzLmJsb2JGcm9tID0gYmxvYkZyb207XG5leHBvcnRzLmJsb2JGcm9tU3luYyA9IGJsb2JGcm9tU3luYztcbmV4cG9ydHMuZGVmYXVsdCA9IGZldGNoO1xuZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuZXhwb3J0cy5maWxlRnJvbSA9IGZpbGVGcm9tO1xuZXhwb3J0cy5maWxlRnJvbVN5bmMgPSBmaWxlRnJvbVN5bmM7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhYm9ydENvbnRyb2xsZXIiLCJyZXF1aXJlIiwibm9kZV9mcyIsIm5vZGVfcGF0aCIsInN0YXQiLCJwcm9taXNlcyIsImJsb2JGcm9tU3luYyIsInBhdGgiLCJ0eXBlIiwiZnJvbUJsb2IiLCJzdGF0U3luYyIsImJsb2JGcm9tIiwidGhlbiIsImZpbGVGcm9tIiwiZnJvbUZpbGUiLCJmaWxlRnJvbVN5bmMiLCJfQmxvYiIsIkJsb2JEYXRhSXRlbSIsInNpemUiLCJsYXN0TW9kaWZpZWQiLCJtdGltZU1zIiwic3RhcnQiLCJGaWxlIiwiYmFzZW5hbWUiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJvcmlnaW5hbFNpemUiLCJ1bmRlZmluZWQiLCJzbGljZSIsImVuZCIsInN0cmVhbSIsIm5vZGVEb21leGNlcHRpb24iLCJjcmVhdGVSZWFkU3RyZWFtIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJmZXRjaCIsImdsb2JhbFRoaXMiLCJCbG9iIiwiRm9ybURhdGEiLCJIZWFkZXJzIiwiUmVxdWVzdCIsIlJlc3BvbnNlIiwiQWJvcnRDb250cm9sbGVyIiwiQWJvcnRFcnJvciIsIkZldGNoRXJyb3IiLCJpc1JlZGlyZWN0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst http = __webpack_require__(/*! node:http */ \"node:http\");\nconst https = __webpack_require__(/*! node:https */ \"node:https\");\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\");\nconst Stream = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst node_buffer = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst node_util = __webpack_require__(/*! node:util */ \"node:util\");\nconst node_url = __webpack_require__(/*! node:url */ \"node:url\");\nconst node_net = __webpack_require__(/*! node:net */ \"node:net\");\n__webpack_require__(/*! node:fs */ \"node:fs\");\n__webpack_require__(/*! node:path */ \"node:path\");\n/**\n * Returns a `Buffer` instance from the given data URI `uri`.\n *\n * @param {String} uri Data URI to turn into a Buffer instance\n * @returns {Buffer} Buffer instance from Data URI\n * @api public\n */ function dataUriToBuffer(uri) {\n    if (!/^data:/i.test(uri)) {\n        throw new TypeError('`uri` does not appear to be a Data URI (must begin with \"data:\")');\n    }\n    // strip newlines\n    uri = uri.replace(/\\r?\\n/g, \"\");\n    // split the URI up into the \"metadata\" and the \"data\" portions\n    const firstComma = uri.indexOf(\",\");\n    if (firstComma === -1 || firstComma <= 4) {\n        throw new TypeError(\"malformed data: URI\");\n    }\n    // remove the \"data:\" scheme and parse the metadata\n    const meta = uri.substring(5, firstComma).split(\";\");\n    let charset = \"\";\n    let base64 = false;\n    const type = meta[0] || \"text/plain\";\n    let typeFull = type;\n    for(let i = 1; i < meta.length; i++){\n        if (meta[i] === \"base64\") {\n            base64 = true;\n        } else {\n            typeFull += `;${meta[i]}`;\n            if (meta[i].indexOf(\"charset=\") === 0) {\n                charset = meta[i].substring(8);\n            }\n        }\n    }\n    // defaults to US-ASCII only if type is not provided\n    if (!meta[0] && !charset.length) {\n        typeFull += \";charset=US-ASCII\";\n        charset = \"US-ASCII\";\n    }\n    // get the encoded data portion and decode URI-encoded chars\n    const encoding = base64 ? \"base64\" : \"ascii\";\n    const data = unescape(uri.substring(firstComma + 1));\n    const buffer = Buffer.from(data, encoding);\n    // set `.type` and `.typeFull` properties to MIME type\n    buffer.type = type;\n    buffer.typeFull = typeFull;\n    // set the `.charset` property\n    buffer.charset = charset;\n    return buffer;\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar ponyfill_es2018 = {\n    exports: {}\n};\n/**\n * web-streams-polyfill v3.2.1\n */ var hasRequiredPonyfill_es2018;\nfunction requirePonyfill_es2018() {\n    if (hasRequiredPonyfill_es2018) return ponyfill_es2018.exports;\n    hasRequiredPonyfill_es2018 = 1;\n    (function(module, exports1) {\n        (function(global1, factory) {\n            factory(exports1);\n        })(commonjsGlobal, function(exports1) {\n            /// <reference lib=\"es2015.symbol\" />\n            const SymbolPolyfill = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? Symbol : (description)=>`Symbol(${description})`;\n            /// <reference lib=\"dom\" />\n            function noop() {\n                return undefined;\n            }\n            function getGlobals() {\n                if (typeof self !== \"undefined\") {\n                    return self;\n                } else if (false) {} else if (typeof commonjsGlobal !== \"undefined\") {\n                    return commonjsGlobal;\n                }\n                return undefined;\n            }\n            const globals = getGlobals();\n            function typeIsObject(x) {\n                return typeof x === \"object\" && x !== null || typeof x === \"function\";\n            }\n            const rethrowAssertionErrorRejection = noop;\n            const originalPromise = Promise;\n            const originalPromiseThen = Promise.prototype.then;\n            const originalPromiseResolve = Promise.resolve.bind(originalPromise);\n            const originalPromiseReject = Promise.reject.bind(originalPromise);\n            function newPromise(executor) {\n                return new originalPromise(executor);\n            }\n            function promiseResolvedWith(value1) {\n                return originalPromiseResolve(value1);\n            }\n            function promiseRejectedWith(reason) {\n                return originalPromiseReject(reason);\n            }\n            function PerformPromiseThen(promise, onFulfilled, onRejected) {\n                // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n                // approximation.\n                return originalPromiseThen.call(promise, onFulfilled, onRejected);\n            }\n            function uponPromise(promise, onFulfilled, onRejected) {\n                PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n            }\n            function uponFulfillment(promise, onFulfilled) {\n                uponPromise(promise, onFulfilled);\n            }\n            function uponRejection(promise, onRejected) {\n                uponPromise(promise, undefined, onRejected);\n            }\n            function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n                return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n            }\n            function setPromiseIsHandledToTrue(promise) {\n                PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n            }\n            const queueMicrotask = (()=>{\n                const globalQueueMicrotask = globals && globals.queueMicrotask;\n                if (typeof globalQueueMicrotask === \"function\") {\n                    return globalQueueMicrotask;\n                }\n                const resolvedPromise = promiseResolvedWith(undefined);\n                return (fn)=>PerformPromiseThen(resolvedPromise, fn);\n            })();\n            function reflectCall(F, V, args) {\n                if (typeof F !== \"function\") {\n                    throw new TypeError(\"Argument is not a function\");\n                }\n                return Function.prototype.apply.call(F, V, args);\n            }\n            function promiseCall(F, V, args) {\n                try {\n                    return promiseResolvedWith(reflectCall(F, V, args));\n                } catch (value1) {\n                    return promiseRejectedWith(value1);\n                }\n            }\n            // Original from Chromium\n            // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n            const QUEUE_MAX_ARRAY_SIZE = 16384;\n            /**\n\t\t     * Simple queue structure.\n\t\t     *\n\t\t     * Avoids scalability issues with using a packed array directly by using\n\t\t     * multiple arrays in a linked list and keeping the array size bounded.\n\t\t     */ class SimpleQueue {\n                constructor(){\n                    this._cursor = 0;\n                    this._size = 0;\n                    // _front and _back are always defined.\n                    this._front = {\n                        _elements: [],\n                        _next: undefined\n                    };\n                    this._back = this._front;\n                    // The cursor is used to avoid calling Array.shift().\n                    // It contains the index of the front element of the array inside the\n                    // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n                    this._cursor = 0;\n                    // When there is only one node, size === elements.length - cursor.\n                    this._size = 0;\n                }\n                get length() {\n                    return this._size;\n                }\n                // For exception safety, this method is structured in order:\n                // 1. Read state\n                // 2. Calculate required state mutations\n                // 3. Perform state mutations\n                push(element) {\n                    const oldBack = this._back;\n                    let newBack = oldBack;\n                    if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n                        newBack = {\n                            _elements: [],\n                            _next: undefined\n                        };\n                    }\n                    // push() is the mutation most likely to throw an exception, so it\n                    // goes first.\n                    oldBack._elements.push(element);\n                    if (newBack !== oldBack) {\n                        this._back = newBack;\n                        oldBack._next = newBack;\n                    }\n                    ++this._size;\n                }\n                // Like push(), shift() follows the read -> calculate -> mutate pattern for\n                // exception safety.\n                shift() {\n                    const oldFront = this._front;\n                    let newFront = oldFront;\n                    const oldCursor = this._cursor;\n                    let newCursor = oldCursor + 1;\n                    const elements = oldFront._elements;\n                    const element = elements[oldCursor];\n                    if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n                        newFront = oldFront._next;\n                        newCursor = 0;\n                    }\n                    // No mutations before this point.\n                    --this._size;\n                    this._cursor = newCursor;\n                    if (oldFront !== newFront) {\n                        this._front = newFront;\n                    }\n                    // Permit shifted element to be garbage collected.\n                    elements[oldCursor] = undefined;\n                    return element;\n                }\n                // The tricky thing about forEach() is that it can be called\n                // re-entrantly. The queue may be mutated inside the callback. It is easy to\n                // see that push() within the callback has no negative effects since the end\n                // of the queue is checked for on every iteration. If shift() is called\n                // repeatedly within the callback then the next iteration may return an\n                // element that has been removed. In this case the callback will be called\n                // with undefined values until we either \"catch up\" with elements that still\n                // exist or reach the back of the queue.\n                forEach(callback) {\n                    let i = this._cursor;\n                    let node = this._front;\n                    let elements = node._elements;\n                    while(i !== elements.length || node._next !== undefined){\n                        if (i === elements.length) {\n                            node = node._next;\n                            elements = node._elements;\n                            i = 0;\n                            if (elements.length === 0) {\n                                break;\n                            }\n                        }\n                        callback(elements[i]);\n                        ++i;\n                    }\n                }\n                // Return the element that would be returned if shift() was called now,\n                // without modifying the queue.\n                peek() {\n                    const front = this._front;\n                    const cursor = this._cursor;\n                    return front._elements[cursor];\n                }\n            }\n            function ReadableStreamReaderGenericInitialize(reader, stream) {\n                reader._ownerReadableStream = stream;\n                stream._reader = reader;\n                if (stream._state === \"readable\") {\n                    defaultReaderClosedPromiseInitialize(reader);\n                } else if (stream._state === \"closed\") {\n                    defaultReaderClosedPromiseInitializeAsResolved(reader);\n                } else {\n                    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n                }\n            }\n            // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n            // check.\n            function ReadableStreamReaderGenericCancel(reader, reason) {\n                const stream = reader._ownerReadableStream;\n                return ReadableStreamCancel(stream, reason);\n            }\n            function ReadableStreamReaderGenericRelease(reader) {\n                if (reader._ownerReadableStream._state === \"readable\") {\n                    defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n                } else {\n                    defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n                }\n                reader._ownerReadableStream._reader = undefined;\n                reader._ownerReadableStream = undefined;\n            }\n            // Helper functions for the readers.\n            function readerLockException(name) {\n                return new TypeError(\"Cannot \" + name + \" a stream using a released reader\");\n            }\n            // Helper functions for the ReadableStreamDefaultReader.\n            function defaultReaderClosedPromiseInitialize(reader) {\n                reader._closedPromise = newPromise((resolve, reject)=>{\n                    reader._closedPromise_resolve = resolve;\n                    reader._closedPromise_reject = reject;\n                });\n            }\n            function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n                defaultReaderClosedPromiseInitialize(reader);\n                defaultReaderClosedPromiseReject(reader, reason);\n            }\n            function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n                defaultReaderClosedPromiseInitialize(reader);\n                defaultReaderClosedPromiseResolve(reader);\n            }\n            function defaultReaderClosedPromiseReject(reader, reason) {\n                if (reader._closedPromise_reject === undefined) {\n                    return;\n                }\n                setPromiseIsHandledToTrue(reader._closedPromise);\n                reader._closedPromise_reject(reason);\n                reader._closedPromise_resolve = undefined;\n                reader._closedPromise_reject = undefined;\n            }\n            function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n                defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n            }\n            function defaultReaderClosedPromiseResolve(reader) {\n                if (reader._closedPromise_resolve === undefined) {\n                    return;\n                }\n                reader._closedPromise_resolve(undefined);\n                reader._closedPromise_resolve = undefined;\n                reader._closedPromise_reject = undefined;\n            }\n            const AbortSteps = SymbolPolyfill(\"[[AbortSteps]]\");\n            const ErrorSteps = SymbolPolyfill(\"[[ErrorSteps]]\");\n            const CancelSteps = SymbolPolyfill(\"[[CancelSteps]]\");\n            const PullSteps = SymbolPolyfill(\"[[PullSteps]]\");\n            /// <reference lib=\"es2015.core\" />\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\n            const NumberIsFinite = Number.isFinite || function(x) {\n                return typeof x === \"number\" && isFinite(x);\n            };\n            /// <reference lib=\"es2015.core\" />\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\n            const MathTrunc = Math.trunc || function(v) {\n                return v < 0 ? Math.ceil(v) : Math.floor(v);\n            };\n            // https://heycam.github.io/webidl/#idl-dictionaries\n            function isDictionary(x) {\n                return typeof x === \"object\" || typeof x === \"function\";\n            }\n            function assertDictionary(obj, context) {\n                if (obj !== undefined && !isDictionary(obj)) {\n                    throw new TypeError(`${context} is not an object.`);\n                }\n            }\n            // https://heycam.github.io/webidl/#idl-callback-functions\n            function assertFunction(x, context) {\n                if (typeof x !== \"function\") {\n                    throw new TypeError(`${context} is not a function.`);\n                }\n            }\n            // https://heycam.github.io/webidl/#idl-object\n            function isObject(x) {\n                return typeof x === \"object\" && x !== null || typeof x === \"function\";\n            }\n            function assertObject(x, context) {\n                if (!isObject(x)) {\n                    throw new TypeError(`${context} is not an object.`);\n                }\n            }\n            function assertRequiredArgument(x, position, context) {\n                if (x === undefined) {\n                    throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n                }\n            }\n            function assertRequiredField(x, field, context) {\n                if (x === undefined) {\n                    throw new TypeError(`${field} is required in '${context}'.`);\n                }\n            }\n            // https://heycam.github.io/webidl/#idl-unrestricted-double\n            function convertUnrestrictedDouble(value1) {\n                return Number(value1);\n            }\n            function censorNegativeZero(x) {\n                return x === 0 ? 0 : x;\n            }\n            function integerPart(x) {\n                return censorNegativeZero(MathTrunc(x));\n            }\n            // https://heycam.github.io/webidl/#idl-unsigned-long-long\n            function convertUnsignedLongLongWithEnforceRange(value1, context) {\n                const lowerBound = 0;\n                const upperBound = Number.MAX_SAFE_INTEGER;\n                let x = Number(value1);\n                x = censorNegativeZero(x);\n                if (!NumberIsFinite(x)) {\n                    throw new TypeError(`${context} is not a finite number`);\n                }\n                x = integerPart(x);\n                if (x < lowerBound || x > upperBound) {\n                    throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n                }\n                if (!NumberIsFinite(x) || x === 0) {\n                    return 0;\n                }\n                // TODO Use BigInt if supported?\n                // let xBigInt = BigInt(integerPart(x));\n                // xBigInt = BigInt.asUintN(64, xBigInt);\n                // return Number(xBigInt);\n                return x;\n            }\n            function assertReadableStream(x, context) {\n                if (!IsReadableStream(x)) {\n                    throw new TypeError(`${context} is not a ReadableStream.`);\n                }\n            }\n            // Abstract operations for the ReadableStream.\n            function AcquireReadableStreamDefaultReader(stream) {\n                return new ReadableStreamDefaultReader(stream);\n            }\n            // ReadableStream API exposed for controllers.\n            function ReadableStreamAddReadRequest(stream, readRequest) {\n                stream._reader._readRequests.push(readRequest);\n            }\n            function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n                const reader = stream._reader;\n                const readRequest = reader._readRequests.shift();\n                if (done) {\n                    readRequest._closeSteps();\n                } else {\n                    readRequest._chunkSteps(chunk);\n                }\n            }\n            function ReadableStreamGetNumReadRequests(stream) {\n                return stream._reader._readRequests.length;\n            }\n            function ReadableStreamHasDefaultReader(stream) {\n                const reader = stream._reader;\n                if (reader === undefined) {\n                    return false;\n                }\n                if (!IsReadableStreamDefaultReader(reader)) {\n                    return false;\n                }\n                return true;\n            }\n            /**\n\t\t     * A default reader vended by a {@link ReadableStream}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStreamDefaultReader {\n                constructor(stream){\n                    assertRequiredArgument(stream, 1, \"ReadableStreamDefaultReader\");\n                    assertReadableStream(stream, \"First parameter\");\n                    if (IsReadableStreamLocked(stream)) {\n                        throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n                    }\n                    ReadableStreamReaderGenericInitialize(this, stream);\n                    this._readRequests = new SimpleQueue();\n                }\n                /**\n\t\t         * Returns a promise that will be fulfilled when the stream becomes closed,\n\t\t         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n\t\t         */ get closed() {\n                    if (!IsReadableStreamDefaultReader(this)) {\n                        return promiseRejectedWith(defaultReaderBrandCheckException(\"closed\"));\n                    }\n                    return this._closedPromise;\n                }\n                /**\n\t\t         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n\t\t         */ cancel(reason = undefined) {\n                    if (!IsReadableStreamDefaultReader(this)) {\n                        return promiseRejectedWith(defaultReaderBrandCheckException(\"cancel\"));\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"cancel\"));\n                    }\n                    return ReadableStreamReaderGenericCancel(this, reason);\n                }\n                /**\n\t\t         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n\t\t         *\n\t\t         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n\t\t         */ read() {\n                    if (!IsReadableStreamDefaultReader(this)) {\n                        return promiseRejectedWith(defaultReaderBrandCheckException(\"read\"));\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"read from\"));\n                    }\n                    let resolvePromise;\n                    let rejectPromise;\n                    const promise = newPromise((resolve, reject)=>{\n                        resolvePromise = resolve;\n                        rejectPromise = reject;\n                    });\n                    const readRequest = {\n                        _chunkSteps: (chunk)=>resolvePromise({\n                                value: chunk,\n                                done: false\n                            }),\n                        _closeSteps: ()=>resolvePromise({\n                                value: undefined,\n                                done: true\n                            }),\n                        _errorSteps: (e)=>rejectPromise(e)\n                    };\n                    ReadableStreamDefaultReaderRead(this, readRequest);\n                    return promise;\n                }\n                /**\n\t\t         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n\t\t         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n\t\t         * from now on; otherwise, the reader will appear closed.\n\t\t         *\n\t\t         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n\t\t         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n\t\t         * do so will throw a `TypeError` and leave the reader locked to the stream.\n\t\t         */ releaseLock() {\n                    if (!IsReadableStreamDefaultReader(this)) {\n                        throw defaultReaderBrandCheckException(\"releaseLock\");\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return;\n                    }\n                    if (this._readRequests.length > 0) {\n                        throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n                    }\n                    ReadableStreamReaderGenericRelease(this);\n                }\n            }\n            Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n                cancel: {\n                    enumerable: true\n                },\n                read: {\n                    enumerable: true\n                },\n                releaseLock: {\n                    enumerable: true\n                },\n                closed: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStreamDefaultReader\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the readers.\n            function IsReadableStreamDefaultReader(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_readRequests\")) {\n                    return false;\n                }\n                return x instanceof ReadableStreamDefaultReader;\n            }\n            function ReadableStreamDefaultReaderRead(reader, readRequest) {\n                const stream = reader._ownerReadableStream;\n                stream._disturbed = true;\n                if (stream._state === \"closed\") {\n                    readRequest._closeSteps();\n                } else if (stream._state === \"errored\") {\n                    readRequest._errorSteps(stream._storedError);\n                } else {\n                    stream._readableStreamController[PullSteps](readRequest);\n                }\n            }\n            // Helper functions for the ReadableStreamDefaultReader.\n            function defaultReaderBrandCheckException(name) {\n                return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n            }\n            /// <reference lib=\"es2018.asynciterable\" />\n            /* eslint-disable @typescript-eslint/no-empty-function */ const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);\n            /// <reference lib=\"es2018.asynciterable\" />\n            class ReadableStreamAsyncIteratorImpl {\n                constructor(reader, preventCancel){\n                    this._ongoingPromise = undefined;\n                    this._isFinished = false;\n                    this._reader = reader;\n                    this._preventCancel = preventCancel;\n                }\n                next() {\n                    const nextSteps = ()=>this._nextSteps();\n                    this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();\n                    return this._ongoingPromise;\n                }\n                return(value1) {\n                    const returnSteps = ()=>this._returnSteps(value1);\n                    return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();\n                }\n                _nextSteps() {\n                    if (this._isFinished) {\n                        return Promise.resolve({\n                            value: undefined,\n                            done: true\n                        });\n                    }\n                    const reader = this._reader;\n                    if (reader._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"iterate\"));\n                    }\n                    let resolvePromise;\n                    let rejectPromise;\n                    const promise = newPromise((resolve, reject)=>{\n                        resolvePromise = resolve;\n                        rejectPromise = reject;\n                    });\n                    const readRequest = {\n                        _chunkSteps: (chunk)=>{\n                            this._ongoingPromise = undefined;\n                            // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                            // FIXME Is this a bug in the specification, or in the test?\n                            queueMicrotask(()=>resolvePromise({\n                                    value: chunk,\n                                    done: false\n                                }));\n                        },\n                        _closeSteps: ()=>{\n                            this._ongoingPromise = undefined;\n                            this._isFinished = true;\n                            ReadableStreamReaderGenericRelease(reader);\n                            resolvePromise({\n                                value: undefined,\n                                done: true\n                            });\n                        },\n                        _errorSteps: (reason)=>{\n                            this._ongoingPromise = undefined;\n                            this._isFinished = true;\n                            ReadableStreamReaderGenericRelease(reader);\n                            rejectPromise(reason);\n                        }\n                    };\n                    ReadableStreamDefaultReaderRead(reader, readRequest);\n                    return promise;\n                }\n                _returnSteps(value1) {\n                    if (this._isFinished) {\n                        return Promise.resolve({\n                            value: value1,\n                            done: true\n                        });\n                    }\n                    this._isFinished = true;\n                    const reader = this._reader;\n                    if (reader._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"finish iterating\"));\n                    }\n                    if (!this._preventCancel) {\n                        const result = ReadableStreamReaderGenericCancel(reader, value1);\n                        ReadableStreamReaderGenericRelease(reader);\n                        return transformPromiseWith(result, ()=>({\n                                value: value1,\n                                done: true\n                            }));\n                    }\n                    ReadableStreamReaderGenericRelease(reader);\n                    return promiseResolvedWith({\n                        value: value1,\n                        done: true\n                    });\n                }\n            }\n            const ReadableStreamAsyncIteratorPrototype = {\n                next () {\n                    if (!IsReadableStreamAsyncIterator(this)) {\n                        return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"next\"));\n                    }\n                    return this._asyncIteratorImpl.next();\n                },\n                return (value1) {\n                    if (!IsReadableStreamAsyncIterator(this)) {\n                        return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"return\"));\n                    }\n                    return this._asyncIteratorImpl.return(value1);\n                }\n            };\n            if (AsyncIteratorPrototype !== undefined) {\n                Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n            }\n            // Abstract operations for the ReadableStream.\n            function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n                const reader = AcquireReadableStreamDefaultReader(stream);\n                const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n                const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n                iterator._asyncIteratorImpl = impl;\n                return iterator;\n            }\n            function IsReadableStreamAsyncIterator(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_asyncIteratorImpl\")) {\n                    return false;\n                }\n                try {\n                    // noinspection SuspiciousTypeOfGuard\n                    return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;\n                } catch (_a) {\n                    return false;\n                }\n            }\n            // Helper functions for the ReadableStream.\n            function streamAsyncIteratorBrandCheckException(name) {\n                return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n            }\n            /// <reference lib=\"es2015.core\" />\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\n            const NumberIsNaN = Number.isNaN || function(x) {\n                // eslint-disable-next-line no-self-compare\n                return x !== x;\n            };\n            function CreateArrayFromList(elements) {\n                // We use arrays to represent lists, so this is basically a no-op.\n                // Do a slice though just in case we happen to depend on the unique-ness.\n                return elements.slice();\n            }\n            function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n                new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n            }\n            // Not implemented correctly\n            function TransferArrayBuffer(O) {\n                return O;\n            }\n            // Not implemented correctly\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            function IsDetachedBuffer(O) {\n                return false;\n            }\n            function ArrayBufferSlice(buffer, begin, end) {\n                // ArrayBuffer.prototype.slice is not available on IE10\n                // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n                if (buffer.slice) {\n                    return buffer.slice(begin, end);\n                }\n                const length = end - begin;\n                const slice = new ArrayBuffer(length);\n                CopyDataBlockBytes(slice, 0, buffer, begin, length);\n                return slice;\n            }\n            function IsNonNegativeNumber(v) {\n                if (typeof v !== \"number\") {\n                    return false;\n                }\n                if (NumberIsNaN(v)) {\n                    return false;\n                }\n                if (v < 0) {\n                    return false;\n                }\n                return true;\n            }\n            function CloneAsUint8Array(O) {\n                const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n                return new Uint8Array(buffer);\n            }\n            function DequeueValue(container) {\n                const pair = container._queue.shift();\n                container._queueTotalSize -= pair.size;\n                if (container._queueTotalSize < 0) {\n                    container._queueTotalSize = 0;\n                }\n                return pair.value;\n            }\n            function EnqueueValueWithSize(container, value1, size) {\n                if (!IsNonNegativeNumber(size) || size === Infinity) {\n                    throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n                }\n                container._queue.push({\n                    value: value1,\n                    size\n                });\n                container._queueTotalSize += size;\n            }\n            function PeekQueueValue(container) {\n                const pair = container._queue.peek();\n                return pair.value;\n            }\n            function ResetQueue(container) {\n                container._queue = new SimpleQueue();\n                container._queueTotalSize = 0;\n            }\n            /**\n\t\t     * A pull-into request in a {@link ReadableByteStreamController}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStreamBYOBRequest {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n\t\t         */ get view() {\n                    if (!IsReadableStreamBYOBRequest(this)) {\n                        throw byobRequestBrandCheckException(\"view\");\n                    }\n                    return this._view;\n                }\n                respond(bytesWritten) {\n                    if (!IsReadableStreamBYOBRequest(this)) {\n                        throw byobRequestBrandCheckException(\"respond\");\n                    }\n                    assertRequiredArgument(bytesWritten, 1, \"respond\");\n                    bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, \"First parameter\");\n                    if (this._associatedReadableByteStreamController === undefined) {\n                        throw new TypeError(\"This BYOB request has been invalidated\");\n                    }\n                    if (IsDetachedBuffer(this._view.buffer)) ;\n                    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n                }\n                respondWithNewView(view) {\n                    if (!IsReadableStreamBYOBRequest(this)) {\n                        throw byobRequestBrandCheckException(\"respondWithNewView\");\n                    }\n                    assertRequiredArgument(view, 1, \"respondWithNewView\");\n                    if (!ArrayBuffer.isView(view)) {\n                        throw new TypeError(\"You can only respond with array buffer views\");\n                    }\n                    if (this._associatedReadableByteStreamController === undefined) {\n                        throw new TypeError(\"This BYOB request has been invalidated\");\n                    }\n                    if (IsDetachedBuffer(view.buffer)) ;\n                    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n                }\n            }\n            Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n                respond: {\n                    enumerable: true\n                },\n                respondWithNewView: {\n                    enumerable: true\n                },\n                view: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStreamBYOBRequest\",\n                    configurable: true\n                });\n            }\n            /**\n\t\t     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableByteStreamController {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * Returns the current BYOB pull request, or `null` if there isn't one.\n\t\t         */ get byobRequest() {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"byobRequest\");\n                    }\n                    return ReadableByteStreamControllerGetBYOBRequest(this);\n                }\n                /**\n\t\t         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n\t\t         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n\t\t         */ get desiredSize() {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"desiredSize\");\n                    }\n                    return ReadableByteStreamControllerGetDesiredSize(this);\n                }\n                /**\n\t\t         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n\t\t         * the stream, but once those are read, the stream will become closed.\n\t\t         */ close() {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"close\");\n                    }\n                    if (this._closeRequested) {\n                        throw new TypeError(\"The stream has already been closed; do not close it again!\");\n                    }\n                    const state = this._controlledReadableByteStream._state;\n                    if (state !== \"readable\") {\n                        throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n                    }\n                    ReadableByteStreamControllerClose(this);\n                }\n                enqueue(chunk) {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"enqueue\");\n                    }\n                    assertRequiredArgument(chunk, 1, \"enqueue\");\n                    if (!ArrayBuffer.isView(chunk)) {\n                        throw new TypeError(\"chunk must be an array buffer view\");\n                    }\n                    if (chunk.byteLength === 0) {\n                        throw new TypeError(\"chunk must have non-zero byteLength\");\n                    }\n                    if (chunk.buffer.byteLength === 0) {\n                        throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n                    }\n                    if (this._closeRequested) {\n                        throw new TypeError(\"stream is closed or draining\");\n                    }\n                    const state = this._controlledReadableByteStream._state;\n                    if (state !== \"readable\") {\n                        throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n                    }\n                    ReadableByteStreamControllerEnqueue(this, chunk);\n                }\n                /**\n\t\t         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n\t\t         */ error(e = undefined) {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"error\");\n                    }\n                    ReadableByteStreamControllerError(this, e);\n                }\n                /** @internal */ [CancelSteps](reason) {\n                    ReadableByteStreamControllerClearPendingPullIntos(this);\n                    ResetQueue(this);\n                    const result = this._cancelAlgorithm(reason);\n                    ReadableByteStreamControllerClearAlgorithms(this);\n                    return result;\n                }\n                /** @internal */ [PullSteps](readRequest) {\n                    const stream = this._controlledReadableByteStream;\n                    if (this._queueTotalSize > 0) {\n                        const entry = this._queue.shift();\n                        this._queueTotalSize -= entry.byteLength;\n                        ReadableByteStreamControllerHandleQueueDrain(this);\n                        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n                        readRequest._chunkSteps(view);\n                        return;\n                    }\n                    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n                    if (autoAllocateChunkSize !== undefined) {\n                        let buffer;\n                        try {\n                            buffer = new ArrayBuffer(autoAllocateChunkSize);\n                        } catch (bufferE) {\n                            readRequest._errorSteps(bufferE);\n                            return;\n                        }\n                        const pullIntoDescriptor = {\n                            buffer,\n                            bufferByteLength: autoAllocateChunkSize,\n                            byteOffset: 0,\n                            byteLength: autoAllocateChunkSize,\n                            bytesFilled: 0,\n                            elementSize: 1,\n                            viewConstructor: Uint8Array,\n                            readerType: \"default\"\n                        };\n                        this._pendingPullIntos.push(pullIntoDescriptor);\n                    }\n                    ReadableStreamAddReadRequest(stream, readRequest);\n                    ReadableByteStreamControllerCallPullIfNeeded(this);\n                }\n            }\n            Object.defineProperties(ReadableByteStreamController.prototype, {\n                close: {\n                    enumerable: true\n                },\n                enqueue: {\n                    enumerable: true\n                },\n                error: {\n                    enumerable: true\n                },\n                byobRequest: {\n                    enumerable: true\n                },\n                desiredSize: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableByteStreamController\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the ReadableByteStreamController.\n            function IsReadableByteStreamController(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableByteStream\")) {\n                    return false;\n                }\n                return x instanceof ReadableByteStreamController;\n            }\n            function IsReadableStreamBYOBRequest(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_associatedReadableByteStreamController\")) {\n                    return false;\n                }\n                return x instanceof ReadableStreamBYOBRequest;\n            }\n            function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n                const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n                if (!shouldPull) {\n                    return;\n                }\n                if (controller._pulling) {\n                    controller._pullAgain = true;\n                    return;\n                }\n                controller._pulling = true;\n                // TODO: Test controller argument\n                const pullPromise = controller._pullAlgorithm();\n                uponPromise(pullPromise, ()=>{\n                    controller._pulling = false;\n                    if (controller._pullAgain) {\n                        controller._pullAgain = false;\n                        ReadableByteStreamControllerCallPullIfNeeded(controller);\n                    }\n                }, (e)=>{\n                    ReadableByteStreamControllerError(controller, e);\n                });\n            }\n            function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n                ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n                controller._pendingPullIntos = new SimpleQueue();\n            }\n            function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n                let done = false;\n                if (stream._state === \"closed\") {\n                    done = true;\n                }\n                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                if (pullIntoDescriptor.readerType === \"default\") {\n                    ReadableStreamFulfillReadRequest(stream, filledView, done);\n                } else {\n                    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n                }\n            }\n            function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n                const bytesFilled = pullIntoDescriptor.bytesFilled;\n                const elementSize = pullIntoDescriptor.elementSize;\n                return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n            }\n            function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n                controller._queue.push({\n                    buffer,\n                    byteOffset,\n                    byteLength\n                });\n                controller._queueTotalSize += byteLength;\n            }\n            function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n                const elementSize = pullIntoDescriptor.elementSize;\n                const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n                const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n                const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n                const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n                let totalBytesToCopyRemaining = maxBytesToCopy;\n                let ready = false;\n                if (maxAlignedBytes > currentAlignedBytes) {\n                    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n                    ready = true;\n                }\n                const queue = controller._queue;\n                while(totalBytesToCopyRemaining > 0){\n                    const headOfQueue = queue.peek();\n                    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n                    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n                    CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n                    if (headOfQueue.byteLength === bytesToCopy) {\n                        queue.shift();\n                    } else {\n                        headOfQueue.byteOffset += bytesToCopy;\n                        headOfQueue.byteLength -= bytesToCopy;\n                    }\n                    controller._queueTotalSize -= bytesToCopy;\n                    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n                    totalBytesToCopyRemaining -= bytesToCopy;\n                }\n                return ready;\n            }\n            function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n                pullIntoDescriptor.bytesFilled += size;\n            }\n            function ReadableByteStreamControllerHandleQueueDrain(controller) {\n                if (controller._queueTotalSize === 0 && controller._closeRequested) {\n                    ReadableByteStreamControllerClearAlgorithms(controller);\n                    ReadableStreamClose(controller._controlledReadableByteStream);\n                } else {\n                    ReadableByteStreamControllerCallPullIfNeeded(controller);\n                }\n            }\n            function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n                if (controller._byobRequest === null) {\n                    return;\n                }\n                controller._byobRequest._associatedReadableByteStreamController = undefined;\n                controller._byobRequest._view = null;\n                controller._byobRequest = null;\n            }\n            function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n                while(controller._pendingPullIntos.length > 0){\n                    if (controller._queueTotalSize === 0) {\n                        return;\n                    }\n                    const pullIntoDescriptor = controller._pendingPullIntos.peek();\n                    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                        ReadableByteStreamControllerShiftPendingPullInto(controller);\n                        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n                    }\n                }\n            }\n            function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n                const stream = controller._controlledReadableByteStream;\n                let elementSize = 1;\n                if (view.constructor !== DataView) {\n                    elementSize = view.constructor.BYTES_PER_ELEMENT;\n                }\n                const ctor = view.constructor;\n                // try {\n                const buffer = TransferArrayBuffer(view.buffer);\n                // } catch (e) {\n                //   readIntoRequest._errorSteps(e);\n                //   return;\n                // }\n                const pullIntoDescriptor = {\n                    buffer,\n                    bufferByteLength: buffer.byteLength,\n                    byteOffset: view.byteOffset,\n                    byteLength: view.byteLength,\n                    bytesFilled: 0,\n                    elementSize,\n                    viewConstructor: ctor,\n                    readerType: \"byob\"\n                };\n                if (controller._pendingPullIntos.length > 0) {\n                    controller._pendingPullIntos.push(pullIntoDescriptor);\n                    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n                    // - No change happens on desiredSize\n                    // - The source has already been notified of that there's at least 1 pending read(view)\n                    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n                    return;\n                }\n                if (stream._state === \"closed\") {\n                    const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n                    readIntoRequest._closeSteps(emptyView);\n                    return;\n                }\n                if (controller._queueTotalSize > 0) {\n                    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                        ReadableByteStreamControllerHandleQueueDrain(controller);\n                        readIntoRequest._chunkSteps(filledView);\n                        return;\n                    }\n                    if (controller._closeRequested) {\n                        const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                        ReadableByteStreamControllerError(controller, e);\n                        readIntoRequest._errorSteps(e);\n                        return;\n                    }\n                }\n                controller._pendingPullIntos.push(pullIntoDescriptor);\n                ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n            function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n                const stream = controller._controlledReadableByteStream;\n                if (ReadableStreamHasBYOBReader(stream)) {\n                    while(ReadableStreamGetNumReadIntoRequests(stream) > 0){\n                        const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n                        ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n                    }\n                }\n            }\n            function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n                ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n                if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n                    return;\n                }\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\n                const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n                if (remainderSize > 0) {\n                    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n                    const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n                    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n                }\n                pullIntoDescriptor.bytesFilled -= remainderSize;\n                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n                ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n            }\n            function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n                const firstDescriptor = controller._pendingPullIntos.peek();\n                ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n                const state = controller._controlledReadableByteStream._state;\n                if (state === \"closed\") {\n                    ReadableByteStreamControllerRespondInClosedState(controller);\n                } else {\n                    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n                }\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n            function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n                const descriptor = controller._pendingPullIntos.shift();\n                return descriptor;\n            }\n            function ReadableByteStreamControllerShouldCallPull(controller) {\n                const stream = controller._controlledReadableByteStream;\n                if (stream._state !== \"readable\") {\n                    return false;\n                }\n                if (controller._closeRequested) {\n                    return false;\n                }\n                if (!controller._started) {\n                    return false;\n                }\n                if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n                    return true;\n                }\n                if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n                    return true;\n                }\n                const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n                if (desiredSize > 0) {\n                    return true;\n                }\n                return false;\n            }\n            function ReadableByteStreamControllerClearAlgorithms(controller) {\n                controller._pullAlgorithm = undefined;\n                controller._cancelAlgorithm = undefined;\n            }\n            // A client of ReadableByteStreamController may use these functions directly to bypass state check.\n            function ReadableByteStreamControllerClose(controller) {\n                const stream = controller._controlledReadableByteStream;\n                if (controller._closeRequested || stream._state !== \"readable\") {\n                    return;\n                }\n                if (controller._queueTotalSize > 0) {\n                    controller._closeRequested = true;\n                    return;\n                }\n                if (controller._pendingPullIntos.length > 0) {\n                    const firstPendingPullInto = controller._pendingPullIntos.peek();\n                    if (firstPendingPullInto.bytesFilled > 0) {\n                        const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                        ReadableByteStreamControllerError(controller, e);\n                        throw e;\n                    }\n                }\n                ReadableByteStreamControllerClearAlgorithms(controller);\n                ReadableStreamClose(stream);\n            }\n            function ReadableByteStreamControllerEnqueue(controller, chunk) {\n                const stream = controller._controlledReadableByteStream;\n                if (controller._closeRequested || stream._state !== \"readable\") {\n                    return;\n                }\n                const buffer = chunk.buffer;\n                const byteOffset = chunk.byteOffset;\n                const byteLength = chunk.byteLength;\n                const transferredBuffer = TransferArrayBuffer(buffer);\n                if (controller._pendingPullIntos.length > 0) {\n                    const firstPendingPullInto = controller._pendingPullIntos.peek();\n                    if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;\n                    firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n                }\n                ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n                if (ReadableStreamHasDefaultReader(stream)) {\n                    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n                        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n                    } else {\n                        if (controller._pendingPullIntos.length > 0) {\n                            ReadableByteStreamControllerShiftPendingPullInto(controller);\n                        }\n                        const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n                        ReadableStreamFulfillReadRequest(stream, transferredView, false);\n                    }\n                } else if (ReadableStreamHasBYOBReader(stream)) {\n                    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n                    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n                    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n                } else {\n                    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n                }\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n            function ReadableByteStreamControllerError(controller, e) {\n                const stream = controller._controlledReadableByteStream;\n                if (stream._state !== \"readable\") {\n                    return;\n                }\n                ReadableByteStreamControllerClearPendingPullIntos(controller);\n                ResetQueue(controller);\n                ReadableByteStreamControllerClearAlgorithms(controller);\n                ReadableStreamError(stream, e);\n            }\n            function ReadableByteStreamControllerGetBYOBRequest(controller) {\n                if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n                    const firstDescriptor = controller._pendingPullIntos.peek();\n                    const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n                    const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n                    SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n                    controller._byobRequest = byobRequest;\n                }\n                return controller._byobRequest;\n            }\n            function ReadableByteStreamControllerGetDesiredSize(controller) {\n                const state = controller._controlledReadableByteStream._state;\n                if (state === \"errored\") {\n                    return null;\n                }\n                if (state === \"closed\") {\n                    return 0;\n                }\n                return controller._strategyHWM - controller._queueTotalSize;\n            }\n            function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n                const firstDescriptor = controller._pendingPullIntos.peek();\n                const state = controller._controlledReadableByteStream._state;\n                if (state === \"closed\") {\n                    if (bytesWritten !== 0) {\n                        throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n                    }\n                } else {\n                    if (bytesWritten === 0) {\n                        throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n                    }\n                    if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n                        throw new RangeError(\"bytesWritten out of range\");\n                    }\n                }\n                firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n                ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n            }\n            function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n                const firstDescriptor = controller._pendingPullIntos.peek();\n                const state = controller._controlledReadableByteStream._state;\n                if (state === \"closed\") {\n                    if (view.byteLength !== 0) {\n                        throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n                    }\n                } else {\n                    if (view.byteLength === 0) {\n                        throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n                    }\n                }\n                if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n                    throw new RangeError(\"The region specified by view does not match byobRequest\");\n                }\n                if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n                    throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n                }\n                if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n                    throw new RangeError(\"The region specified by view is larger than byobRequest\");\n                }\n                const viewByteLength = view.byteLength;\n                firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n                ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n            }\n            function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n                controller._controlledReadableByteStream = stream;\n                controller._pullAgain = false;\n                controller._pulling = false;\n                controller._byobRequest = null;\n                // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n                controller._queue = controller._queueTotalSize = undefined;\n                ResetQueue(controller);\n                controller._closeRequested = false;\n                controller._started = false;\n                controller._strategyHWM = highWaterMark;\n                controller._pullAlgorithm = pullAlgorithm;\n                controller._cancelAlgorithm = cancelAlgorithm;\n                controller._autoAllocateChunkSize = autoAllocateChunkSize;\n                controller._pendingPullIntos = new SimpleQueue();\n                stream._readableStreamController = controller;\n                const startResult = startAlgorithm();\n                uponPromise(promiseResolvedWith(startResult), ()=>{\n                    controller._started = true;\n                    ReadableByteStreamControllerCallPullIfNeeded(controller);\n                }, (r)=>{\n                    ReadableByteStreamControllerError(controller, r);\n                });\n            }\n            function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n                const controller = Object.create(ReadableByteStreamController.prototype);\n                let startAlgorithm = ()=>undefined;\n                let pullAlgorithm = ()=>promiseResolvedWith(undefined);\n                let cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n                if (underlyingByteSource.start !== undefined) {\n                    startAlgorithm = ()=>underlyingByteSource.start(controller);\n                }\n                if (underlyingByteSource.pull !== undefined) {\n                    pullAlgorithm = ()=>underlyingByteSource.pull(controller);\n                }\n                if (underlyingByteSource.cancel !== undefined) {\n                    cancelAlgorithm = (reason)=>underlyingByteSource.cancel(reason);\n                }\n                const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n                if (autoAllocateChunkSize === 0) {\n                    throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n                }\n                SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n            }\n            function SetUpReadableStreamBYOBRequest(request, controller, view) {\n                request._associatedReadableByteStreamController = controller;\n                request._view = view;\n            }\n            // Helper functions for the ReadableStreamBYOBRequest.\n            function byobRequestBrandCheckException(name) {\n                return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n            }\n            // Helper functions for the ReadableByteStreamController.\n            function byteStreamControllerBrandCheckException(name) {\n                return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n            }\n            // Abstract operations for the ReadableStream.\n            function AcquireReadableStreamBYOBReader(stream) {\n                return new ReadableStreamBYOBReader(stream);\n            }\n            // ReadableStream API exposed for controllers.\n            function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n                stream._reader._readIntoRequests.push(readIntoRequest);\n            }\n            function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n                const reader = stream._reader;\n                const readIntoRequest = reader._readIntoRequests.shift();\n                if (done) {\n                    readIntoRequest._closeSteps(chunk);\n                } else {\n                    readIntoRequest._chunkSteps(chunk);\n                }\n            }\n            function ReadableStreamGetNumReadIntoRequests(stream) {\n                return stream._reader._readIntoRequests.length;\n            }\n            function ReadableStreamHasBYOBReader(stream) {\n                const reader = stream._reader;\n                if (reader === undefined) {\n                    return false;\n                }\n                if (!IsReadableStreamBYOBReader(reader)) {\n                    return false;\n                }\n                return true;\n            }\n            /**\n\t\t     * A BYOB reader vended by a {@link ReadableStream}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStreamBYOBReader {\n                constructor(stream){\n                    assertRequiredArgument(stream, 1, \"ReadableStreamBYOBReader\");\n                    assertReadableStream(stream, \"First parameter\");\n                    if (IsReadableStreamLocked(stream)) {\n                        throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n                    }\n                    if (!IsReadableByteStreamController(stream._readableStreamController)) {\n                        throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte \" + \"source\");\n                    }\n                    ReadableStreamReaderGenericInitialize(this, stream);\n                    this._readIntoRequests = new SimpleQueue();\n                }\n                /**\n\t\t         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n\t\t         * the reader's lock is released before the stream finishes closing.\n\t\t         */ get closed() {\n                    if (!IsReadableStreamBYOBReader(this)) {\n                        return promiseRejectedWith(byobReaderBrandCheckException(\"closed\"));\n                    }\n                    return this._closedPromise;\n                }\n                /**\n\t\t         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n\t\t         */ cancel(reason = undefined) {\n                    if (!IsReadableStreamBYOBReader(this)) {\n                        return promiseRejectedWith(byobReaderBrandCheckException(\"cancel\"));\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"cancel\"));\n                    }\n                    return ReadableStreamReaderGenericCancel(this, reason);\n                }\n                /**\n\t\t         * Attempts to reads bytes into view, and returns a promise resolved with the result.\n\t\t         *\n\t\t         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n\t\t         */ read(view) {\n                    if (!IsReadableStreamBYOBReader(this)) {\n                        return promiseRejectedWith(byobReaderBrandCheckException(\"read\"));\n                    }\n                    if (!ArrayBuffer.isView(view)) {\n                        return promiseRejectedWith(new TypeError(\"view must be an array buffer view\"));\n                    }\n                    if (view.byteLength === 0) {\n                        return promiseRejectedWith(new TypeError(\"view must have non-zero byteLength\"));\n                    }\n                    if (view.buffer.byteLength === 0) {\n                        return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n                    }\n                    if (IsDetachedBuffer(view.buffer)) ;\n                    if (this._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"read from\"));\n                    }\n                    let resolvePromise;\n                    let rejectPromise;\n                    const promise = newPromise((resolve, reject)=>{\n                        resolvePromise = resolve;\n                        rejectPromise = reject;\n                    });\n                    const readIntoRequest = {\n                        _chunkSteps: (chunk)=>resolvePromise({\n                                value: chunk,\n                                done: false\n                            }),\n                        _closeSteps: (chunk)=>resolvePromise({\n                                value: chunk,\n                                done: true\n                            }),\n                        _errorSteps: (e)=>rejectPromise(e)\n                    };\n                    ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n                    return promise;\n                }\n                /**\n\t\t         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n\t\t         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n\t\t         * from now on; otherwise, the reader will appear closed.\n\t\t         *\n\t\t         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n\t\t         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n\t\t         * do so will throw a `TypeError` and leave the reader locked to the stream.\n\t\t         */ releaseLock() {\n                    if (!IsReadableStreamBYOBReader(this)) {\n                        throw byobReaderBrandCheckException(\"releaseLock\");\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return;\n                    }\n                    if (this._readIntoRequests.length > 0) {\n                        throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n                    }\n                    ReadableStreamReaderGenericRelease(this);\n                }\n            }\n            Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n                cancel: {\n                    enumerable: true\n                },\n                read: {\n                    enumerable: true\n                },\n                releaseLock: {\n                    enumerable: true\n                },\n                closed: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStreamBYOBReader\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the readers.\n            function IsReadableStreamBYOBReader(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_readIntoRequests\")) {\n                    return false;\n                }\n                return x instanceof ReadableStreamBYOBReader;\n            }\n            function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n                const stream = reader._ownerReadableStream;\n                stream._disturbed = true;\n                if (stream._state === \"errored\") {\n                    readIntoRequest._errorSteps(stream._storedError);\n                } else {\n                    ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n                }\n            }\n            // Helper functions for the ReadableStreamBYOBReader.\n            function byobReaderBrandCheckException(name) {\n                return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n            }\n            function ExtractHighWaterMark(strategy, defaultHWM) {\n                const { highWaterMark } = strategy;\n                if (highWaterMark === undefined) {\n                    return defaultHWM;\n                }\n                if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n                    throw new RangeError(\"Invalid highWaterMark\");\n                }\n                return highWaterMark;\n            }\n            function ExtractSizeAlgorithm(strategy) {\n                const { size } = strategy;\n                if (!size) {\n                    return ()=>1;\n                }\n                return size;\n            }\n            function convertQueuingStrategy(init, context) {\n                assertDictionary(init, context);\n                const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n                const size = init === null || init === void 0 ? void 0 : init.size;\n                return {\n                    highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n                    size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n                };\n            }\n            function convertQueuingStrategySize(fn, context) {\n                assertFunction(fn, context);\n                return (chunk)=>convertUnrestrictedDouble(fn(chunk));\n            }\n            function convertUnderlyingSink(original, context) {\n                assertDictionary(original, context);\n                const abort = original === null || original === void 0 ? void 0 : original.abort;\n                const close = original === null || original === void 0 ? void 0 : original.close;\n                const start = original === null || original === void 0 ? void 0 : original.start;\n                const type = original === null || original === void 0 ? void 0 : original.type;\n                const write = original === null || original === void 0 ? void 0 : original.write;\n                return {\n                    abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n                    close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n                    start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n                    write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n                    type\n                };\n            }\n            function convertUnderlyingSinkAbortCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (reason)=>promiseCall(fn, original, [\n                        reason\n                    ]);\n            }\n            function convertUnderlyingSinkCloseCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return ()=>promiseCall(fn, original, []);\n            }\n            function convertUnderlyingSinkStartCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>reflectCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertUnderlyingSinkWriteCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (chunk, controller)=>promiseCall(fn, original, [\n                        chunk,\n                        controller\n                    ]);\n            }\n            function assertWritableStream(x, context) {\n                if (!IsWritableStream(x)) {\n                    throw new TypeError(`${context} is not a WritableStream.`);\n                }\n            }\n            function isAbortSignal(value1) {\n                if (typeof value1 !== \"object\" || value1 === null) {\n                    return false;\n                }\n                try {\n                    return typeof value1.aborted === \"boolean\";\n                } catch (_a) {\n                    // AbortSignal.prototype.aborted throws if its brand check fails\n                    return false;\n                }\n            }\n            const supportsAbortController = typeof AbortController === \"function\";\n            /**\n\t\t     * Construct a new AbortController, if supported by the platform.\n\t\t     *\n\t\t     * @internal\n\t\t     */ function createAbortController() {\n                if (supportsAbortController) {\n                    return new AbortController();\n                }\n                return undefined;\n            }\n            /**\n\t\t     * A writable stream represents a destination for data, into which you can write.\n\t\t     *\n\t\t     * @public\n\t\t     */ class WritableStream {\n                constructor(rawUnderlyingSink = {}, rawStrategy = {}){\n                    if (rawUnderlyingSink === undefined) {\n                        rawUnderlyingSink = null;\n                    } else {\n                        assertObject(rawUnderlyingSink, \"First parameter\");\n                    }\n                    const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n                    const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, \"First parameter\");\n                    InitializeWritableStream(this);\n                    const type = underlyingSink.type;\n                    if (type !== undefined) {\n                        throw new RangeError(\"Invalid type is specified\");\n                    }\n                    const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                    const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n                }\n                /**\n\t\t         * Returns whether or not the writable stream is locked to a writer.\n\t\t         */ get locked() {\n                    if (!IsWritableStream(this)) {\n                        throw streamBrandCheckException$2(\"locked\");\n                    }\n                    return IsWritableStreamLocked(this);\n                }\n                /**\n\t\t         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n\t\t         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n\t\t         * mechanism of the underlying sink.\n\t\t         *\n\t\t         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n\t\t         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n\t\t         * the stream) if the stream is currently locked.\n\t\t         */ abort(reason = undefined) {\n                    if (!IsWritableStream(this)) {\n                        return promiseRejectedWith(streamBrandCheckException$2(\"abort\"));\n                    }\n                    if (IsWritableStreamLocked(this)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot abort a stream that already has a writer\"));\n                    }\n                    return WritableStreamAbort(this, reason);\n                }\n                /**\n\t\t         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n\t\t         * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n\t\t         *\n\t\t         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n\t\t         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n\t\t         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n\t\t         */ close() {\n                    if (!IsWritableStream(this)) {\n                        return promiseRejectedWith(streamBrandCheckException$2(\"close\"));\n                    }\n                    if (IsWritableStreamLocked(this)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot close a stream that already has a writer\"));\n                    }\n                    if (WritableStreamCloseQueuedOrInFlight(this)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n                    }\n                    return WritableStreamClose(this);\n                }\n                /**\n\t\t         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n\t\t         * is locked, no other writer can be acquired until this one is released.\n\t\t         *\n\t\t         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n\t\t         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n\t\t         * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n\t\t         */ getWriter() {\n                    if (!IsWritableStream(this)) {\n                        throw streamBrandCheckException$2(\"getWriter\");\n                    }\n                    return AcquireWritableStreamDefaultWriter(this);\n                }\n            }\n            Object.defineProperties(WritableStream.prototype, {\n                abort: {\n                    enumerable: true\n                },\n                close: {\n                    enumerable: true\n                },\n                getWriter: {\n                    enumerable: true\n                },\n                locked: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"WritableStream\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the WritableStream.\n            function AcquireWritableStreamDefaultWriter(stream) {\n                return new WritableStreamDefaultWriter(stream);\n            }\n            // Throws if and only if startAlgorithm throws.\n            function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n                const stream = Object.create(WritableStream.prototype);\n                InitializeWritableStream(stream);\n                const controller = Object.create(WritableStreamDefaultController.prototype);\n                SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n                return stream;\n            }\n            function InitializeWritableStream(stream) {\n                stream._state = \"writable\";\n                // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n                // 'erroring' or 'errored'. May be set to an undefined value.\n                stream._storedError = undefined;\n                stream._writer = undefined;\n                // Initialize to undefined first because the constructor of the controller checks this\n                // variable to validate the caller.\n                stream._writableStreamController = undefined;\n                // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n                // producer without waiting for the queued writes to finish.\n                stream._writeRequests = new SimpleQueue();\n                // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n                // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n                stream._inFlightWriteRequest = undefined;\n                // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n                // has been detached.\n                stream._closeRequest = undefined;\n                // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n                // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n                stream._inFlightCloseRequest = undefined;\n                // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n                stream._pendingAbortRequest = undefined;\n                // The backpressure signal set by the controller.\n                stream._backpressure = false;\n            }\n            function IsWritableStream(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_writableStreamController\")) {\n                    return false;\n                }\n                return x instanceof WritableStream;\n            }\n            function IsWritableStreamLocked(stream) {\n                if (stream._writer === undefined) {\n                    return false;\n                }\n                return true;\n            }\n            function WritableStreamAbort(stream, reason) {\n                var _a;\n                if (stream._state === \"closed\" || stream._state === \"errored\") {\n                    return promiseResolvedWith(undefined);\n                }\n                stream._writableStreamController._abortReason = reason;\n                (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();\n                // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n                // but it doesn't know that signaling abort runs author code that might have changed the state.\n                // Widen the type again by casting to WritableStreamState.\n                const state = stream._state;\n                if (state === \"closed\" || state === \"errored\") {\n                    return promiseResolvedWith(undefined);\n                }\n                if (stream._pendingAbortRequest !== undefined) {\n                    return stream._pendingAbortRequest._promise;\n                }\n                let wasAlreadyErroring = false;\n                if (state === \"erroring\") {\n                    wasAlreadyErroring = true;\n                    // reason will not be used, so don't keep a reference to it.\n                    reason = undefined;\n                }\n                const promise = newPromise((resolve, reject)=>{\n                    stream._pendingAbortRequest = {\n                        _promise: undefined,\n                        _resolve: resolve,\n                        _reject: reject,\n                        _reason: reason,\n                        _wasAlreadyErroring: wasAlreadyErroring\n                    };\n                });\n                stream._pendingAbortRequest._promise = promise;\n                if (!wasAlreadyErroring) {\n                    WritableStreamStartErroring(stream, reason);\n                }\n                return promise;\n            }\n            function WritableStreamClose(stream) {\n                const state = stream._state;\n                if (state === \"closed\" || state === \"errored\") {\n                    return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n                }\n                const promise = newPromise((resolve, reject)=>{\n                    const closeRequest = {\n                        _resolve: resolve,\n                        _reject: reject\n                    };\n                    stream._closeRequest = closeRequest;\n                });\n                const writer = stream._writer;\n                if (writer !== undefined && stream._backpressure && state === \"writable\") {\n                    defaultWriterReadyPromiseResolve(writer);\n                }\n                WritableStreamDefaultControllerClose(stream._writableStreamController);\n                return promise;\n            }\n            // WritableStream API exposed for controllers.\n            function WritableStreamAddWriteRequest(stream) {\n                const promise = newPromise((resolve, reject)=>{\n                    const writeRequest = {\n                        _resolve: resolve,\n                        _reject: reject\n                    };\n                    stream._writeRequests.push(writeRequest);\n                });\n                return promise;\n            }\n            function WritableStreamDealWithRejection(stream, error) {\n                const state = stream._state;\n                if (state === \"writable\") {\n                    WritableStreamStartErroring(stream, error);\n                    return;\n                }\n                WritableStreamFinishErroring(stream);\n            }\n            function WritableStreamStartErroring(stream, reason) {\n                const controller = stream._writableStreamController;\n                stream._state = \"erroring\";\n                stream._storedError = reason;\n                const writer = stream._writer;\n                if (writer !== undefined) {\n                    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n                }\n                if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n                    WritableStreamFinishErroring(stream);\n                }\n            }\n            function WritableStreamFinishErroring(stream) {\n                stream._state = \"errored\";\n                stream._writableStreamController[ErrorSteps]();\n                const storedError = stream._storedError;\n                stream._writeRequests.forEach((writeRequest)=>{\n                    writeRequest._reject(storedError);\n                });\n                stream._writeRequests = new SimpleQueue();\n                if (stream._pendingAbortRequest === undefined) {\n                    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n                    return;\n                }\n                const abortRequest = stream._pendingAbortRequest;\n                stream._pendingAbortRequest = undefined;\n                if (abortRequest._wasAlreadyErroring) {\n                    abortRequest._reject(storedError);\n                    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n                    return;\n                }\n                const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n                uponPromise(promise, ()=>{\n                    abortRequest._resolve();\n                    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n                }, (reason)=>{\n                    abortRequest._reject(reason);\n                    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n                });\n            }\n            function WritableStreamFinishInFlightWrite(stream) {\n                stream._inFlightWriteRequest._resolve(undefined);\n                stream._inFlightWriteRequest = undefined;\n            }\n            function WritableStreamFinishInFlightWriteWithError(stream, error) {\n                stream._inFlightWriteRequest._reject(error);\n                stream._inFlightWriteRequest = undefined;\n                WritableStreamDealWithRejection(stream, error);\n            }\n            function WritableStreamFinishInFlightClose(stream) {\n                stream._inFlightCloseRequest._resolve(undefined);\n                stream._inFlightCloseRequest = undefined;\n                const state = stream._state;\n                if (state === \"erroring\") {\n                    // The error was too late to do anything, so it is ignored.\n                    stream._storedError = undefined;\n                    if (stream._pendingAbortRequest !== undefined) {\n                        stream._pendingAbortRequest._resolve();\n                        stream._pendingAbortRequest = undefined;\n                    }\n                }\n                stream._state = \"closed\";\n                const writer = stream._writer;\n                if (writer !== undefined) {\n                    defaultWriterClosedPromiseResolve(writer);\n                }\n            }\n            function WritableStreamFinishInFlightCloseWithError(stream, error) {\n                stream._inFlightCloseRequest._reject(error);\n                stream._inFlightCloseRequest = undefined;\n                // Never execute sink abort() after sink close().\n                if (stream._pendingAbortRequest !== undefined) {\n                    stream._pendingAbortRequest._reject(error);\n                    stream._pendingAbortRequest = undefined;\n                }\n                WritableStreamDealWithRejection(stream, error);\n            }\n            // TODO(ricea): Fix alphabetical order.\n            function WritableStreamCloseQueuedOrInFlight(stream) {\n                if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n                    return false;\n                }\n                return true;\n            }\n            function WritableStreamHasOperationMarkedInFlight(stream) {\n                if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n                    return false;\n                }\n                return true;\n            }\n            function WritableStreamMarkCloseRequestInFlight(stream) {\n                stream._inFlightCloseRequest = stream._closeRequest;\n                stream._closeRequest = undefined;\n            }\n            function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n                stream._inFlightWriteRequest = stream._writeRequests.shift();\n            }\n            function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n                if (stream._closeRequest !== undefined) {\n                    stream._closeRequest._reject(stream._storedError);\n                    stream._closeRequest = undefined;\n                }\n                const writer = stream._writer;\n                if (writer !== undefined) {\n                    defaultWriterClosedPromiseReject(writer, stream._storedError);\n                }\n            }\n            function WritableStreamUpdateBackpressure(stream, backpressure) {\n                const writer = stream._writer;\n                if (writer !== undefined && backpressure !== stream._backpressure) {\n                    if (backpressure) {\n                        defaultWriterReadyPromiseReset(writer);\n                    } else {\n                        defaultWriterReadyPromiseResolve(writer);\n                    }\n                }\n                stream._backpressure = backpressure;\n            }\n            /**\n\t\t     * A default writer vended by a {@link WritableStream}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class WritableStreamDefaultWriter {\n                constructor(stream){\n                    assertRequiredArgument(stream, 1, \"WritableStreamDefaultWriter\");\n                    assertWritableStream(stream, \"First parameter\");\n                    if (IsWritableStreamLocked(stream)) {\n                        throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n                    }\n                    this._ownerWritableStream = stream;\n                    stream._writer = this;\n                    const state = stream._state;\n                    if (state === \"writable\") {\n                        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                            defaultWriterReadyPromiseInitialize(this);\n                        } else {\n                            defaultWriterReadyPromiseInitializeAsResolved(this);\n                        }\n                        defaultWriterClosedPromiseInitialize(this);\n                    } else if (state === \"erroring\") {\n                        defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n                        defaultWriterClosedPromiseInitialize(this);\n                    } else if (state === \"closed\") {\n                        defaultWriterReadyPromiseInitializeAsResolved(this);\n                        defaultWriterClosedPromiseInitializeAsResolved(this);\n                    } else {\n                        const storedError = stream._storedError;\n                        defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n                        defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n                    }\n                }\n                /**\n\t\t         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n\t\t         * the writer’s lock is released before the stream finishes closing.\n\t\t         */ get closed() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"closed\"));\n                    }\n                    return this._closedPromise;\n                }\n                /**\n\t\t         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.\n\t\t         * A producer can use this information to determine the right amount of data to write.\n\t\t         *\n\t\t         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n\t\t         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n\t\t         * the writer’s lock is released.\n\t\t         */ get desiredSize() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        throw defaultWriterBrandCheckException(\"desiredSize\");\n                    }\n                    if (this._ownerWritableStream === undefined) {\n                        throw defaultWriterLockException(\"desiredSize\");\n                    }\n                    return WritableStreamDefaultWriterGetDesiredSize(this);\n                }\n                /**\n\t\t         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions\n\t\t         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n\t\t         * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n\t\t         *\n\t\t         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become\n\t\t         * rejected.\n\t\t         */ get ready() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"ready\"));\n                    }\n                    return this._readyPromise;\n                }\n                /**\n\t\t         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n\t\t         */ abort(reason = undefined) {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"abort\"));\n                    }\n                    if (this._ownerWritableStream === undefined) {\n                        return promiseRejectedWith(defaultWriterLockException(\"abort\"));\n                    }\n                    return WritableStreamDefaultWriterAbort(this, reason);\n                }\n                /**\n\t\t         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n\t\t         */ close() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"close\"));\n                    }\n                    const stream = this._ownerWritableStream;\n                    if (stream === undefined) {\n                        return promiseRejectedWith(defaultWriterLockException(\"close\"));\n                    }\n                    if (WritableStreamCloseQueuedOrInFlight(stream)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n                    }\n                    return WritableStreamDefaultWriterClose(this);\n                }\n                /**\n\t\t         * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n\t\t         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n\t\t         * now on; otherwise, the writer will appear closed.\n\t\t         *\n\t\t         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n\t\t         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n\t\t         * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n\t\t         * other producers from writing in an interleaved manner.\n\t\t         */ releaseLock() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        throw defaultWriterBrandCheckException(\"releaseLock\");\n                    }\n                    const stream = this._ownerWritableStream;\n                    if (stream === undefined) {\n                        return;\n                    }\n                    WritableStreamDefaultWriterRelease(this);\n                }\n                write(chunk = undefined) {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"write\"));\n                    }\n                    if (this._ownerWritableStream === undefined) {\n                        return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n                    }\n                    return WritableStreamDefaultWriterWrite(this, chunk);\n                }\n            }\n            Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n                abort: {\n                    enumerable: true\n                },\n                close: {\n                    enumerable: true\n                },\n                releaseLock: {\n                    enumerable: true\n                },\n                write: {\n                    enumerable: true\n                },\n                closed: {\n                    enumerable: true\n                },\n                desiredSize: {\n                    enumerable: true\n                },\n                ready: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"WritableStreamDefaultWriter\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the WritableStreamDefaultWriter.\n            function IsWritableStreamDefaultWriter(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_ownerWritableStream\")) {\n                    return false;\n                }\n                return x instanceof WritableStreamDefaultWriter;\n            }\n            // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n            function WritableStreamDefaultWriterAbort(writer, reason) {\n                const stream = writer._ownerWritableStream;\n                return WritableStreamAbort(stream, reason);\n            }\n            function WritableStreamDefaultWriterClose(writer) {\n                const stream = writer._ownerWritableStream;\n                return WritableStreamClose(stream);\n            }\n            function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n                const stream = writer._ownerWritableStream;\n                const state = stream._state;\n                if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n                    return promiseResolvedWith(undefined);\n                }\n                if (state === \"errored\") {\n                    return promiseRejectedWith(stream._storedError);\n                }\n                return WritableStreamDefaultWriterClose(writer);\n            }\n            function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n                if (writer._closedPromiseState === \"pending\") {\n                    defaultWriterClosedPromiseReject(writer, error);\n                } else {\n                    defaultWriterClosedPromiseResetToRejected(writer, error);\n                }\n            }\n            function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n                if (writer._readyPromiseState === \"pending\") {\n                    defaultWriterReadyPromiseReject(writer, error);\n                } else {\n                    defaultWriterReadyPromiseResetToRejected(writer, error);\n                }\n            }\n            function WritableStreamDefaultWriterGetDesiredSize(writer) {\n                const stream = writer._ownerWritableStream;\n                const state = stream._state;\n                if (state === \"errored\" || state === \"erroring\") {\n                    return null;\n                }\n                if (state === \"closed\") {\n                    return 0;\n                }\n                return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n            }\n            function WritableStreamDefaultWriterRelease(writer) {\n                const stream = writer._ownerWritableStream;\n                const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n                WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n                // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n                // rejected until afterwards. This means that simply testing state will not work.\n                WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n                stream._writer = undefined;\n                writer._ownerWritableStream = undefined;\n            }\n            function WritableStreamDefaultWriterWrite(writer, chunk) {\n                const stream = writer._ownerWritableStream;\n                const controller = stream._writableStreamController;\n                const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n                if (stream !== writer._ownerWritableStream) {\n                    return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n                }\n                const state = stream._state;\n                if (state === \"errored\") {\n                    return promiseRejectedWith(stream._storedError);\n                }\n                if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n                    return promiseRejectedWith(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n                }\n                if (state === \"erroring\") {\n                    return promiseRejectedWith(stream._storedError);\n                }\n                const promise = WritableStreamAddWriteRequest(stream);\n                WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n                return promise;\n            }\n            const closeSentinel = {};\n            /**\n\t\t     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n\t\t     *\n\t\t     * @public\n\t\t     */ class WritableStreamDefaultController {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n\t\t         *\n\t\t         * @deprecated\n\t\t         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n\t\t         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n\t\t         */ get abortReason() {\n                    if (!IsWritableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$2(\"abortReason\");\n                    }\n                    return this._abortReason;\n                }\n                /**\n\t\t         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n\t\t         */ get signal() {\n                    if (!IsWritableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$2(\"signal\");\n                    }\n                    if (this._abortController === undefined) {\n                        // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n                        // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n                        // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n                        throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n                    }\n                    return this._abortController.signal;\n                }\n                /**\n\t\t         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n\t\t         *\n\t\t         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n\t\t         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n\t\t         * normal lifecycle of interactions with the underlying sink.\n\t\t         */ error(e = undefined) {\n                    if (!IsWritableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$2(\"error\");\n                    }\n                    const state = this._controlledWritableStream._state;\n                    if (state !== \"writable\") {\n                        // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n                        // just treat it as a no-op.\n                        return;\n                    }\n                    WritableStreamDefaultControllerError(this, e);\n                }\n                /** @internal */ [AbortSteps](reason) {\n                    const result = this._abortAlgorithm(reason);\n                    WritableStreamDefaultControllerClearAlgorithms(this);\n                    return result;\n                }\n                /** @internal */ [ErrorSteps]() {\n                    ResetQueue(this);\n                }\n            }\n            Object.defineProperties(WritableStreamDefaultController.prototype, {\n                abortReason: {\n                    enumerable: true\n                },\n                signal: {\n                    enumerable: true\n                },\n                error: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"WritableStreamDefaultController\",\n                    configurable: true\n                });\n            }\n            // Abstract operations implementing interface required by the WritableStream.\n            function IsWritableStreamDefaultController(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_controlledWritableStream\")) {\n                    return false;\n                }\n                return x instanceof WritableStreamDefaultController;\n            }\n            function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n                controller._controlledWritableStream = stream;\n                stream._writableStreamController = controller;\n                // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n                controller._queue = undefined;\n                controller._queueTotalSize = undefined;\n                ResetQueue(controller);\n                controller._abortReason = undefined;\n                controller._abortController = createAbortController();\n                controller._started = false;\n                controller._strategySizeAlgorithm = sizeAlgorithm;\n                controller._strategyHWM = highWaterMark;\n                controller._writeAlgorithm = writeAlgorithm;\n                controller._closeAlgorithm = closeAlgorithm;\n                controller._abortAlgorithm = abortAlgorithm;\n                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                WritableStreamUpdateBackpressure(stream, backpressure);\n                const startResult = startAlgorithm();\n                const startPromise = promiseResolvedWith(startResult);\n                uponPromise(startPromise, ()=>{\n                    controller._started = true;\n                    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n                }, (r)=>{\n                    controller._started = true;\n                    WritableStreamDealWithRejection(stream, r);\n                });\n            }\n            function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n                const controller = Object.create(WritableStreamDefaultController.prototype);\n                let startAlgorithm = ()=>undefined;\n                let writeAlgorithm = ()=>promiseResolvedWith(undefined);\n                let closeAlgorithm = ()=>promiseResolvedWith(undefined);\n                let abortAlgorithm = ()=>promiseResolvedWith(undefined);\n                if (underlyingSink.start !== undefined) {\n                    startAlgorithm = ()=>underlyingSink.start(controller);\n                }\n                if (underlyingSink.write !== undefined) {\n                    writeAlgorithm = (chunk)=>underlyingSink.write(chunk, controller);\n                }\n                if (underlyingSink.close !== undefined) {\n                    closeAlgorithm = ()=>underlyingSink.close();\n                }\n                if (underlyingSink.abort !== undefined) {\n                    abortAlgorithm = (reason)=>underlyingSink.abort(reason);\n                }\n                SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n            }\n            // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n            function WritableStreamDefaultControllerClearAlgorithms(controller) {\n                controller._writeAlgorithm = undefined;\n                controller._closeAlgorithm = undefined;\n                controller._abortAlgorithm = undefined;\n                controller._strategySizeAlgorithm = undefined;\n            }\n            function WritableStreamDefaultControllerClose(controller) {\n                EnqueueValueWithSize(controller, closeSentinel, 0);\n                WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n            }\n            function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n                try {\n                    return controller._strategySizeAlgorithm(chunk);\n                } catch (chunkSizeE) {\n                    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n                    return 1;\n                }\n            }\n            function WritableStreamDefaultControllerGetDesiredSize(controller) {\n                return controller._strategyHWM - controller._queueTotalSize;\n            }\n            function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n                try {\n                    EnqueueValueWithSize(controller, chunk, chunkSize);\n                } catch (enqueueE) {\n                    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n                    return;\n                }\n                const stream = controller._controlledWritableStream;\n                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === \"writable\") {\n                    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                    WritableStreamUpdateBackpressure(stream, backpressure);\n                }\n                WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n            }\n            // Abstract operations for the WritableStreamDefaultController.\n            function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n                const stream = controller._controlledWritableStream;\n                if (!controller._started) {\n                    return;\n                }\n                if (stream._inFlightWriteRequest !== undefined) {\n                    return;\n                }\n                const state = stream._state;\n                if (state === \"erroring\") {\n                    WritableStreamFinishErroring(stream);\n                    return;\n                }\n                if (controller._queue.length === 0) {\n                    return;\n                }\n                const value1 = PeekQueueValue(controller);\n                if (value1 === closeSentinel) {\n                    WritableStreamDefaultControllerProcessClose(controller);\n                } else {\n                    WritableStreamDefaultControllerProcessWrite(controller, value1);\n                }\n            }\n            function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n                if (controller._controlledWritableStream._state === \"writable\") {\n                    WritableStreamDefaultControllerError(controller, error);\n                }\n            }\n            function WritableStreamDefaultControllerProcessClose(controller) {\n                const stream = controller._controlledWritableStream;\n                WritableStreamMarkCloseRequestInFlight(stream);\n                DequeueValue(controller);\n                const sinkClosePromise = controller._closeAlgorithm();\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n                uponPromise(sinkClosePromise, ()=>{\n                    WritableStreamFinishInFlightClose(stream);\n                }, (reason)=>{\n                    WritableStreamFinishInFlightCloseWithError(stream, reason);\n                });\n            }\n            function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n                const stream = controller._controlledWritableStream;\n                WritableStreamMarkFirstWriteRequestInFlight(stream);\n                const sinkWritePromise = controller._writeAlgorithm(chunk);\n                uponPromise(sinkWritePromise, ()=>{\n                    WritableStreamFinishInFlightWrite(stream);\n                    const state = stream._state;\n                    DequeueValue(controller);\n                    if (!WritableStreamCloseQueuedOrInFlight(stream) && state === \"writable\") {\n                        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                        WritableStreamUpdateBackpressure(stream, backpressure);\n                    }\n                    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n                }, (reason)=>{\n                    if (stream._state === \"writable\") {\n                        WritableStreamDefaultControllerClearAlgorithms(controller);\n                    }\n                    WritableStreamFinishInFlightWriteWithError(stream, reason);\n                });\n            }\n            function WritableStreamDefaultControllerGetBackpressure(controller) {\n                const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n                return desiredSize <= 0;\n            }\n            // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n            function WritableStreamDefaultControllerError(controller, error) {\n                const stream = controller._controlledWritableStream;\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n                WritableStreamStartErroring(stream, error);\n            }\n            // Helper functions for the WritableStream.\n            function streamBrandCheckException$2(name) {\n                return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n            }\n            // Helper functions for the WritableStreamDefaultController.\n            function defaultControllerBrandCheckException$2(name) {\n                return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n            }\n            // Helper functions for the WritableStreamDefaultWriter.\n            function defaultWriterBrandCheckException(name) {\n                return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n            }\n            function defaultWriterLockException(name) {\n                return new TypeError(\"Cannot \" + name + \" a stream using a released writer\");\n            }\n            function defaultWriterClosedPromiseInitialize(writer) {\n                writer._closedPromise = newPromise((resolve, reject)=>{\n                    writer._closedPromise_resolve = resolve;\n                    writer._closedPromise_reject = reject;\n                    writer._closedPromiseState = \"pending\";\n                });\n            }\n            function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n                defaultWriterClosedPromiseInitialize(writer);\n                defaultWriterClosedPromiseReject(writer, reason);\n            }\n            function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n                defaultWriterClosedPromiseInitialize(writer);\n                defaultWriterClosedPromiseResolve(writer);\n            }\n            function defaultWriterClosedPromiseReject(writer, reason) {\n                if (writer._closedPromise_reject === undefined) {\n                    return;\n                }\n                setPromiseIsHandledToTrue(writer._closedPromise);\n                writer._closedPromise_reject(reason);\n                writer._closedPromise_resolve = undefined;\n                writer._closedPromise_reject = undefined;\n                writer._closedPromiseState = \"rejected\";\n            }\n            function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n                defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n            }\n            function defaultWriterClosedPromiseResolve(writer) {\n                if (writer._closedPromise_resolve === undefined) {\n                    return;\n                }\n                writer._closedPromise_resolve(undefined);\n                writer._closedPromise_resolve = undefined;\n                writer._closedPromise_reject = undefined;\n                writer._closedPromiseState = \"resolved\";\n            }\n            function defaultWriterReadyPromiseInitialize(writer) {\n                writer._readyPromise = newPromise((resolve, reject)=>{\n                    writer._readyPromise_resolve = resolve;\n                    writer._readyPromise_reject = reject;\n                });\n                writer._readyPromiseState = \"pending\";\n            }\n            function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n                defaultWriterReadyPromiseInitialize(writer);\n                defaultWriterReadyPromiseReject(writer, reason);\n            }\n            function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n                defaultWriterReadyPromiseInitialize(writer);\n                defaultWriterReadyPromiseResolve(writer);\n            }\n            function defaultWriterReadyPromiseReject(writer, reason) {\n                if (writer._readyPromise_reject === undefined) {\n                    return;\n                }\n                setPromiseIsHandledToTrue(writer._readyPromise);\n                writer._readyPromise_reject(reason);\n                writer._readyPromise_resolve = undefined;\n                writer._readyPromise_reject = undefined;\n                writer._readyPromiseState = \"rejected\";\n            }\n            function defaultWriterReadyPromiseReset(writer) {\n                defaultWriterReadyPromiseInitialize(writer);\n            }\n            function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n                defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n            }\n            function defaultWriterReadyPromiseResolve(writer) {\n                if (writer._readyPromise_resolve === undefined) {\n                    return;\n                }\n                writer._readyPromise_resolve(undefined);\n                writer._readyPromise_resolve = undefined;\n                writer._readyPromise_reject = undefined;\n                writer._readyPromiseState = \"fulfilled\";\n            }\n            /// <reference lib=\"dom\" />\n            const NativeDOMException = typeof DOMException !== \"undefined\" ? DOMException : undefined;\n            /// <reference types=\"node\" />\n            function isDOMExceptionConstructor(ctor) {\n                if (!(typeof ctor === \"function\" || typeof ctor === \"object\")) {\n                    return false;\n                }\n                try {\n                    new ctor();\n                    return true;\n                } catch (_a) {\n                    return false;\n                }\n            }\n            function createDOMExceptionPolyfill() {\n                // eslint-disable-next-line no-shadow\n                const ctor = function DOMException1(message, name) {\n                    this.message = message || \"\";\n                    this.name = name || \"Error\";\n                    if (Error.captureStackTrace) {\n                        Error.captureStackTrace(this, this.constructor);\n                    }\n                };\n                ctor.prototype = Object.create(Error.prototype);\n                Object.defineProperty(ctor.prototype, \"constructor\", {\n                    value: ctor,\n                    writable: true,\n                    configurable: true\n                });\n                return ctor;\n            }\n            // eslint-disable-next-line no-redeclare\n            const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n            function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n                const reader = AcquireReadableStreamDefaultReader(source);\n                const writer = AcquireWritableStreamDefaultWriter(dest);\n                source._disturbed = true;\n                let shuttingDown = false;\n                // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n                let currentWrite = promiseResolvedWith(undefined);\n                return newPromise((resolve, reject)=>{\n                    let abortAlgorithm;\n                    if (signal !== undefined) {\n                        abortAlgorithm = ()=>{\n                            const error = new DOMException$1(\"Aborted\", \"AbortError\");\n                            const actions = [];\n                            if (!preventAbort) {\n                                actions.push(()=>{\n                                    if (dest._state === \"writable\") {\n                                        return WritableStreamAbort(dest, error);\n                                    }\n                                    return promiseResolvedWith(undefined);\n                                });\n                            }\n                            if (!preventCancel) {\n                                actions.push(()=>{\n                                    if (source._state === \"readable\") {\n                                        return ReadableStreamCancel(source, error);\n                                    }\n                                    return promiseResolvedWith(undefined);\n                                });\n                            }\n                            shutdownWithAction(()=>Promise.all(actions.map((action)=>action())), true, error);\n                        };\n                        if (signal.aborted) {\n                            abortAlgorithm();\n                            return;\n                        }\n                        signal.addEventListener(\"abort\", abortAlgorithm);\n                    }\n                    // Using reader and writer, read all chunks from this and write them to dest\n                    // - Backpressure must be enforced\n                    // - Shutdown must stop all activity\n                    function pipeLoop() {\n                        return newPromise((resolveLoop, rejectLoop)=>{\n                            function next(done) {\n                                if (done) {\n                                    resolveLoop();\n                                } else {\n                                    // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                                    // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                                    PerformPromiseThen(pipeStep(), next, rejectLoop);\n                                }\n                            }\n                            next(false);\n                        });\n                    }\n                    function pipeStep() {\n                        if (shuttingDown) {\n                            return promiseResolvedWith(true);\n                        }\n                        return PerformPromiseThen(writer._readyPromise, ()=>{\n                            return newPromise((resolveRead, rejectRead)=>{\n                                ReadableStreamDefaultReaderRead(reader, {\n                                    _chunkSteps: (chunk)=>{\n                                        currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                                        resolveRead(false);\n                                    },\n                                    _closeSteps: ()=>resolveRead(true),\n                                    _errorSteps: rejectRead\n                                });\n                            });\n                        });\n                    }\n                    // Errors must be propagated forward\n                    isOrBecomesErrored(source, reader._closedPromise, (storedError)=>{\n                        if (!preventAbort) {\n                            shutdownWithAction(()=>WritableStreamAbort(dest, storedError), true, storedError);\n                        } else {\n                            shutdown(true, storedError);\n                        }\n                    });\n                    // Errors must be propagated backward\n                    isOrBecomesErrored(dest, writer._closedPromise, (storedError)=>{\n                        if (!preventCancel) {\n                            shutdownWithAction(()=>ReadableStreamCancel(source, storedError), true, storedError);\n                        } else {\n                            shutdown(true, storedError);\n                        }\n                    });\n                    // Closing must be propagated forward\n                    isOrBecomesClosed(source, reader._closedPromise, ()=>{\n                        if (!preventClose) {\n                            shutdownWithAction(()=>WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n                        } else {\n                            shutdown();\n                        }\n                    });\n                    // Closing must be propagated backward\n                    if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === \"closed\") {\n                        const destClosed = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n                        if (!preventCancel) {\n                            shutdownWithAction(()=>ReadableStreamCancel(source, destClosed), true, destClosed);\n                        } else {\n                            shutdown(true, destClosed);\n                        }\n                    }\n                    setPromiseIsHandledToTrue(pipeLoop());\n                    function waitForWritesToFinish() {\n                        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n                        // for that too.\n                        const oldCurrentWrite = currentWrite;\n                        return PerformPromiseThen(currentWrite, ()=>oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n                    }\n                    function isOrBecomesErrored(stream, promise, action) {\n                        if (stream._state === \"errored\") {\n                            action(stream._storedError);\n                        } else {\n                            uponRejection(promise, action);\n                        }\n                    }\n                    function isOrBecomesClosed(stream, promise, action) {\n                        if (stream._state === \"closed\") {\n                            action();\n                        } else {\n                            uponFulfillment(promise, action);\n                        }\n                    }\n                    function shutdownWithAction(action, originalIsError, originalError) {\n                        if (shuttingDown) {\n                            return;\n                        }\n                        shuttingDown = true;\n                        if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                            uponFulfillment(waitForWritesToFinish(), doTheRest);\n                        } else {\n                            doTheRest();\n                        }\n                        function doTheRest() {\n                            uponPromise(action(), ()=>finalize(originalIsError, originalError), (newError)=>finalize(true, newError));\n                        }\n                    }\n                    function shutdown(isError, error) {\n                        if (shuttingDown) {\n                            return;\n                        }\n                        shuttingDown = true;\n                        if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                            uponFulfillment(waitForWritesToFinish(), ()=>finalize(isError, error));\n                        } else {\n                            finalize(isError, error);\n                        }\n                    }\n                    function finalize(isError, error) {\n                        WritableStreamDefaultWriterRelease(writer);\n                        ReadableStreamReaderGenericRelease(reader);\n                        if (signal !== undefined) {\n                            signal.removeEventListener(\"abort\", abortAlgorithm);\n                        }\n                        if (isError) {\n                            reject(error);\n                        } else {\n                            resolve(undefined);\n                        }\n                    }\n                });\n            }\n            /**\n\t\t     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStreamDefaultController {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n\t\t         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n\t\t         */ get desiredSize() {\n                    if (!IsReadableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$1(\"desiredSize\");\n                    }\n                    return ReadableStreamDefaultControllerGetDesiredSize(this);\n                }\n                /**\n\t\t         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n\t\t         * the stream, but once those are read, the stream will become closed.\n\t\t         */ close() {\n                    if (!IsReadableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$1(\"close\");\n                    }\n                    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                        throw new TypeError(\"The stream is not in a state that permits close\");\n                    }\n                    ReadableStreamDefaultControllerClose(this);\n                }\n                enqueue(chunk = undefined) {\n                    if (!IsReadableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$1(\"enqueue\");\n                    }\n                    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                        throw new TypeError(\"The stream is not in a state that permits enqueue\");\n                    }\n                    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n                }\n                /**\n\t\t         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n\t\t         */ error(e = undefined) {\n                    if (!IsReadableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$1(\"error\");\n                    }\n                    ReadableStreamDefaultControllerError(this, e);\n                }\n                /** @internal */ [CancelSteps](reason) {\n                    ResetQueue(this);\n                    const result = this._cancelAlgorithm(reason);\n                    ReadableStreamDefaultControllerClearAlgorithms(this);\n                    return result;\n                }\n                /** @internal */ [PullSteps](readRequest) {\n                    const stream = this._controlledReadableStream;\n                    if (this._queue.length > 0) {\n                        const chunk = DequeueValue(this);\n                        if (this._closeRequested && this._queue.length === 0) {\n                            ReadableStreamDefaultControllerClearAlgorithms(this);\n                            ReadableStreamClose(stream);\n                        } else {\n                            ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                        }\n                        readRequest._chunkSteps(chunk);\n                    } else {\n                        ReadableStreamAddReadRequest(stream, readRequest);\n                        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                    }\n                }\n            }\n            Object.defineProperties(ReadableStreamDefaultController.prototype, {\n                close: {\n                    enumerable: true\n                },\n                enqueue: {\n                    enumerable: true\n                },\n                error: {\n                    enumerable: true\n                },\n                desiredSize: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStreamDefaultController\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the ReadableStreamDefaultController.\n            function IsReadableStreamDefaultController(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableStream\")) {\n                    return false;\n                }\n                return x instanceof ReadableStreamDefaultController;\n            }\n            function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n                const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n                if (!shouldPull) {\n                    return;\n                }\n                if (controller._pulling) {\n                    controller._pullAgain = true;\n                    return;\n                }\n                controller._pulling = true;\n                const pullPromise = controller._pullAlgorithm();\n                uponPromise(pullPromise, ()=>{\n                    controller._pulling = false;\n                    if (controller._pullAgain) {\n                        controller._pullAgain = false;\n                        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n                    }\n                }, (e)=>{\n                    ReadableStreamDefaultControllerError(controller, e);\n                });\n            }\n            function ReadableStreamDefaultControllerShouldCallPull(controller) {\n                const stream = controller._controlledReadableStream;\n                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n                    return false;\n                }\n                if (!controller._started) {\n                    return false;\n                }\n                if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n                    return true;\n                }\n                const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n                if (desiredSize > 0) {\n                    return true;\n                }\n                return false;\n            }\n            function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n                controller._pullAlgorithm = undefined;\n                controller._cancelAlgorithm = undefined;\n                controller._strategySizeAlgorithm = undefined;\n            }\n            // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n            function ReadableStreamDefaultControllerClose(controller) {\n                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n                    return;\n                }\n                const stream = controller._controlledReadableStream;\n                controller._closeRequested = true;\n                if (controller._queue.length === 0) {\n                    ReadableStreamDefaultControllerClearAlgorithms(controller);\n                    ReadableStreamClose(stream);\n                }\n            }\n            function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n                    return;\n                }\n                const stream = controller._controlledReadableStream;\n                if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n                    ReadableStreamFulfillReadRequest(stream, chunk, false);\n                } else {\n                    let chunkSize;\n                    try {\n                        chunkSize = controller._strategySizeAlgorithm(chunk);\n                    } catch (chunkSizeE) {\n                        ReadableStreamDefaultControllerError(controller, chunkSizeE);\n                        throw chunkSizeE;\n                    }\n                    try {\n                        EnqueueValueWithSize(controller, chunk, chunkSize);\n                    } catch (enqueueE) {\n                        ReadableStreamDefaultControllerError(controller, enqueueE);\n                        throw enqueueE;\n                    }\n                }\n                ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n            }\n            function ReadableStreamDefaultControllerError(controller, e) {\n                const stream = controller._controlledReadableStream;\n                if (stream._state !== \"readable\") {\n                    return;\n                }\n                ResetQueue(controller);\n                ReadableStreamDefaultControllerClearAlgorithms(controller);\n                ReadableStreamError(stream, e);\n            }\n            function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n                const state = controller._controlledReadableStream._state;\n                if (state === \"errored\") {\n                    return null;\n                }\n                if (state === \"closed\") {\n                    return 0;\n                }\n                return controller._strategyHWM - controller._queueTotalSize;\n            }\n            // This is used in the implementation of TransformStream.\n            function ReadableStreamDefaultControllerHasBackpressure(controller) {\n                if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n                    return false;\n                }\n                return true;\n            }\n            function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n                const state = controller._controlledReadableStream._state;\n                if (!controller._closeRequested && state === \"readable\") {\n                    return true;\n                }\n                return false;\n            }\n            function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n                controller._controlledReadableStream = stream;\n                controller._queue = undefined;\n                controller._queueTotalSize = undefined;\n                ResetQueue(controller);\n                controller._started = false;\n                controller._closeRequested = false;\n                controller._pullAgain = false;\n                controller._pulling = false;\n                controller._strategySizeAlgorithm = sizeAlgorithm;\n                controller._strategyHWM = highWaterMark;\n                controller._pullAlgorithm = pullAlgorithm;\n                controller._cancelAlgorithm = cancelAlgorithm;\n                stream._readableStreamController = controller;\n                const startResult = startAlgorithm();\n                uponPromise(promiseResolvedWith(startResult), ()=>{\n                    controller._started = true;\n                    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n                }, (r)=>{\n                    ReadableStreamDefaultControllerError(controller, r);\n                });\n            }\n            function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n                const controller = Object.create(ReadableStreamDefaultController.prototype);\n                let startAlgorithm = ()=>undefined;\n                let pullAlgorithm = ()=>promiseResolvedWith(undefined);\n                let cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n                if (underlyingSource.start !== undefined) {\n                    startAlgorithm = ()=>underlyingSource.start(controller);\n                }\n                if (underlyingSource.pull !== undefined) {\n                    pullAlgorithm = ()=>underlyingSource.pull(controller);\n                }\n                if (underlyingSource.cancel !== undefined) {\n                    cancelAlgorithm = (reason)=>underlyingSource.cancel(reason);\n                }\n                SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n            }\n            // Helper functions for the ReadableStreamDefaultController.\n            function defaultControllerBrandCheckException$1(name) {\n                return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n            }\n            function ReadableStreamTee(stream, cloneForBranch2) {\n                if (IsReadableByteStreamController(stream._readableStreamController)) {\n                    return ReadableByteStreamTee(stream);\n                }\n                return ReadableStreamDefaultTee(stream);\n            }\n            function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n                const reader = AcquireReadableStreamDefaultReader(stream);\n                let reading = false;\n                let readAgain = false;\n                let canceled1 = false;\n                let canceled2 = false;\n                let reason1;\n                let reason2;\n                let branch1;\n                let branch2;\n                let resolveCancelPromise;\n                const cancelPromise = newPromise((resolve)=>{\n                    resolveCancelPromise = resolve;\n                });\n                function pullAlgorithm() {\n                    if (reading) {\n                        readAgain = true;\n                        return promiseResolvedWith(undefined);\n                    }\n                    reading = true;\n                    const readRequest = {\n                        _chunkSteps: (chunk)=>{\n                            // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                            // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                            // successful synchronously-available reads get ahead of asynchronously-available errors.\n                            queueMicrotask(()=>{\n                                readAgain = false;\n                                const chunk1 = chunk;\n                                const chunk2 = chunk;\n                                // There is no way to access the cloning code right now in the reference implementation.\n                                // If we add one then we'll need an implementation for serializable objects.\n                                // if (!canceled2 && cloneForBranch2) {\n                                //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n                                // }\n                                if (!canceled1) {\n                                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                                }\n                                if (!canceled2) {\n                                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                                }\n                                reading = false;\n                                if (readAgain) {\n                                    pullAlgorithm();\n                                }\n                            });\n                        },\n                        _closeSteps: ()=>{\n                            reading = false;\n                            if (!canceled1) {\n                                ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                            }\n                            if (!canceled2) {\n                                ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                            }\n                            if (!canceled1 || !canceled2) {\n                                resolveCancelPromise(undefined);\n                            }\n                        },\n                        _errorSteps: ()=>{\n                            reading = false;\n                        }\n                    };\n                    ReadableStreamDefaultReaderRead(reader, readRequest);\n                    return promiseResolvedWith(undefined);\n                }\n                function cancel1Algorithm(reason) {\n                    canceled1 = true;\n                    reason1 = reason;\n                    if (canceled2) {\n                        const compositeReason = CreateArrayFromList([\n                            reason1,\n                            reason2\n                        ]);\n                        const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                        resolveCancelPromise(cancelResult);\n                    }\n                    return cancelPromise;\n                }\n                function cancel2Algorithm(reason) {\n                    canceled2 = true;\n                    reason2 = reason;\n                    if (canceled1) {\n                        const compositeReason = CreateArrayFromList([\n                            reason1,\n                            reason2\n                        ]);\n                        const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                        resolveCancelPromise(cancelResult);\n                    }\n                    return cancelPromise;\n                }\n                function startAlgorithm() {\n                // do nothing\n                }\n                branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n                branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n                uponRejection(reader._closedPromise, (r)=>{\n                    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n                    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                });\n                return [\n                    branch1,\n                    branch2\n                ];\n            }\n            function ReadableByteStreamTee(stream) {\n                let reader = AcquireReadableStreamDefaultReader(stream);\n                let reading = false;\n                let readAgainForBranch1 = false;\n                let readAgainForBranch2 = false;\n                let canceled1 = false;\n                let canceled2 = false;\n                let reason1;\n                let reason2;\n                let branch1;\n                let branch2;\n                let resolveCancelPromise;\n                const cancelPromise = newPromise((resolve)=>{\n                    resolveCancelPromise = resolve;\n                });\n                function forwardReaderError(thisReader) {\n                    uponRejection(thisReader._closedPromise, (r)=>{\n                        if (thisReader !== reader) {\n                            return;\n                        }\n                        ReadableByteStreamControllerError(branch1._readableStreamController, r);\n                        ReadableByteStreamControllerError(branch2._readableStreamController, r);\n                        if (!canceled1 || !canceled2) {\n                            resolveCancelPromise(undefined);\n                        }\n                    });\n                }\n                function pullWithDefaultReader() {\n                    if (IsReadableStreamBYOBReader(reader)) {\n                        ReadableStreamReaderGenericRelease(reader);\n                        reader = AcquireReadableStreamDefaultReader(stream);\n                        forwardReaderError(reader);\n                    }\n                    const readRequest = {\n                        _chunkSteps: (chunk)=>{\n                            // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                            // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                            // successful synchronously-available reads get ahead of asynchronously-available errors.\n                            queueMicrotask(()=>{\n                                readAgainForBranch1 = false;\n                                readAgainForBranch2 = false;\n                                const chunk1 = chunk;\n                                let chunk2 = chunk;\n                                if (!canceled1 && !canceled2) {\n                                    try {\n                                        chunk2 = CloneAsUint8Array(chunk);\n                                    } catch (cloneE) {\n                                        ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                                        ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                                        resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                        return;\n                                    }\n                                }\n                                if (!canceled1) {\n                                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                                }\n                                if (!canceled2) {\n                                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                                }\n                                reading = false;\n                                if (readAgainForBranch1) {\n                                    pull1Algorithm();\n                                } else if (readAgainForBranch2) {\n                                    pull2Algorithm();\n                                }\n                            });\n                        },\n                        _closeSteps: ()=>{\n                            reading = false;\n                            if (!canceled1) {\n                                ReadableByteStreamControllerClose(branch1._readableStreamController);\n                            }\n                            if (!canceled2) {\n                                ReadableByteStreamControllerClose(branch2._readableStreamController);\n                            }\n                            if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n                            }\n                            if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n                            }\n                            if (!canceled1 || !canceled2) {\n                                resolveCancelPromise(undefined);\n                            }\n                        },\n                        _errorSteps: ()=>{\n                            reading = false;\n                        }\n                    };\n                    ReadableStreamDefaultReaderRead(reader, readRequest);\n                }\n                function pullWithBYOBReader(view, forBranch2) {\n                    if (IsReadableStreamDefaultReader(reader)) {\n                        ReadableStreamReaderGenericRelease(reader);\n                        reader = AcquireReadableStreamBYOBReader(stream);\n                        forwardReaderError(reader);\n                    }\n                    const byobBranch = forBranch2 ? branch2 : branch1;\n                    const otherBranch = forBranch2 ? branch1 : branch2;\n                    const readIntoRequest = {\n                        _chunkSteps: (chunk)=>{\n                            // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                            // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                            // successful synchronously-available reads get ahead of asynchronously-available errors.\n                            queueMicrotask(()=>{\n                                readAgainForBranch1 = false;\n                                readAgainForBranch2 = false;\n                                const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                                const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                                if (!otherCanceled) {\n                                    let clonedChunk;\n                                    try {\n                                        clonedChunk = CloneAsUint8Array(chunk);\n                                    } catch (cloneE) {\n                                        ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                                        ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                                        resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                        return;\n                                    }\n                                    if (!byobCanceled) {\n                                        ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                                    }\n                                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                                } else if (!byobCanceled) {\n                                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                                }\n                                reading = false;\n                                if (readAgainForBranch1) {\n                                    pull1Algorithm();\n                                } else if (readAgainForBranch2) {\n                                    pull2Algorithm();\n                                }\n                            });\n                        },\n                        _closeSteps: (chunk)=>{\n                            reading = false;\n                            const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                            const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                            if (!byobCanceled) {\n                                ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n                            }\n                            if (!otherCanceled) {\n                                ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n                            }\n                            if (chunk !== undefined) {\n                                if (!byobCanceled) {\n                                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                                }\n                                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                                }\n                            }\n                            if (!byobCanceled || !otherCanceled) {\n                                resolveCancelPromise(undefined);\n                            }\n                        },\n                        _errorSteps: ()=>{\n                            reading = false;\n                        }\n                    };\n                    ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n                }\n                function pull1Algorithm() {\n                    if (reading) {\n                        readAgainForBranch1 = true;\n                        return promiseResolvedWith(undefined);\n                    }\n                    reading = true;\n                    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n                    if (byobRequest === null) {\n                        pullWithDefaultReader();\n                    } else {\n                        pullWithBYOBReader(byobRequest._view, false);\n                    }\n                    return promiseResolvedWith(undefined);\n                }\n                function pull2Algorithm() {\n                    if (reading) {\n                        readAgainForBranch2 = true;\n                        return promiseResolvedWith(undefined);\n                    }\n                    reading = true;\n                    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n                    if (byobRequest === null) {\n                        pullWithDefaultReader();\n                    } else {\n                        pullWithBYOBReader(byobRequest._view, true);\n                    }\n                    return promiseResolvedWith(undefined);\n                }\n                function cancel1Algorithm(reason) {\n                    canceled1 = true;\n                    reason1 = reason;\n                    if (canceled2) {\n                        const compositeReason = CreateArrayFromList([\n                            reason1,\n                            reason2\n                        ]);\n                        const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                        resolveCancelPromise(cancelResult);\n                    }\n                    return cancelPromise;\n                }\n                function cancel2Algorithm(reason) {\n                    canceled2 = true;\n                    reason2 = reason;\n                    if (canceled1) {\n                        const compositeReason = CreateArrayFromList([\n                            reason1,\n                            reason2\n                        ]);\n                        const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                        resolveCancelPromise(cancelResult);\n                    }\n                    return cancelPromise;\n                }\n                function startAlgorithm() {\n                    return;\n                }\n                branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n                branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n                forwardReaderError(reader);\n                return [\n                    branch1,\n                    branch2\n                ];\n            }\n            function convertUnderlyingDefaultOrByteSource(source, context) {\n                assertDictionary(source, context);\n                const original = source;\n                const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n                const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n                const pull = original === null || original === void 0 ? void 0 : original.pull;\n                const start = original === null || original === void 0 ? void 0 : original.start;\n                const type = original === null || original === void 0 ? void 0 : original.type;\n                return {\n                    autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n                    cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n                    pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n                    start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n                    type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n                };\n            }\n            function convertUnderlyingSourceCancelCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (reason)=>promiseCall(fn, original, [\n                        reason\n                    ]);\n            }\n            function convertUnderlyingSourcePullCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>promiseCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertUnderlyingSourceStartCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>reflectCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertReadableStreamType(type, context) {\n                type = `${type}`;\n                if (type !== \"bytes\") {\n                    throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n                }\n                return type;\n            }\n            function convertReaderOptions(options, context) {\n                assertDictionary(options, context);\n                const mode = options === null || options === void 0 ? void 0 : options.mode;\n                return {\n                    mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n                };\n            }\n            function convertReadableStreamReaderMode(mode, context) {\n                mode = `${mode}`;\n                if (mode !== \"byob\") {\n                    throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n                }\n                return mode;\n            }\n            function convertIteratorOptions(options, context) {\n                assertDictionary(options, context);\n                const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n                return {\n                    preventCancel: Boolean(preventCancel)\n                };\n            }\n            function convertPipeOptions(options, context) {\n                assertDictionary(options, context);\n                const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n                const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n                const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n                const signal = options === null || options === void 0 ? void 0 : options.signal;\n                if (signal !== undefined) {\n                    assertAbortSignal(signal, `${context} has member 'signal' that`);\n                }\n                return {\n                    preventAbort: Boolean(preventAbort),\n                    preventCancel: Boolean(preventCancel),\n                    preventClose: Boolean(preventClose),\n                    signal\n                };\n            }\n            function assertAbortSignal(signal, context) {\n                if (!isAbortSignal(signal)) {\n                    throw new TypeError(`${context} is not an AbortSignal.`);\n                }\n            }\n            function convertReadableWritablePair(pair, context) {\n                assertDictionary(pair, context);\n                const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n                assertRequiredField(readable, \"readable\", \"ReadableWritablePair\");\n                assertReadableStream(readable, `${context} has member 'readable' that`);\n                const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n                assertRequiredField(writable, \"writable\", \"ReadableWritablePair\");\n                assertWritableStream(writable, `${context} has member 'writable' that`);\n                return {\n                    readable,\n                    writable\n                };\n            }\n            /**\n\t\t     * A readable stream represents a source of data, from which you can read.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStream1 {\n                constructor(rawUnderlyingSource = {}, rawStrategy = {}){\n                    if (rawUnderlyingSource === undefined) {\n                        rawUnderlyingSource = null;\n                    } else {\n                        assertObject(rawUnderlyingSource, \"First parameter\");\n                    }\n                    const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n                    const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, \"First parameter\");\n                    InitializeReadableStream(this);\n                    if (underlyingSource.type === \"bytes\") {\n                        if (strategy.size !== undefined) {\n                            throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n                        }\n                        const highWaterMark = ExtractHighWaterMark(strategy, 0);\n                        SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n                    } else {\n                        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                        const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                        SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n                    }\n                }\n                /**\n\t\t         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n\t\t         */ get locked() {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"locked\");\n                    }\n                    return IsReadableStreamLocked(this);\n                }\n                /**\n\t\t         * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n\t\t         *\n\t\t         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n\t\t         * method, which might or might not use it.\n\t\t         */ cancel(reason = undefined) {\n                    if (!IsReadableStream(this)) {\n                        return promiseRejectedWith(streamBrandCheckException$1(\"cancel\"));\n                    }\n                    if (IsReadableStreamLocked(this)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot cancel a stream that already has a reader\"));\n                    }\n                    return ReadableStreamCancel(this, reason);\n                }\n                getReader(rawOptions = undefined) {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"getReader\");\n                    }\n                    const options = convertReaderOptions(rawOptions, \"First parameter\");\n                    if (options.mode === undefined) {\n                        return AcquireReadableStreamDefaultReader(this);\n                    }\n                    return AcquireReadableStreamBYOBReader(this);\n                }\n                pipeThrough(rawTransform, rawOptions = {}) {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"pipeThrough\");\n                    }\n                    assertRequiredArgument(rawTransform, 1, \"pipeThrough\");\n                    const transform = convertReadableWritablePair(rawTransform, \"First parameter\");\n                    const options = convertPipeOptions(rawOptions, \"Second parameter\");\n                    if (IsReadableStreamLocked(this)) {\n                        throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n                    }\n                    if (IsWritableStreamLocked(transform.writable)) {\n                        throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n                    }\n                    const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n                    setPromiseIsHandledToTrue(promise);\n                    return transform.readable;\n                }\n                pipeTo(destination, rawOptions = {}) {\n                    if (!IsReadableStream(this)) {\n                        return promiseRejectedWith(streamBrandCheckException$1(\"pipeTo\"));\n                    }\n                    if (destination === undefined) {\n                        return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n                    }\n                    if (!IsWritableStream(destination)) {\n                        return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n                    }\n                    let options;\n                    try {\n                        options = convertPipeOptions(rawOptions, \"Second parameter\");\n                    } catch (e) {\n                        return promiseRejectedWith(e);\n                    }\n                    if (IsReadableStreamLocked(this)) {\n                        return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\"));\n                    }\n                    if (IsWritableStreamLocked(destination)) {\n                        return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\"));\n                    }\n                    return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n                }\n                /**\n\t\t         * Tees this readable stream, returning a two-element array containing the two resulting branches as\n\t\t         * new {@link ReadableStream} instances.\n\t\t         *\n\t\t         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n\t\t         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n\t\t         * propagated to the stream's underlying source.\n\t\t         *\n\t\t         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n\t\t         * this could allow interference between the two branches.\n\t\t         */ tee() {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"tee\");\n                    }\n                    const branches = ReadableStreamTee(this);\n                    return CreateArrayFromList(branches);\n                }\n                values(rawOptions = undefined) {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"values\");\n                    }\n                    const options = convertIteratorOptions(rawOptions, \"First parameter\");\n                    return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n                }\n            }\n            Object.defineProperties(ReadableStream1.prototype, {\n                cancel: {\n                    enumerable: true\n                },\n                getReader: {\n                    enumerable: true\n                },\n                pipeThrough: {\n                    enumerable: true\n                },\n                pipeTo: {\n                    enumerable: true\n                },\n                tee: {\n                    enumerable: true\n                },\n                values: {\n                    enumerable: true\n                },\n                locked: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStream1.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStream\",\n                    configurable: true\n                });\n            }\n            if (typeof SymbolPolyfill.asyncIterator === \"symbol\") {\n                Object.defineProperty(ReadableStream1.prototype, SymbolPolyfill.asyncIterator, {\n                    value: ReadableStream1.prototype.values,\n                    writable: true,\n                    configurable: true\n                });\n            }\n            // Abstract operations for the ReadableStream.\n            // Throws if and only if startAlgorithm throws.\n            function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n                const stream = Object.create(ReadableStream1.prototype);\n                InitializeReadableStream(stream);\n                const controller = Object.create(ReadableStreamDefaultController.prototype);\n                SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n                return stream;\n            }\n            // Throws if and only if startAlgorithm throws.\n            function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n                const stream = Object.create(ReadableStream1.prototype);\n                InitializeReadableStream(stream);\n                const controller = Object.create(ReadableByteStreamController.prototype);\n                SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n                return stream;\n            }\n            function InitializeReadableStream(stream) {\n                stream._state = \"readable\";\n                stream._reader = undefined;\n                stream._storedError = undefined;\n                stream._disturbed = false;\n            }\n            function IsReadableStream(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_readableStreamController\")) {\n                    return false;\n                }\n                return x instanceof ReadableStream1;\n            }\n            function IsReadableStreamLocked(stream) {\n                if (stream._reader === undefined) {\n                    return false;\n                }\n                return true;\n            }\n            // ReadableStream API exposed for controllers.\n            function ReadableStreamCancel(stream, reason) {\n                stream._disturbed = true;\n                if (stream._state === \"closed\") {\n                    return promiseResolvedWith(undefined);\n                }\n                if (stream._state === \"errored\") {\n                    return promiseRejectedWith(stream._storedError);\n                }\n                ReadableStreamClose(stream);\n                const reader = stream._reader;\n                if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n                    reader._readIntoRequests.forEach((readIntoRequest)=>{\n                        readIntoRequest._closeSteps(undefined);\n                    });\n                    reader._readIntoRequests = new SimpleQueue();\n                }\n                const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n                return transformPromiseWith(sourceCancelPromise, noop);\n            }\n            function ReadableStreamClose(stream) {\n                stream._state = \"closed\";\n                const reader = stream._reader;\n                if (reader === undefined) {\n                    return;\n                }\n                defaultReaderClosedPromiseResolve(reader);\n                if (IsReadableStreamDefaultReader(reader)) {\n                    reader._readRequests.forEach((readRequest)=>{\n                        readRequest._closeSteps();\n                    });\n                    reader._readRequests = new SimpleQueue();\n                }\n            }\n            function ReadableStreamError(stream, e) {\n                stream._state = \"errored\";\n                stream._storedError = e;\n                const reader = stream._reader;\n                if (reader === undefined) {\n                    return;\n                }\n                defaultReaderClosedPromiseReject(reader, e);\n                if (IsReadableStreamDefaultReader(reader)) {\n                    reader._readRequests.forEach((readRequest)=>{\n                        readRequest._errorSteps(e);\n                    });\n                    reader._readRequests = new SimpleQueue();\n                } else {\n                    reader._readIntoRequests.forEach((readIntoRequest)=>{\n                        readIntoRequest._errorSteps(e);\n                    });\n                    reader._readIntoRequests = new SimpleQueue();\n                }\n            }\n            // Helper functions for the ReadableStream.\n            function streamBrandCheckException$1(name) {\n                return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n            }\n            function convertQueuingStrategyInit(init, context) {\n                assertDictionary(init, context);\n                const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n                assertRequiredField(highWaterMark, \"highWaterMark\", \"QueuingStrategyInit\");\n                return {\n                    highWaterMark: convertUnrestrictedDouble(highWaterMark)\n                };\n            }\n            // The size function must not have a prototype property nor be a constructor\n            const byteLengthSizeFunction = (chunk)=>{\n                return chunk.byteLength;\n            };\n            try {\n                Object.defineProperty(byteLengthSizeFunction, \"name\", {\n                    value: \"size\",\n                    configurable: true\n                });\n            } catch (_a) {\n            // This property is non-configurable in older browsers, so ignore if this throws.\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n            }\n            /**\n\t\t     * A queuing strategy that counts the number of bytes in each chunk.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ByteLengthQueuingStrategy {\n                constructor(options){\n                    assertRequiredArgument(options, 1, \"ByteLengthQueuingStrategy\");\n                    options = convertQueuingStrategyInit(options, \"First parameter\");\n                    this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n                }\n                /**\n\t\t         * Returns the high water mark provided to the constructor.\n\t\t         */ get highWaterMark() {\n                    if (!IsByteLengthQueuingStrategy(this)) {\n                        throw byteLengthBrandCheckException(\"highWaterMark\");\n                    }\n                    return this._byteLengthQueuingStrategyHighWaterMark;\n                }\n                /**\n\t\t         * Measures the size of `chunk` by returning the value of its `byteLength` property.\n\t\t         */ get size() {\n                    if (!IsByteLengthQueuingStrategy(this)) {\n                        throw byteLengthBrandCheckException(\"size\");\n                    }\n                    return byteLengthSizeFunction;\n                }\n            }\n            Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n                highWaterMark: {\n                    enumerable: true\n                },\n                size: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ByteLengthQueuingStrategy\",\n                    configurable: true\n                });\n            }\n            // Helper functions for the ByteLengthQueuingStrategy.\n            function byteLengthBrandCheckException(name) {\n                return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n            }\n            function IsByteLengthQueuingStrategy(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_byteLengthQueuingStrategyHighWaterMark\")) {\n                    return false;\n                }\n                return x instanceof ByteLengthQueuingStrategy;\n            }\n            // The size function must not have a prototype property nor be a constructor\n            const countSizeFunction = ()=>{\n                return 1;\n            };\n            try {\n                Object.defineProperty(countSizeFunction, \"name\", {\n                    value: \"size\",\n                    configurable: true\n                });\n            } catch (_a) {\n            // This property is non-configurable in older browsers, so ignore if this throws.\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n            }\n            /**\n\t\t     * A queuing strategy that counts the number of chunks.\n\t\t     *\n\t\t     * @public\n\t\t     */ class CountQueuingStrategy {\n                constructor(options){\n                    assertRequiredArgument(options, 1, \"CountQueuingStrategy\");\n                    options = convertQueuingStrategyInit(options, \"First parameter\");\n                    this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n                }\n                /**\n\t\t         * Returns the high water mark provided to the constructor.\n\t\t         */ get highWaterMark() {\n                    if (!IsCountQueuingStrategy(this)) {\n                        throw countBrandCheckException(\"highWaterMark\");\n                    }\n                    return this._countQueuingStrategyHighWaterMark;\n                }\n                /**\n\t\t         * Measures the size of `chunk` by always returning 1.\n\t\t         * This ensures that the total queue size is a count of the number of chunks in the queue.\n\t\t         */ get size() {\n                    if (!IsCountQueuingStrategy(this)) {\n                        throw countBrandCheckException(\"size\");\n                    }\n                    return countSizeFunction;\n                }\n            }\n            Object.defineProperties(CountQueuingStrategy.prototype, {\n                highWaterMark: {\n                    enumerable: true\n                },\n                size: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"CountQueuingStrategy\",\n                    configurable: true\n                });\n            }\n            // Helper functions for the CountQueuingStrategy.\n            function countBrandCheckException(name) {\n                return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n            }\n            function IsCountQueuingStrategy(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_countQueuingStrategyHighWaterMark\")) {\n                    return false;\n                }\n                return x instanceof CountQueuingStrategy;\n            }\n            function convertTransformer(original, context) {\n                assertDictionary(original, context);\n                const flush = original === null || original === void 0 ? void 0 : original.flush;\n                const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n                const start = original === null || original === void 0 ? void 0 : original.start;\n                const transform = original === null || original === void 0 ? void 0 : original.transform;\n                const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n                return {\n                    flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n                    readableType,\n                    start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n                    transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n                    writableType\n                };\n            }\n            function convertTransformerFlushCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>promiseCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertTransformerStartCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>reflectCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertTransformerTransformCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (chunk, controller)=>promiseCall(fn, original, [\n                        chunk,\n                        controller\n                    ]);\n            }\n            // Class TransformStream\n            /**\n\t\t     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n\t\t     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n\t\t     * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n\t\t     * made available for reading from the readable side.\n\t\t     *\n\t\t     * @public\n\t\t     */ class TransformStream {\n                constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}){\n                    if (rawTransformer === undefined) {\n                        rawTransformer = null;\n                    }\n                    const writableStrategy = convertQueuingStrategy(rawWritableStrategy, \"Second parameter\");\n                    const readableStrategy = convertQueuingStrategy(rawReadableStrategy, \"Third parameter\");\n                    const transformer = convertTransformer(rawTransformer, \"First parameter\");\n                    if (transformer.readableType !== undefined) {\n                        throw new RangeError(\"Invalid readableType specified\");\n                    }\n                    if (transformer.writableType !== undefined) {\n                        throw new RangeError(\"Invalid writableType specified\");\n                    }\n                    const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n                    const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n                    const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n                    const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n                    let startPromise_resolve;\n                    const startPromise = newPromise((resolve)=>{\n                        startPromise_resolve = resolve;\n                    });\n                    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n                    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n                    if (transformer.start !== undefined) {\n                        startPromise_resolve(transformer.start(this._transformStreamController));\n                    } else {\n                        startPromise_resolve(undefined);\n                    }\n                }\n                /**\n\t\t         * The readable side of the transform stream.\n\t\t         */ get readable() {\n                    if (!IsTransformStream(this)) {\n                        throw streamBrandCheckException(\"readable\");\n                    }\n                    return this._readable;\n                }\n                /**\n\t\t         * The writable side of the transform stream.\n\t\t         */ get writable() {\n                    if (!IsTransformStream(this)) {\n                        throw streamBrandCheckException(\"writable\");\n                    }\n                    return this._writable;\n                }\n            }\n            Object.defineProperties(TransformStream.prototype, {\n                readable: {\n                    enumerable: true\n                },\n                writable: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"TransformStream\",\n                    configurable: true\n                });\n            }\n            function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n                function startAlgorithm() {\n                    return startPromise;\n                }\n                function writeAlgorithm(chunk) {\n                    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n                }\n                function abortAlgorithm(reason) {\n                    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n                }\n                function closeAlgorithm() {\n                    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n                }\n                stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n                function pullAlgorithm() {\n                    return TransformStreamDefaultSourcePullAlgorithm(stream);\n                }\n                function cancelAlgorithm(reason) {\n                    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n                    return promiseResolvedWith(undefined);\n                }\n                stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n                // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n                stream._backpressure = undefined;\n                stream._backpressureChangePromise = undefined;\n                stream._backpressureChangePromise_resolve = undefined;\n                TransformStreamSetBackpressure(stream, true);\n                stream._transformStreamController = undefined;\n            }\n            function IsTransformStream(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_transformStreamController\")) {\n                    return false;\n                }\n                return x instanceof TransformStream;\n            }\n            // This is a no-op if both sides are already errored.\n            function TransformStreamError(stream, e) {\n                ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n                TransformStreamErrorWritableAndUnblockWrite(stream, e);\n            }\n            function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n                TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n                WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n                if (stream._backpressure) {\n                    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n                    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n                    // _backpressure is set.\n                    TransformStreamSetBackpressure(stream, false);\n                }\n            }\n            function TransformStreamSetBackpressure(stream, backpressure) {\n                // Passes also when called during construction.\n                if (stream._backpressureChangePromise !== undefined) {\n                    stream._backpressureChangePromise_resolve();\n                }\n                stream._backpressureChangePromise = newPromise((resolve)=>{\n                    stream._backpressureChangePromise_resolve = resolve;\n                });\n                stream._backpressure = backpressure;\n            }\n            // Class TransformStreamDefaultController\n            /**\n\t\t     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class TransformStreamDefaultController {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.\n\t\t         */ get desiredSize() {\n                    if (!IsTransformStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException(\"desiredSize\");\n                    }\n                    const readableController = this._controlledTransformStream._readable._readableStreamController;\n                    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n                }\n                enqueue(chunk = undefined) {\n                    if (!IsTransformStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException(\"enqueue\");\n                    }\n                    TransformStreamDefaultControllerEnqueue(this, chunk);\n                }\n                /**\n\t\t         * Errors both the readable side and the writable side of the controlled transform stream, making all future\n\t\t         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n\t\t         */ error(reason = undefined) {\n                    if (!IsTransformStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException(\"error\");\n                    }\n                    TransformStreamDefaultControllerError(this, reason);\n                }\n                /**\n\t\t         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n\t\t         * transformer only needs to consume a portion of the chunks written to the writable side.\n\t\t         */ terminate() {\n                    if (!IsTransformStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException(\"terminate\");\n                    }\n                    TransformStreamDefaultControllerTerminate(this);\n                }\n            }\n            Object.defineProperties(TransformStreamDefaultController.prototype, {\n                enqueue: {\n                    enumerable: true\n                },\n                error: {\n                    enumerable: true\n                },\n                terminate: {\n                    enumerable: true\n                },\n                desiredSize: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"TransformStreamDefaultController\",\n                    configurable: true\n                });\n            }\n            // Transform Stream Default Controller Abstract Operations\n            function IsTransformStreamDefaultController(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_controlledTransformStream\")) {\n                    return false;\n                }\n                return x instanceof TransformStreamDefaultController;\n            }\n            function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n                controller._controlledTransformStream = stream;\n                stream._transformStreamController = controller;\n                controller._transformAlgorithm = transformAlgorithm;\n                controller._flushAlgorithm = flushAlgorithm;\n            }\n            function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n                const controller = Object.create(TransformStreamDefaultController.prototype);\n                let transformAlgorithm = (chunk)=>{\n                    try {\n                        TransformStreamDefaultControllerEnqueue(controller, chunk);\n                        return promiseResolvedWith(undefined);\n                    } catch (transformResultE) {\n                        return promiseRejectedWith(transformResultE);\n                    }\n                };\n                let flushAlgorithm = ()=>promiseResolvedWith(undefined);\n                if (transformer.transform !== undefined) {\n                    transformAlgorithm = (chunk)=>transformer.transform(chunk, controller);\n                }\n                if (transformer.flush !== undefined) {\n                    flushAlgorithm = ()=>transformer.flush(controller);\n                }\n                SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n            }\n            function TransformStreamDefaultControllerClearAlgorithms(controller) {\n                controller._transformAlgorithm = undefined;\n                controller._flushAlgorithm = undefined;\n            }\n            function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n                const stream = controller._controlledTransformStream;\n                const readableController = stream._readable._readableStreamController;\n                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n                    throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n                }\n                // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n                // accept TransformStreamDefaultControllerEnqueue() calls.\n                try {\n                    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n                } catch (e) {\n                    // This happens when readableStrategy.size() throws.\n                    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n                    throw stream._readable._storedError;\n                }\n                const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n                if (backpressure !== stream._backpressure) {\n                    TransformStreamSetBackpressure(stream, true);\n                }\n            }\n            function TransformStreamDefaultControllerError(controller, e) {\n                TransformStreamError(controller._controlledTransformStream, e);\n            }\n            function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n                const transformPromise = controller._transformAlgorithm(chunk);\n                return transformPromiseWith(transformPromise, undefined, (r)=>{\n                    TransformStreamError(controller._controlledTransformStream, r);\n                    throw r;\n                });\n            }\n            function TransformStreamDefaultControllerTerminate(controller) {\n                const stream = controller._controlledTransformStream;\n                const readableController = stream._readable._readableStreamController;\n                ReadableStreamDefaultControllerClose(readableController);\n                const error = new TypeError(\"TransformStream terminated\");\n                TransformStreamErrorWritableAndUnblockWrite(stream, error);\n            }\n            // TransformStreamDefaultSink Algorithms\n            function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n                const controller = stream._transformStreamController;\n                if (stream._backpressure) {\n                    const backpressureChangePromise = stream._backpressureChangePromise;\n                    return transformPromiseWith(backpressureChangePromise, ()=>{\n                        const writable = stream._writable;\n                        const state = writable._state;\n                        if (state === \"erroring\") {\n                            throw writable._storedError;\n                        }\n                        return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n                    });\n                }\n                return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n            }\n            function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n                // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n                // errored.\n                TransformStreamError(stream, reason);\n                return promiseResolvedWith(undefined);\n            }\n            function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n                // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n                const readable = stream._readable;\n                const controller = stream._transformStreamController;\n                const flushPromise = controller._flushAlgorithm();\n                TransformStreamDefaultControllerClearAlgorithms(controller);\n                // Return a promise that is fulfilled with undefined on success.\n                return transformPromiseWith(flushPromise, ()=>{\n                    if (readable._state === \"errored\") {\n                        throw readable._storedError;\n                    }\n                    ReadableStreamDefaultControllerClose(readable._readableStreamController);\n                }, (r)=>{\n                    TransformStreamError(stream, r);\n                    throw readable._storedError;\n                });\n            }\n            // TransformStreamDefaultSource Algorithms\n            function TransformStreamDefaultSourcePullAlgorithm(stream) {\n                // Invariant. Enforced by the promises returned by start() and pull().\n                TransformStreamSetBackpressure(stream, false);\n                // Prevent the next pull() call until there is backpressure.\n                return stream._backpressureChangePromise;\n            }\n            // Helper functions for the TransformStreamDefaultController.\n            function defaultControllerBrandCheckException(name) {\n                return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n            }\n            // Helper functions for the TransformStream.\n            function streamBrandCheckException(name) {\n                return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n            }\n            exports1.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n            exports1.CountQueuingStrategy = CountQueuingStrategy;\n            exports1.ReadableByteStreamController = ReadableByteStreamController;\n            exports1.ReadableStream = ReadableStream1;\n            exports1.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n            exports1.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n            exports1.ReadableStreamDefaultController = ReadableStreamDefaultController;\n            exports1.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n            exports1.TransformStream = TransformStream;\n            exports1.TransformStreamDefaultController = TransformStreamDefaultController;\n            exports1.WritableStream = WritableStream;\n            exports1.WritableStreamDefaultController = WritableStreamDefaultController;\n            exports1.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        });\n    })(ponyfill_es2018, ponyfill_es2018.exports);\n    return ponyfill_es2018.exports;\n}\n/* c8 ignore start */ // 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE$1 = 65536;\nif (!globalThis.ReadableStream) {\n    // `node:stream/web` got introduced in v16.5.0 as experimental\n    // and it's preferred over the polyfilled version. So we also\n    // suppress the warning that gets emitted by NodeJS for using it.\n    try {\n        const process1 = __webpack_require__(/*! node:process */ \"node:process\");\n        const { emitWarning } = process1;\n        try {\n            process1.emitWarning = ()=>{};\n            Object.assign(globalThis, __webpack_require__(/*! node:stream/web */ \"node:stream/web\"));\n            process1.emitWarning = emitWarning;\n        } catch (error) {\n            process1.emitWarning = emitWarning;\n            throw error;\n        }\n    } catch (error) {\n        // fallback to polyfill implementation\n        Object.assign(globalThis, requirePonyfill_es2018());\n    }\n}\ntry {\n    // Don't use node: prefix for this, require+node: is not supported until node v14.14\n    // Only `import()` can use prefix in 12.20 and later\n    const { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\n    if (Blob && !Blob.prototype.stream) {\n        Blob.prototype.stream = function name(params) {\n            let position = 0;\n            const blob = this;\n            return new ReadableStream({\n                type: \"bytes\",\n                async pull (ctrl) {\n                    const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));\n                    const buffer = await chunk.arrayBuffer();\n                    position += buffer.byteLength;\n                    ctrl.enqueue(new Uint8Array(buffer));\n                    if (position === blob.size) {\n                        ctrl.close();\n                    }\n                }\n            });\n        };\n    }\n} catch (error) {}\n/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ // 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536;\n/** @param {(Blob | Uint8Array)[]} parts */ async function* toIterator(parts, clone = true) {\n    for (const part of parts){\n        if (\"stream\" in part) {\n            yield* /** @type {AsyncIterableIterator<Uint8Array>} */ part.stream();\n        } else if (ArrayBuffer.isView(part)) {\n            if (clone) {\n                let position = part.byteOffset;\n                const end = part.byteOffset + part.byteLength;\n                while(position !== end){\n                    const size = Math.min(end - position, POOL_SIZE);\n                    const chunk = part.buffer.slice(position, position + size);\n                    position += chunk.byteLength;\n                    yield new Uint8Array(chunk);\n                }\n            } else {\n                yield part;\n            }\n        /* c8 ignore next 10 */ } else {\n            // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n            let position = 0, b = /** @type {Blob} */ part;\n            while(position !== b.size){\n                const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));\n                const buffer = await chunk.arrayBuffer();\n                position += buffer.byteLength;\n                yield new Uint8Array(buffer);\n            }\n        }\n    }\n}\nconst _Blob = class Blob {\n    /** @type {Array.<(Blob|Uint8Array)>} */ #parts;\n    #type;\n    #size;\n    #endings;\n    /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */ constructor(blobParts = [], options = {}){\n        this.#parts = [];\n        this.#type = \"\";\n        this.#size = 0;\n        this.#endings = \"transparent\";\n        if (typeof blobParts !== \"object\" || blobParts === null) {\n            throw new TypeError(\"Failed to construct 'Blob': The provided value cannot be converted to a sequence.\");\n        }\n        if (typeof blobParts[Symbol.iterator] !== \"function\") {\n            throw new TypeError(\"Failed to construct 'Blob': The object must have a callable @@iterator property.\");\n        }\n        if (typeof options !== \"object\" && typeof options !== \"function\") {\n            throw new TypeError(\"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\");\n        }\n        if (options === null) options = {};\n        const encoder = new TextEncoder();\n        for (const element of blobParts){\n            let part;\n            if (ArrayBuffer.isView(element)) {\n                part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n            } else if (element instanceof ArrayBuffer) {\n                part = new Uint8Array(element.slice(0));\n            } else if (element instanceof Blob) {\n                part = element;\n            } else {\n                part = encoder.encode(`${element}`);\n            }\n            const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n            // Avoid pushing empty parts into the array to better GC them\n            if (size) {\n                this.#size += size;\n                this.#parts.push(part);\n            }\n        }\n        this.#endings = `${options.endings === undefined ? \"transparent\" : options.endings}`;\n        const type = options.type === undefined ? \"\" : String(options.type);\n        this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : \"\";\n    }\n    /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */ get size() {\n        return this.#size;\n    }\n    /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */ get type() {\n        return this.#type;\n    }\n    /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */ async text() {\n        // More optimized than using this.arrayBuffer()\n        // that requires twice as much ram\n        const decoder = new TextDecoder();\n        let str = \"\";\n        for await (const part of toIterator(this.#parts, false)){\n            str += decoder.decode(part, {\n                stream: true\n            });\n        }\n        // Remaining\n        str += decoder.decode();\n        return str;\n    }\n    /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */ async arrayBuffer() {\n        // Easier way... Just a unnecessary overhead\n        // const view = new Uint8Array(this.size);\n        // await this.stream().getReader({mode: 'byob'}).read(view);\n        // return view.buffer;\n        const data = new Uint8Array(this.size);\n        let offset = 0;\n        for await (const chunk of toIterator(this.#parts, false)){\n            data.set(chunk, offset);\n            offset += chunk.length;\n        }\n        return data.buffer;\n    }\n    stream() {\n        const it = toIterator(this.#parts, true);\n        return new globalThis.ReadableStream({\n            // @ts-ignore\n            type: \"bytes\",\n            async pull (ctrl) {\n                const chunk = await it.next();\n                chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n            },\n            async cancel () {\n                await it.return();\n            }\n        });\n    }\n    /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */ slice(start = 0, end = this.size, type = \"\") {\n        const { size } = this;\n        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n        const span = Math.max(relativeEnd - relativeStart, 0);\n        const parts = this.#parts;\n        const blobParts = [];\n        let added = 0;\n        for (const part of parts){\n            // don't add the overflow to new blobParts\n            if (added >= span) {\n                break;\n            }\n            const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n            if (relativeStart && size <= relativeStart) {\n                // Skip the beginning and change the relative\n                // start & end position as we skip the unwanted parts\n                relativeStart -= size;\n                relativeEnd -= size;\n            } else {\n                let chunk;\n                if (ArrayBuffer.isView(part)) {\n                    chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));\n                    added += chunk.byteLength;\n                } else {\n                    chunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n                    added += chunk.size;\n                }\n                relativeEnd -= size;\n                blobParts.push(chunk);\n                relativeStart = 0; // All next sequential parts should start at 0\n            }\n        }\n        const blob = new Blob([], {\n            type: String(type).toLowerCase()\n        });\n        blob.#size = span;\n        blob.#parts = blobParts;\n        return blob;\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n    static [Symbol.hasInstance](object) {\n        return object && typeof object === \"object\" && typeof object.constructor === \"function\" && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n    }\n};\nObject.defineProperties(_Blob.prototype, {\n    size: {\n        enumerable: true\n    },\n    type: {\n        enumerable: true\n    },\n    slice: {\n        enumerable: true\n    }\n});\n/** @type {typeof globalThis.Blob} */ const Blob = _Blob;\nconst _Blob$1 = Blob;\nconst _File = class File extends _Blob$1 {\n    #lastModified;\n    #name;\n    /**\n   * @param {*[]} fileBits\n   * @param {string} fileName\n   * @param {{lastModified?: number, type?: string}} options\n   */ // @ts-ignore\n    constructor(fileBits, fileName, options = {}){\n        if (arguments.length < 2) {\n            throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);\n        }\n        super(fileBits, options);\n        this.#lastModified = 0;\n        this.#name = \"\";\n        if (options === null) options = {};\n        // Simulate WebIDL type casting for NaN value in lastModified option.\n        const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified);\n        if (!Number.isNaN(lastModified)) {\n            this.#lastModified = lastModified;\n        }\n        this.#name = String(fileName);\n    }\n    get name() {\n        return this.#name;\n    }\n    get lastModified() {\n        return this.#lastModified;\n    }\n    get [Symbol.toStringTag]() {\n        return \"File\";\n    }\n    static [Symbol.hasInstance](object) {\n        return !!object && object instanceof _Blob$1 && /^(File)$/.test(object[Symbol.toStringTag]);\n    }\n};\n/** @type {typeof globalThis.File} */ // @ts-ignore\nconst File = _File;\nconst File$1 = File;\n/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ var { toStringTag: t, iterator: i, hasInstance: h } = Symbol, r = Math.random, m = \"append,set,get,getAll,delete,keys,values,entries,forEach,constructor\".split(\",\"), f = (a, b, c)=>(a += \"\", /^(Blob|File)$/.test(b && b[t]) ? [\n        (c = c !== void 0 ? c + \"\" : b[t] == \"File\" ? b.name : \"blob\", a),\n        b.name !== c || b[t] == \"blob\" ? new File$1([\n            b\n        ], c, b) : b\n    ] : [\n        a,\n        b + \"\"\n    ]), e = (c, f)=>(f ? c : c.replace(/\\r?\\n|\\r/g, \"\\r\\n\")).replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\"), x = (n, a, e)=>{\n    if (a.length < e) {\n        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`);\n    }\n};\n/** @type {typeof globalThis.FormData} */ const FormData = class FormData {\n    #d;\n    constructor(...a){\n        this.#d = [];\n        if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);\n    }\n    get [t]() {\n        return \"FormData\";\n    }\n    [i]() {\n        return this.entries();\n    }\n    static [h](o) {\n        return o && typeof o === \"object\" && o[t] === \"FormData\" && !m.some((m)=>typeof o[m] != \"function\");\n    }\n    append(...a) {\n        x(\"append\", arguments, 2);\n        this.#d.push(f(...a));\n    }\n    delete(a) {\n        x(\"delete\", arguments, 1);\n        a += \"\";\n        this.#d = this.#d.filter(([b])=>b !== a);\n    }\n    get(a) {\n        x(\"get\", arguments, 1);\n        a += \"\";\n        for(var b = this.#d, l = b.length, c = 0; c < l; c++)if (b[c][0] === a) return b[c][1];\n        return null;\n    }\n    getAll(a, b) {\n        x(\"getAll\", arguments, 1);\n        b = [];\n        a += \"\";\n        this.#d.forEach((c)=>c[0] === a && b.push(c[1]));\n        return b;\n    }\n    has(a) {\n        x(\"has\", arguments, 1);\n        a += \"\";\n        return this.#d.some((b)=>b[0] === a);\n    }\n    forEach(a, b) {\n        x(\"forEach\", arguments, 1);\n        for (var [c, d] of this)a.call(b, d, c, this);\n    }\n    set(...a) {\n        x(\"set\", arguments, 2);\n        var b = [], c = !0;\n        a = f(...a);\n        this.#d.forEach((d)=>{\n            d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);\n        });\n        c && b.push(a);\n        this.#d = b;\n    }\n    *entries() {\n        yield* this.#d;\n    }\n    *keys() {\n        for (var [a] of this)yield a;\n    }\n    *values() {\n        for (var [, a] of this)yield a;\n    }\n};\n/** @param {FormData} F */ function formDataToBlob(F, B = _Blob$1) {\n    var b = `${r()}${r()}`.replace(/\\./g, \"\").slice(-28).padStart(32, \"-\"), c = [], p = `--${b}\\r\\nContent-Disposition: form-data; name=\"`;\n    F.forEach((v, n)=>typeof v == \"string\" ? c.push(p + e(n) + `\"\\r\\n\\r\\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, \"\\r\\n\")}\\r\\n`) : c.push(p + e(n) + `\"; filename=\"${e(v.name, 1)}\"\\r\\nContent-Type: ${v.type || \"application/octet-stream\"}\\r\\n\\r\\n`, v, \"\\r\\n\"));\n    c.push(`--${b}--`);\n    return new B(c, {\n        type: \"multipart/form-data; boundary=\" + b\n    });\n}\nclass FetchBaseError extends Error {\n    constructor(message, type){\n        super(message);\n        // Hide custom error implementation details from end-users\n        Error.captureStackTrace(this, this.constructor);\n        this.type = type;\n    }\n    get name() {\n        return this.constructor.name;\n    }\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n/**\n * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError\n*/ /**\n * FetchError interface for operational errors\n */ class FetchError extends FetchBaseError {\n    /**\n\t * @param  {string} message -      Error message for human\n\t * @param  {string} [type] -        Error type for machine\n\t * @param  {SystemError} [systemError] - For Node.js system error\n\t */ constructor(message, type, systemError){\n        super(message, type);\n        // When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code\n        if (systemError) {\n            // eslint-disable-next-line no-multi-assign\n            this.code = this.errno = systemError.code;\n            this.erroredSysCall = systemError.syscall;\n        }\n    }\n}\n/**\n * Is.js\n *\n * Object type checks.\n */ const NAME = Symbol.toStringTag;\n/**\n * Check if `obj` is a URLSearchParams object\n * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143\n * @param {*} object - Object to check for\n * @return {boolean}\n */ const isURLSearchParameters = (object)=>{\n    return typeof object === \"object\" && typeof object.append === \"function\" && typeof object.delete === \"function\" && typeof object.get === \"function\" && typeof object.getAll === \"function\" && typeof object.has === \"function\" && typeof object.set === \"function\" && typeof object.sort === \"function\" && object[NAME] === \"URLSearchParams\";\n};\n/**\n * Check if `object` is a W3C `Blob` object (which `File` inherits from)\n * @param {*} object - Object to check for\n * @return {boolean}\n */ const isBlob = (object)=>{\n    return object && typeof object === \"object\" && typeof object.arrayBuffer === \"function\" && typeof object.type === \"string\" && typeof object.stream === \"function\" && typeof object.constructor === \"function\" && /^(Blob|File)$/.test(object[NAME]);\n};\n/**\n * Check if `obj` is an instance of AbortSignal.\n * @param {*} object - Object to check for\n * @return {boolean}\n */ const isAbortSignal = (object)=>{\n    return typeof object === \"object\" && (object[NAME] === \"AbortSignal\" || object[NAME] === \"EventTarget\");\n};\n/**\n * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of\n * the parent domain.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */ const isDomainOrSubdomain = (destination, original)=>{\n    const orig = new URL(original).hostname;\n    const dest = new URL(destination).hostname;\n    return orig === dest || orig.endsWith(`.${dest}`);\n};\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */ const isSameProtocol = (destination, original)=>{\n    const orig = new URL(original).protocol;\n    const dest = new URL(destination).protocol;\n    return orig === dest;\n};\nconst pipeline = node_util.promisify(Stream.pipeline);\nconst INTERNALS$2 = Symbol(\"Body internals\");\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ class Body {\n    constructor(body, { size = 0 } = {}){\n        let boundary = null;\n        if (body === null) {\n            // Body is undefined or null\n            body = null;\n        } else if (isURLSearchParameters(body)) {\n            // Body is a URLSearchParams\n            body = node_buffer.Buffer.from(body.toString());\n        } else if (isBlob(body)) ;\n        else if (node_buffer.Buffer.isBuffer(body)) ;\n        else if (node_util.types.isAnyArrayBuffer(body)) {\n            // Body is ArrayBuffer\n            body = node_buffer.Buffer.from(body);\n        } else if (ArrayBuffer.isView(body)) {\n            // Body is ArrayBufferView\n            body = node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n        } else if (body instanceof Stream) ;\n        else if (body instanceof FormData) {\n            // Body is FormData\n            body = formDataToBlob(body);\n            boundary = body.type.split(\"=\")[1];\n        } else {\n            // None of the above\n            // coerce to string then buffer\n            body = node_buffer.Buffer.from(String(body));\n        }\n        let stream = body;\n        if (node_buffer.Buffer.isBuffer(body)) {\n            stream = Stream.Readable.from(body);\n        } else if (isBlob(body)) {\n            stream = Stream.Readable.from(body.stream());\n        }\n        this[INTERNALS$2] = {\n            body,\n            stream,\n            boundary,\n            disturbed: false,\n            error: null\n        };\n        this.size = size;\n        if (body instanceof Stream) {\n            body.on(\"error\", (error_)=>{\n                const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, \"system\", error_);\n                this[INTERNALS$2].error = error;\n            });\n        }\n    }\n    get body() {\n        return this[INTERNALS$2].stream;\n    }\n    get bodyUsed() {\n        return this[INTERNALS$2].disturbed;\n    }\n    /**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */ async arrayBuffer() {\n        const { buffer, byteOffset, byteLength } = await consumeBody(this);\n        return buffer.slice(byteOffset, byteOffset + byteLength);\n    }\n    async formData() {\n        const ct = this.headers.get(\"content-type\");\n        if (ct.startsWith(\"application/x-www-form-urlencoded\")) {\n            const formData = new FormData();\n            const parameters = new URLSearchParams(await this.text());\n            for (const [name, value1] of parameters){\n                formData.append(name, value1);\n            }\n            return formData;\n        }\n        const { toFormData } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/node-fetch-native\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../chunks/multipart-parser.cjs */ \"(rsc)/./node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs\", 19));\n        return toFormData(this.body, ct);\n    }\n    /**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */ async blob() {\n        const ct = this.headers && this.headers.get(\"content-type\") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || \"\";\n        const buf = await this.arrayBuffer();\n        return new _Blob$1([\n            buf\n        ], {\n            type: ct\n        });\n    }\n    /**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */ async json() {\n        const text = await this.text();\n        return JSON.parse(text);\n    }\n    /**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */ async text() {\n        const buffer = await consumeBody(this);\n        return new TextDecoder().decode(buffer);\n    }\n    /**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */ buffer() {\n        return consumeBody(this);\n    }\n}\nBody.prototype.buffer = node_util.deprecate(Body.prototype.buffer, \"Please use 'response.arrayBuffer()' instead of 'response.buffer()'\", \"node-fetch#buffer\");\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n    body: {\n        enumerable: true\n    },\n    bodyUsed: {\n        enumerable: true\n    },\n    arrayBuffer: {\n        enumerable: true\n    },\n    blob: {\n        enumerable: true\n    },\n    json: {\n        enumerable: true\n    },\n    text: {\n        enumerable: true\n    },\n    data: {\n        get: node_util.deprecate(()=>{}, \"data doesn't exist, use json(), text(), arrayBuffer(), or body instead\", \"https://github.com/node-fetch/node-fetch/issues/1000 (response)\")\n    }\n});\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */ async function consumeBody(data) {\n    if (data[INTERNALS$2].disturbed) {\n        throw new TypeError(`body used already for: ${data.url}`);\n    }\n    data[INTERNALS$2].disturbed = true;\n    if (data[INTERNALS$2].error) {\n        throw data[INTERNALS$2].error;\n    }\n    const { body } = data;\n    // Body is null\n    if (body === null) {\n        return node_buffer.Buffer.alloc(0);\n    }\n    /* c8 ignore next 3 */ if (!(body instanceof Stream)) {\n        return node_buffer.Buffer.alloc(0);\n    }\n    // Body is stream\n    // get ready to actually consume the body\n    const accum = [];\n    let accumBytes = 0;\n    try {\n        for await (const chunk of body){\n            if (data.size > 0 && accumBytes + chunk.length > data.size) {\n                const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, \"max-size\");\n                body.destroy(error);\n                throw error;\n            }\n            accumBytes += chunk.length;\n            accum.push(chunk);\n        }\n    } catch (error) {\n        const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, \"system\", error);\n        throw error_;\n    }\n    if (body.readableEnded === true || body._readableState.ended === true) {\n        try {\n            if (accum.every((c)=>typeof c === \"string\")) {\n                return node_buffer.Buffer.from(accum.join(\"\"));\n            }\n            return node_buffer.Buffer.concat(accum, accumBytes);\n        } catch (error) {\n            throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, \"system\", error);\n        }\n    } else {\n        throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n    }\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */ const clone = (instance, highWaterMark)=>{\n    let p1;\n    let p2;\n    let { body } = instance[INTERNALS$2];\n    // Don't allow cloning a used body\n    if (instance.bodyUsed) {\n        throw new Error(\"cannot clone body after it is used\");\n    }\n    // Check that body is a stream and not form-data object\n    // note: we can't clone the form-data object without having it as a dependency\n    if (body instanceof Stream && typeof body.getBoundary !== \"function\") {\n        // Tee instance body\n        p1 = new Stream.PassThrough({\n            highWaterMark\n        });\n        p2 = new Stream.PassThrough({\n            highWaterMark\n        });\n        body.pipe(p1);\n        body.pipe(p2);\n        // Set instance body to teed body and return the other teed body\n        instance[INTERNALS$2].stream = p1;\n        body = p2;\n    }\n    return body;\n};\nconst getNonSpecFormDataBoundary = node_util.deprecate((body)=>body.getBoundary(), \"form-data doesn't follow the spec and requires special treatment. Use alternative package\", \"https://github.com/node-fetch/node-fetch/issues/1167\");\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */ const extractContentType = (body, request)=>{\n    // Body is null or undefined\n    if (body === null) {\n        return null;\n    }\n    // Body is string\n    if (typeof body === \"string\") {\n        return \"text/plain;charset=UTF-8\";\n    }\n    // Body is a URLSearchParams\n    if (isURLSearchParameters(body)) {\n        return \"application/x-www-form-urlencoded;charset=UTF-8\";\n    }\n    // Body is blob\n    if (isBlob(body)) {\n        return body.type || null;\n    }\n    // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n    if (node_buffer.Buffer.isBuffer(body) || node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n        return null;\n    }\n    if (body instanceof FormData) {\n        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;\n    }\n    // Detect form data input from form-data module\n    if (body && typeof body.getBoundary === \"function\") {\n        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n    }\n    // Body is stream - can't really do much about this\n    if (body instanceof Stream) {\n        return null;\n    }\n    // Body constructor defaults other things to string\n    return \"text/plain;charset=UTF-8\";\n};\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */ const getTotalBytes = (request)=>{\n    const { body } = request[INTERNALS$2];\n    // Body is null or undefined\n    if (body === null) {\n        return 0;\n    }\n    // Body is Blob\n    if (isBlob(body)) {\n        return body.size;\n    }\n    // Body is Buffer\n    if (node_buffer.Buffer.isBuffer(body)) {\n        return body.length;\n    }\n    // Detect form data input from form-data module\n    if (body && typeof body.getLengthSync === \"function\") {\n        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n    }\n    // Body is stream\n    return null;\n};\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */ const writeToStream = async (dest, { body })=>{\n    if (body === null) {\n        // Body is null\n        dest.end();\n    } else {\n        // Body is stream\n        await pipeline(body, dest);\n    }\n};\n/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */ /* c8 ignore next 9 */ const validateHeaderName = typeof http.validateHeaderName === \"function\" ? http.validateHeaderName : (name)=>{\n    if (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n        const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n        Object.defineProperty(error, \"code\", {\n            value: \"ERR_INVALID_HTTP_TOKEN\"\n        });\n        throw error;\n    }\n};\n/* c8 ignore next 9 */ const validateHeaderValue = typeof http.validateHeaderValue === \"function\" ? http.validateHeaderValue : (name, value1)=>{\n    if (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value1)) {\n        const error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n        Object.defineProperty(error, \"code\", {\n            value: \"ERR_INVALID_CHAR\"\n        });\n        throw error;\n    }\n};\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */ /**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */ class Headers extends URLSearchParams {\n    /**\n\t * Headers class\n\t *\n\t * @constructor\n\t * @param {HeadersInit} [init] - Response headers\n\t */ constructor(init){\n        // Validate and normalize init object in [name, value(s)][]\n        /** @type {string[][]} */ let result = [];\n        if (init instanceof Headers) {\n            const raw = init.raw();\n            for (const [name, values] of Object.entries(raw)){\n                result.push(...values.map((value1)=>[\n                        name,\n                        value1\n                    ]));\n            }\n        } else if (init == null) ;\n        else if (typeof init === \"object\" && !node_util.types.isBoxedPrimitive(init)) {\n            const method = init[Symbol.iterator];\n            // eslint-disable-next-line no-eq-null, eqeqeq\n            if (method == null) {\n                // Record<ByteString, ByteString>\n                result.push(...Object.entries(init));\n            } else {\n                if (typeof method !== \"function\") {\n                    throw new TypeError(\"Header pairs must be iterable\");\n                }\n                // Sequence<sequence<ByteString>>\n                // Note: per spec we have to first exhaust the lists then process them\n                result = [\n                    ...init\n                ].map((pair)=>{\n                    if (typeof pair !== \"object\" || node_util.types.isBoxedPrimitive(pair)) {\n                        throw new TypeError(\"Each header pair must be an iterable object\");\n                    }\n                    return [\n                        ...pair\n                    ];\n                }).map((pair)=>{\n                    if (pair.length !== 2) {\n                        throw new TypeError(\"Each header pair must be a name/value tuple\");\n                    }\n                    return [\n                        ...pair\n                    ];\n                });\n            }\n        } else {\n            throw new TypeError(\"Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)\");\n        }\n        // Validate and lowercase\n        result = result.length > 0 ? result.map(([name, value1])=>{\n            validateHeaderName(name);\n            validateHeaderValue(name, String(value1));\n            return [\n                String(name).toLowerCase(),\n                String(value1)\n            ];\n        }) : undefined;\n        super(result);\n        // Returning a Proxy that will lowercase key names, validate parameters and sort keys\n        // eslint-disable-next-line no-constructor-return\n        return new Proxy(this, {\n            get (target, p, receiver) {\n                switch(p){\n                    case \"append\":\n                    case \"set\":\n                        return (name, value1)=>{\n                            validateHeaderName(name);\n                            validateHeaderValue(name, String(value1));\n                            return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value1));\n                        };\n                    case \"delete\":\n                    case \"has\":\n                    case \"getAll\":\n                        return (name)=>{\n                            validateHeaderName(name);\n                            return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());\n                        };\n                    case \"keys\":\n                        return ()=>{\n                            target.sort();\n                            return new Set(URLSearchParams.prototype.keys.call(target)).keys();\n                        };\n                    default:\n                        return Reflect.get(target, p, receiver);\n                }\n            }\n        });\n    /* c8 ignore next */ }\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n    toString() {\n        return Object.prototype.toString.call(this);\n    }\n    get(name) {\n        const values = this.getAll(name);\n        if (values.length === 0) {\n            return null;\n        }\n        let value1 = values.join(\", \");\n        if (/^content-encoding$/i.test(name)) {\n            value1 = value1.toLowerCase();\n        }\n        return value1;\n    }\n    forEach(callback, thisArg = undefined) {\n        for (const name of this.keys()){\n            Reflect.apply(callback, thisArg, [\n                this.get(name),\n                name,\n                this\n            ]);\n        }\n    }\n    *values() {\n        for (const name of this.keys()){\n            yield this.get(name);\n        }\n    }\n    /**\n\t * @type {() => IterableIterator<[string, string]>}\n\t */ *entries() {\n        for (const name of this.keys()){\n            yield [\n                name,\n                this.get(name)\n            ];\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n\t * Node-fetch non-spec method\n\t * returning all headers and their values as array\n\t * @returns {Record<string, string[]>}\n\t */ raw() {\n        return [\n            ...this.keys()\n        ].reduce((result, key)=>{\n            result[key] = this.getAll(key);\n            return result;\n        }, {});\n    }\n    /**\n\t * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n\t */ [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return [\n            ...this.keys()\n        ].reduce((result, key)=>{\n            const values = this.getAll(key);\n            // Http.request() only supports string as Host header.\n            // This hack makes specifying custom Host header possible.\n            if (key === \"host\") {\n                result[key] = values[0];\n            } else {\n                result[key] = values.length > 1 ? values : values[0];\n            }\n            return result;\n        }, {});\n    }\n}\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */ Object.defineProperties(Headers.prototype, [\n    \"get\",\n    \"entries\",\n    \"forEach\",\n    \"values\"\n].reduce((result, property)=>{\n    result[property] = {\n        enumerable: true\n    };\n    return result;\n}, {}));\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */ function fromRawHeaders(headers = []) {\n    return new Headers(headers// Split into pairs\n    .reduce((result, value1, index, array)=>{\n        if (index % 2 === 0) {\n            result.push(array.slice(index, index + 2));\n        }\n        return result;\n    }, []).filter(([name, value1])=>{\n        try {\n            validateHeaderName(name);\n            validateHeaderValue(name, String(value1));\n            return true;\n        } catch  {\n            return false;\n        }\n    }));\n}\nconst redirectStatus = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\n/**\n * Redirect code matching\n *\n * @param {number} code - Status code\n * @return {boolean}\n */ const isRedirect = (code)=>{\n    return redirectStatus.has(code);\n};\n/**\n * Response.js\n *\n * Response class provides content decoding\n */ const INTERNALS$1 = Symbol(\"Response internals\");\n/**\n * Response class\n *\n * Ref: https://fetch.spec.whatwg.org/#response-class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ class Response extends Body {\n    constructor(body = null, options = {}){\n        super(body, options);\n        // eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition\n        const status = options.status != null ? options.status : 200;\n        const headers = new Headers(options.headers);\n        if (body !== null && !headers.has(\"Content-Type\")) {\n            const contentType = extractContentType(body, this);\n            if (contentType) {\n                headers.append(\"Content-Type\", contentType);\n            }\n        }\n        this[INTERNALS$1] = {\n            type: \"default\",\n            url: options.url,\n            status,\n            statusText: options.statusText || \"\",\n            headers,\n            counter: options.counter,\n            highWaterMark: options.highWaterMark\n        };\n    }\n    get type() {\n        return this[INTERNALS$1].type;\n    }\n    get url() {\n        return this[INTERNALS$1].url || \"\";\n    }\n    get status() {\n        return this[INTERNALS$1].status;\n    }\n    /**\n\t * Convenience property representing if the request ended normally\n\t */ get ok() {\n        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n    }\n    get redirected() {\n        return this[INTERNALS$1].counter > 0;\n    }\n    get statusText() {\n        return this[INTERNALS$1].statusText;\n    }\n    get headers() {\n        return this[INTERNALS$1].headers;\n    }\n    get highWaterMark() {\n        return this[INTERNALS$1].highWaterMark;\n    }\n    /**\n\t * Clone this response\n\t *\n\t * @return  Response\n\t */ clone() {\n        return new Response(clone(this, this.highWaterMark), {\n            type: this.type,\n            url: this.url,\n            status: this.status,\n            statusText: this.statusText,\n            headers: this.headers,\n            ok: this.ok,\n            redirected: this.redirected,\n            size: this.size,\n            highWaterMark: this.highWaterMark\n        });\n    }\n    /**\n\t * @param {string} url    The URL that the new response is to originate from.\n\t * @param {number} status An optional status code for the response (e.g., 302.)\n\t * @returns {Response}    A Response object.\n\t */ static redirect(url, status = 302) {\n        if (!isRedirect(status)) {\n            throw new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n        }\n        return new Response(null, {\n            headers: {\n                location: new URL(url).toString()\n            },\n            status\n        });\n    }\n    static error() {\n        const response = new Response(null, {\n            status: 0,\n            statusText: \"\"\n        });\n        response[INTERNALS$1].type = \"error\";\n        return response;\n    }\n    static json(data = undefined, init = {}) {\n        const body = JSON.stringify(data);\n        if (body === undefined) {\n            throw new TypeError(\"data is not JSON serializable\");\n        }\n        const headers = new Headers(init && init.headers);\n        if (!headers.has(\"content-type\")) {\n            headers.set(\"content-type\", \"application/json\");\n        }\n        return new Response(body, {\n            ...init,\n            headers\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Response\";\n    }\n}\nObject.defineProperties(Response.prototype, {\n    type: {\n        enumerable: true\n    },\n    url: {\n        enumerable: true\n    },\n    status: {\n        enumerable: true\n    },\n    ok: {\n        enumerable: true\n    },\n    redirected: {\n        enumerable: true\n    },\n    statusText: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    }\n});\nconst getSearch = (parsedURL)=>{\n    if (parsedURL.search) {\n        return parsedURL.search;\n    }\n    const lastOffset = parsedURL.href.length - 1;\n    const hash = parsedURL.hash || (parsedURL.href[lastOffset] === \"#\" ? \"#\" : \"\");\n    return parsedURL.href[lastOffset - hash.length] === \"?\" ? \"?\" : \"\";\n};\n/**\n * @external URL\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}\n */ /**\n * @module utils/referrer\n * @private\n */ /**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}\n * @param {string} URL\n * @param {boolean} [originOnly=false]\n */ function stripURLForUseAsAReferrer(url, originOnly = false) {\n    // 1. If url is null, return no referrer.\n    if (url == null) {\n        return \"no-referrer\";\n    }\n    url = new URL(url);\n    // 2. If url's scheme is a local scheme, then return no referrer.\n    if (/^(about|blob|data):$/.test(url.protocol)) {\n        return \"no-referrer\";\n    }\n    // 3. Set url's username to the empty string.\n    url.username = \"\";\n    // 4. Set url's password to null.\n    // Note: `null` appears to be a mistake as this actually results in the password being `\"null\"`.\n    url.password = \"\";\n    // 5. Set url's fragment to null.\n    // Note: `null` appears to be a mistake as this actually results in the fragment being `\"#null\"`.\n    url.hash = \"\";\n    // 6. If the origin-only flag is true, then:\n    if (originOnly) {\n        // 6.1. Set url's path to null.\n        // Note: `null` appears to be a mistake as this actually results in the path being `\"/null\"`.\n        url.pathname = \"\";\n        // 6.2. Set url's query to null.\n        // Note: `null` appears to be a mistake as this actually results in the query being `\"?null\"`.\n        url.search = \"\";\n    }\n    // 7. Return url.\n    return url;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}\n */ const ReferrerPolicy = new Set([\n    \"\",\n    \"no-referrer\",\n    \"no-referrer-when-downgrade\",\n    \"same-origin\",\n    \"origin\",\n    \"strict-origin\",\n    \"origin-when-cross-origin\",\n    \"strict-origin-when-cross-origin\",\n    \"unsafe-url\"\n]);\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}\n */ const DEFAULT_REFERRER_POLICY = \"strict-origin-when-cross-origin\";\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}\n * @param {string} referrerPolicy\n * @returns {string} referrerPolicy\n */ function validateReferrerPolicy(referrerPolicy) {\n    if (!ReferrerPolicy.has(referrerPolicy)) {\n        throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n    }\n    return referrerPolicy;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */ function isOriginPotentiallyTrustworthy(url) {\n    // 1. If origin is an opaque origin, return \"Not Trustworthy\".\n    // Not applicable\n    // 2. Assert: origin is a tuple origin.\n    // Not for implementations\n    // 3. If origin's scheme is either \"https\" or \"wss\", return \"Potentially Trustworthy\".\n    if (/^(http|ws)s:$/.test(url.protocol)) {\n        return true;\n    }\n    // 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n    const hostIp = url.host.replace(/(^\\[)|(]$)/g, \"\");\n    const hostIPVersion = node_net.isIP(hostIp);\n    if (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n        return true;\n    }\n    if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n        return true;\n    }\n    // 5. If origin's host component is \"localhost\" or falls within \".localhost\", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return \"Potentially Trustworthy\".\n    // We are returning FALSE here because we cannot ensure conformance to\n    // let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)\n    if (url.host === \"localhost\" || url.host.endsWith(\".localhost\")) {\n        return false;\n    }\n    // 6. If origin's scheme component is file, return \"Potentially Trustworthy\".\n    if (url.protocol === \"file:\") {\n        return true;\n    }\n    // 7. If origin's scheme component is one which the user agent considers to be authenticated, return \"Potentially Trustworthy\".\n    // Not supported\n    // 8. If origin has been configured as a trustworthy origin, return \"Potentially Trustworthy\".\n    // Not supported\n    // 9. Return \"Not Trustworthy\".\n    return false;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */ function isUrlPotentiallyTrustworthy(url) {\n    // 1. If url is \"about:blank\" or \"about:srcdoc\", return \"Potentially Trustworthy\".\n    if (/^about:(blank|srcdoc)$/.test(url)) {\n        return true;\n    }\n    // 2. If url's scheme is \"data\", return \"Potentially Trustworthy\".\n    if (url.protocol === \"data:\") {\n        return true;\n    }\n    // Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were\n    // created. Therefore, blobs created in a trustworthy origin will themselves be potentially\n    // trustworthy.\n    if (/^(blob|filesystem):$/.test(url.protocol)) {\n        return true;\n    }\n    // 3. Return the result of executing §3.2 Is origin potentially trustworthy? on url's origin.\n    return isOriginPotentiallyTrustworthy(url);\n}\n/**\n * Modifies the referrerURL to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerURLCallback\n * @param {external:URL} referrerURL\n * @returns {external:URL} modified referrerURL\n */ /**\n * Modifies the referrerOrigin to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerOriginCallback\n * @param {external:URL} referrerOrigin\n * @returns {external:URL} modified referrerOrigin\n */ /**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}\n * @param {Request} request\n * @param {object} o\n * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback\n * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback\n * @returns {external:URL} Request's referrer\n */ function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {\n    // There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for\n    // these cases:\n    // > Note: If request's referrer is \"no-referrer\", Fetch will not call into this algorithm.\n    // > Note: If request's referrer policy is the empty string, Fetch will not call into this\n    // > algorithm.\n    if (request.referrer === \"no-referrer\" || request.referrerPolicy === \"\") {\n        return null;\n    }\n    // 1. Let policy be request's associated referrer policy.\n    const policy = request.referrerPolicy;\n    // 2. Let environment be request's client.\n    // not applicable to node.js\n    // 3. Switch on request's referrer:\n    if (request.referrer === \"about:client\") {\n        return \"no-referrer\";\n    }\n    // \"a URL\": Let referrerSource be request's referrer.\n    const referrerSource = request.referrer;\n    // 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.\n    let referrerURL = stripURLForUseAsAReferrer(referrerSource);\n    // 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the\n    //    origin-only flag set to true.\n    let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);\n    // 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set\n    //    referrerURL to referrerOrigin.\n    if (referrerURL.toString().length > 4096) {\n        referrerURL = referrerOrigin;\n    }\n    // 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary\n    //    policy considerations in the interests of minimizing data leakage. For example, the user\n    //    agent could strip the URL down to an origin, modify its host, replace it with an empty\n    //    string, etc.\n    if (referrerURLCallback) {\n        referrerURL = referrerURLCallback(referrerURL);\n    }\n    if (referrerOriginCallback) {\n        referrerOrigin = referrerOriginCallback(referrerOrigin);\n    }\n    // 8.Execute the statements corresponding to the value of policy:\n    const currentURL = new URL(request.url);\n    switch(policy){\n        case \"no-referrer\":\n            return \"no-referrer\";\n        case \"origin\":\n            return referrerOrigin;\n        case \"unsafe-url\":\n            return referrerURL;\n        case \"strict-origin\":\n            // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n            //    potentially trustworthy URL, then return no referrer.\n            if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n                return \"no-referrer\";\n            }\n            // 2. Return referrerOrigin.\n            return referrerOrigin.toString();\n        case \"strict-origin-when-cross-origin\":\n            // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n            //    return referrerURL.\n            if (referrerURL.origin === currentURL.origin) {\n                return referrerURL;\n            }\n            // 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n            //    potentially trustworthy URL, then return no referrer.\n            if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n                return \"no-referrer\";\n            }\n            // 3. Return referrerOrigin.\n            return referrerOrigin;\n        case \"same-origin\":\n            // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n            //    return referrerURL.\n            if (referrerURL.origin === currentURL.origin) {\n                return referrerURL;\n            }\n            // 2. Return no referrer.\n            return \"no-referrer\";\n        case \"origin-when-cross-origin\":\n            // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n            //    return referrerURL.\n            if (referrerURL.origin === currentURL.origin) {\n                return referrerURL;\n            }\n            // Return referrerOrigin.\n            return referrerOrigin;\n        case \"no-referrer-when-downgrade\":\n            // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n            //    potentially trustworthy URL, then return no referrer.\n            if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n                return \"no-referrer\";\n            }\n            // 2. Return referrerURL.\n            return referrerURL;\n        default:\n            throw new TypeError(`Invalid referrerPolicy: ${policy}`);\n    }\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}\n * @param {Headers} headers Response headers\n * @returns {string} policy\n */ function parseReferrerPolicyFromHeader(headers) {\n    // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`\n    //    and response’s header list.\n    const policyTokens = (headers.get(\"referrer-policy\") || \"\").split(/[,\\s]+/);\n    // 2. Let policy be the empty string.\n    let policy = \"\";\n    // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty\n    //    string, then set policy to token.\n    // Note: This algorithm loops over multiple policy values to allow deployment of new policy\n    // values with fallbacks for older user agents, as described in § 11.1 Unknown Policy Values.\n    for (const token of policyTokens){\n        if (token && ReferrerPolicy.has(token)) {\n            policy = token;\n        }\n    }\n    // 4. Return policy.\n    return policy;\n}\n/**\n * Request.js\n *\n * Request class contains server only options\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */ const INTERNALS = Symbol(\"Request internals\");\n/**\n * Check if `obj` is an instance of Request.\n *\n * @param  {*} object\n * @return {boolean}\n */ const isRequest = (object)=>{\n    return typeof object === \"object\" && typeof object[INTERNALS] === \"object\";\n};\nconst doBadDataWarn = node_util.deprecate(()=>{}, \".data is not a valid RequestInit property, use .body instead\", \"https://github.com/node-fetch/node-fetch/issues/1000 (request)\");\n/**\n * Request class\n *\n * Ref: https://fetch.spec.whatwg.org/#request-class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */ class Request extends Body {\n    constructor(input, init = {}){\n        let parsedURL;\n        // Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)\n        if (isRequest(input)) {\n            parsedURL = new URL(input.url);\n        } else {\n            parsedURL = new URL(input);\n            input = {};\n        }\n        if (parsedURL.username !== \"\" || parsedURL.password !== \"\") {\n            throw new TypeError(`${parsedURL} is an url with embedded credentials.`);\n        }\n        let method = init.method || input.method || \"GET\";\n        if (/^(delete|get|head|options|post|put)$/i.test(method)) {\n            method = method.toUpperCase();\n        }\n        if (!isRequest(init) && \"data\" in init) {\n            doBadDataWarn();\n        }\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if ((init.body != null || isRequest(input) && input.body !== null) && (method === \"GET\" || method === \"HEAD\")) {\n            throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n        }\n        const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n        super(inputBody, {\n            size: init.size || input.size || 0\n        });\n        const headers = new Headers(init.headers || input.headers || {});\n        if (inputBody !== null && !headers.has(\"Content-Type\")) {\n            const contentType = extractContentType(inputBody, this);\n            if (contentType) {\n                headers.set(\"Content-Type\", contentType);\n            }\n        }\n        let signal = isRequest(input) ? input.signal : null;\n        if (\"signal\" in init) {\n            signal = init.signal;\n        }\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (signal != null && !isAbortSignal(signal)) {\n            throw new TypeError(\"Expected signal to be an instanceof AbortSignal or EventTarget\");\n        }\n        // §5.4, Request constructor steps, step 15.1\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        let referrer = init.referrer == null ? input.referrer : init.referrer;\n        if (referrer === \"\") {\n            // §5.4, Request constructor steps, step 15.2\n            referrer = \"no-referrer\";\n        } else if (referrer) {\n            // §5.4, Request constructor steps, step 15.3.1, 15.3.2\n            const parsedReferrer = new URL(referrer);\n            // §5.4, Request constructor steps, step 15.3.3, 15.3.4\n            referrer = /^about:(\\/\\/)?client$/.test(parsedReferrer) ? \"client\" : parsedReferrer;\n        } else {\n            referrer = undefined;\n        }\n        this[INTERNALS] = {\n            method,\n            redirect: init.redirect || input.redirect || \"follow\",\n            headers,\n            parsedURL,\n            signal,\n            referrer\n        };\n        // Node-fetch-only options\n        this.follow = init.follow === undefined ? input.follow === undefined ? 20 : input.follow : init.follow;\n        this.compress = init.compress === undefined ? input.compress === undefined ? true : input.compress : init.compress;\n        this.counter = init.counter || input.counter || 0;\n        this.agent = init.agent || input.agent;\n        this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;\n        this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;\n        // §5.4, Request constructor steps, step 16.\n        // Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy\n        this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || \"\";\n    }\n    /** @returns {string} */ get method() {\n        return this[INTERNALS].method;\n    }\n    /** @returns {string} */ get url() {\n        return node_url.format(this[INTERNALS].parsedURL);\n    }\n    /** @returns {Headers} */ get headers() {\n        return this[INTERNALS].headers;\n    }\n    get redirect() {\n        return this[INTERNALS].redirect;\n    }\n    /** @returns {AbortSignal} */ get signal() {\n        return this[INTERNALS].signal;\n    }\n    // https://fetch.spec.whatwg.org/#dom-request-referrer\n    get referrer() {\n        if (this[INTERNALS].referrer === \"no-referrer\") {\n            return \"\";\n        }\n        if (this[INTERNALS].referrer === \"client\") {\n            return \"about:client\";\n        }\n        if (this[INTERNALS].referrer) {\n            return this[INTERNALS].referrer.toString();\n        }\n        return undefined;\n    }\n    get referrerPolicy() {\n        return this[INTERNALS].referrerPolicy;\n    }\n    set referrerPolicy(referrerPolicy) {\n        this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);\n    }\n    /**\n\t * Clone this request\n\t *\n\t * @return  Request\n\t */ clone() {\n        return new Request(this);\n    }\n    get [Symbol.toStringTag]() {\n        return \"Request\";\n    }\n}\nObject.defineProperties(Request.prototype, {\n    method: {\n        enumerable: true\n    },\n    url: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    redirect: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    },\n    signal: {\n        enumerable: true\n    },\n    referrer: {\n        enumerable: true\n    },\n    referrerPolicy: {\n        enumerable: true\n    }\n});\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param {Request} request - A Request instance\n * @return The options object to be passed to http.request\n */ const getNodeRequestOptions = (request)=>{\n    const { parsedURL } = request[INTERNALS];\n    const headers = new Headers(request[INTERNALS].headers);\n    // Fetch step 1.3\n    if (!headers.has(\"Accept\")) {\n        headers.set(\"Accept\", \"*/*\");\n    }\n    // HTTP-network-or-cache fetch steps 2.4-2.7\n    let contentLengthValue = null;\n    if (request.body === null && /^(post|put)$/i.test(request.method)) {\n        contentLengthValue = \"0\";\n    }\n    if (request.body !== null) {\n        const totalBytes = getTotalBytes(request);\n        // Set Content-Length if totalBytes is a number (that is not NaN)\n        if (typeof totalBytes === \"number\" && !Number.isNaN(totalBytes)) {\n            contentLengthValue = String(totalBytes);\n        }\n    }\n    if (contentLengthValue) {\n        headers.set(\"Content-Length\", contentLengthValue);\n    }\n    // 4.1. Main fetch, step 2.6\n    // > If request's referrer policy is the empty string, then set request's referrer policy to the\n    // > default referrer policy.\n    if (request.referrerPolicy === \"\") {\n        request.referrerPolicy = DEFAULT_REFERRER_POLICY;\n    }\n    // 4.1. Main fetch, step 2.7\n    // > If request's referrer is not \"no-referrer\", set request's referrer to the result of invoking\n    // > determine request's referrer.\n    if (request.referrer && request.referrer !== \"no-referrer\") {\n        request[INTERNALS].referrer = determineRequestsReferrer(request);\n    } else {\n        request[INTERNALS].referrer = \"no-referrer\";\n    }\n    // 4.5. HTTP-network-or-cache fetch, step 6.9\n    // > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized\n    // >  and isomorphic encoded, to httpRequest's header list.\n    if (request[INTERNALS].referrer instanceof URL) {\n        headers.set(\"Referer\", request.referrer);\n    }\n    // HTTP-network-or-cache fetch step 2.11\n    if (!headers.has(\"User-Agent\")) {\n        headers.set(\"User-Agent\", \"node-fetch\");\n    }\n    // HTTP-network-or-cache fetch step 2.15\n    if (request.compress && !headers.has(\"Accept-Encoding\")) {\n        headers.set(\"Accept-Encoding\", \"gzip, deflate, br\");\n    }\n    let { agent } = request;\n    if (typeof agent === \"function\") {\n        agent = agent(parsedURL);\n    }\n    if (!headers.has(\"Connection\") && !agent) {\n        headers.set(\"Connection\", \"close\");\n    }\n    // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n    const search = getSearch(parsedURL);\n    // Pass the full URL directly to request(), but overwrite the following\n    // options:\n    const options = {\n        // Overwrite search to retain trailing ? (issue #776)\n        path: parsedURL.pathname + search,\n        // The following options are not expressed in the URL\n        method: request.method,\n        headers: headers[Symbol.for(\"nodejs.util.inspect.custom\")](),\n        insecureHTTPParser: request.insecureHTTPParser,\n        agent\n    };\n    return {\n        /** @type {URL} */ parsedURL,\n        options\n    };\n};\n/**\n * AbortError interface for cancelled requests\n */ class AbortError extends FetchBaseError {\n    constructor(message, type = \"aborted\"){\n        super(message, type);\n    }\n}\n/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ if (!globalThis.DOMException) {\n    try {\n        const { MessageChannel } = __webpack_require__(/*! worker_threads */ \"worker_threads\"), port = new MessageChannel().port1, ab = new ArrayBuffer();\n        port.postMessage(ab, [\n            ab,\n            ab\n        ]);\n    } catch (err) {\n        err.constructor.name === \"DOMException\" && (globalThis.DOMException = err.constructor);\n    }\n}\nvar nodeDomexception = globalThis.DOMException;\n/**\n * Index.js\n *\n * a request API compatible with window.fetch\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */ const supportedSchemas = new Set([\n    \"data:\",\n    \"http:\",\n    \"https:\"\n]);\n/**\n * Fetch function\n *\n * @param   {string | URL | import('./request').default} url - Absolute url or Request instance\n * @param   {*} [options_] - Fetch options\n * @return  {Promise<import('./response').default>}\n */ async function fetch(url, options_) {\n    return new Promise((resolve, reject)=>{\n        // Build request object\n        const request = new Request(url, options_);\n        const { parsedURL, options } = getNodeRequestOptions(request);\n        if (!supportedSchemas.has(parsedURL.protocol)) {\n            throw new TypeError(`node-fetch cannot load ${url}. URL scheme \"${parsedURL.protocol.replace(/:$/, \"\")}\" is not supported.`);\n        }\n        if (parsedURL.protocol === \"data:\") {\n            const data = dataUriToBuffer(request.url);\n            const response = new Response(data, {\n                headers: {\n                    \"Content-Type\": data.typeFull\n                }\n            });\n            resolve(response);\n            return;\n        }\n        // Wrap http.request into fetch\n        const send = (parsedURL.protocol === \"https:\" ? https : http).request;\n        const { signal } = request;\n        let response = null;\n        const abort = ()=>{\n            const error = new AbortError(\"The operation was aborted.\");\n            reject(error);\n            if (request.body && request.body instanceof Stream.Readable) {\n                request.body.destroy(error);\n            }\n            if (!response || !response.body) {\n                return;\n            }\n            response.body.emit(\"error\", error);\n        };\n        if (signal && signal.aborted) {\n            abort();\n            return;\n        }\n        const abortAndFinalize = ()=>{\n            abort();\n            finalize();\n        };\n        // Send request\n        const request_ = send(parsedURL.toString(), options);\n        if (signal) {\n            signal.addEventListener(\"abort\", abortAndFinalize);\n        }\n        const finalize = ()=>{\n            request_.abort();\n            if (signal) {\n                signal.removeEventListener(\"abort\", abortAndFinalize);\n            }\n        };\n        request_.on(\"error\", (error)=>{\n            reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, \"system\", error));\n            finalize();\n        });\n        fixResponseChunkedTransferBadEnding(request_, (error)=>{\n            if (response && response.body) {\n                response.body.destroy(error);\n            }\n        });\n        /* c8 ignore next 18 */ if (process.version < \"v14\") {\n            // Before Node.js 14, pipeline() does not fully support async iterators and does not always\n            // properly handle when the socket close/end events are out of order.\n            request_.on(\"socket\", (s)=>{\n                let endedWithEventsCount;\n                s.prependListener(\"end\", ()=>{\n                    endedWithEventsCount = s._eventsCount;\n                });\n                s.prependListener(\"close\", (hadError)=>{\n                    // if end happened before close but the socket didn't emit an error, do it now\n                    if (response && endedWithEventsCount < s._eventsCount && !hadError) {\n                        const error = new Error(\"Premature close\");\n                        error.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                        response.body.emit(\"error\", error);\n                    }\n                });\n            });\n        }\n        request_.on(\"response\", (response_)=>{\n            request_.setTimeout(0);\n            const headers = fromRawHeaders(response_.rawHeaders);\n            // HTTP fetch step 5\n            if (isRedirect(response_.statusCode)) {\n                // HTTP fetch step 5.2\n                const location = headers.get(\"Location\");\n                // HTTP fetch step 5.3\n                let locationURL = null;\n                try {\n                    locationURL = location === null ? null : new URL(location, request.url);\n                } catch  {\n                    // error here can only be invalid URL in Location: header\n                    // do not throw when options.redirect == manual\n                    // let the user extract the errorneous redirect URL\n                    if (request.redirect !== \"manual\") {\n                        reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, \"invalid-redirect\"));\n                        finalize();\n                        return;\n                    }\n                }\n                // HTTP fetch step 5.5\n                switch(request.redirect){\n                    case \"error\":\n                        reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, \"no-redirect\"));\n                        finalize();\n                        return;\n                    case \"manual\":\n                        break;\n                    case \"follow\":\n                        {\n                            // HTTP-redirect fetch step 2\n                            if (locationURL === null) {\n                                break;\n                            }\n                            // HTTP-redirect fetch step 5\n                            if (request.counter >= request.follow) {\n                                reject(new FetchError(`maximum redirect reached at: ${request.url}`, \"max-redirect\"));\n                                finalize();\n                                return;\n                            }\n                            // HTTP-redirect fetch step 6 (counter increment)\n                            // Create a new Request object.\n                            const requestOptions = {\n                                headers: new Headers(request.headers),\n                                follow: request.follow,\n                                counter: request.counter + 1,\n                                agent: request.agent,\n                                compress: request.compress,\n                                method: request.method,\n                                body: clone(request),\n                                signal: request.signal,\n                                size: request.size,\n                                referrer: request.referrer,\n                                referrerPolicy: request.referrerPolicy\n                            };\n                            // when forwarding sensitive headers like \"Authorization\",\n                            // \"WWW-Authenticate\", and \"Cookie\" to untrusted targets,\n                            // headers will be ignored when following a redirect to a domain\n                            // that is not a subdomain match or exact match of the initial domain.\n                            // For example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\"\n                            // will forward the sensitive headers, but a redirect to \"bar.com\" will not.\n                            // headers will also be ignored when following a redirect to a domain using\n                            // a different protocol. For example, a redirect from \"https://foo.com\" to \"http://foo.com\"\n                            // will not forward the sensitive headers\n                            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n                                for (const name of [\n                                    \"authorization\",\n                                    \"www-authenticate\",\n                                    \"cookie\",\n                                    \"cookie2\"\n                                ]){\n                                    requestOptions.headers.delete(name);\n                                }\n                            }\n                            // HTTP-redirect fetch step 9\n                            if (response_.statusCode !== 303 && request.body && options_.body instanceof Stream.Readable) {\n                                reject(new FetchError(\"Cannot follow redirect with body being a readable stream\", \"unsupported-redirect\"));\n                                finalize();\n                                return;\n                            }\n                            // HTTP-redirect fetch step 11\n                            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === \"POST\") {\n                                requestOptions.method = \"GET\";\n                                requestOptions.body = undefined;\n                                requestOptions.headers.delete(\"content-length\");\n                            }\n                            // HTTP-redirect fetch step 14\n                            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);\n                            if (responseReferrerPolicy) {\n                                requestOptions.referrerPolicy = responseReferrerPolicy;\n                            }\n                            // HTTP-redirect fetch step 15\n                            resolve(fetch(new Request(locationURL, requestOptions)));\n                            finalize();\n                            return;\n                        }\n                    default:\n                        return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));\n                }\n            }\n            // Prepare response\n            if (signal) {\n                response_.once(\"end\", ()=>{\n                    signal.removeEventListener(\"abort\", abortAndFinalize);\n                });\n            }\n            let body = Stream.pipeline(response_, new Stream.PassThrough(), (error)=>{\n                if (error) {\n                    reject(error);\n                }\n            });\n            // see https://github.com/nodejs/node/pull/29376\n            /* c8 ignore next 3 */ if (process.version < \"v12.10\") {\n                response_.on(\"aborted\", abortAndFinalize);\n            }\n            const responseOptions = {\n                url: request.url,\n                status: response_.statusCode,\n                statusText: response_.statusMessage,\n                headers,\n                size: request.size,\n                counter: request.counter,\n                highWaterMark: request.highWaterMark\n            };\n            // HTTP-network fetch step 12.1.1.3\n            const codings = headers.get(\"Content-Encoding\");\n            // HTTP-network fetch step 12.1.1.4: handle content codings\n            // in following scenarios we ignore compression support\n            // 1. compression support is disabled\n            // 2. HEAD request\n            // 3. no Content-Encoding header\n            // 4. no content response (204)\n            // 5. content not modified response (304)\n            if (!request.compress || request.method === \"HEAD\" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {\n                response = new Response(body, responseOptions);\n                resolve(response);\n                return;\n            }\n            // For Node v6+\n            // Be less strict when decoding compressed responses, since sometimes\n            // servers send slightly invalid responses that are still accepted\n            // by common browsers.\n            // Always using Z_SYNC_FLUSH is what cURL does.\n            const zlibOptions = {\n                flush: zlib.Z_SYNC_FLUSH,\n                finishFlush: zlib.Z_SYNC_FLUSH\n            };\n            // For gzip\n            if (codings === \"gzip\" || codings === \"x-gzip\") {\n                body = Stream.pipeline(body, zlib.createGunzip(zlibOptions), (error)=>{\n                    if (error) {\n                        reject(error);\n                    }\n                });\n                response = new Response(body, responseOptions);\n                resolve(response);\n                return;\n            }\n            // For deflate\n            if (codings === \"deflate\" || codings === \"x-deflate\") {\n                // Handle the infamous raw deflate response from old servers\n                // a hack for old IIS and Apache servers\n                const raw = Stream.pipeline(response_, new Stream.PassThrough(), (error)=>{\n                    if (error) {\n                        reject(error);\n                    }\n                });\n                raw.once(\"data\", (chunk)=>{\n                    // See http://stackoverflow.com/questions/37519828\n                    if ((chunk[0] & 0x0F) === 0x08) {\n                        body = Stream.pipeline(body, zlib.createInflate(), (error)=>{\n                            if (error) {\n                                reject(error);\n                            }\n                        });\n                    } else {\n                        body = Stream.pipeline(body, zlib.createInflateRaw(), (error)=>{\n                            if (error) {\n                                reject(error);\n                            }\n                        });\n                    }\n                    response = new Response(body, responseOptions);\n                    resolve(response);\n                });\n                raw.once(\"end\", ()=>{\n                    // Some old IIS servers return zero-length OK deflate responses, so\n                    // 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903\n                    if (!response) {\n                        response = new Response(body, responseOptions);\n                        resolve(response);\n                    }\n                });\n                return;\n            }\n            // For br\n            if (codings === \"br\") {\n                body = Stream.pipeline(body, zlib.createBrotliDecompress(), (error)=>{\n                    if (error) {\n                        reject(error);\n                    }\n                });\n                response = new Response(body, responseOptions);\n                resolve(response);\n                return;\n            }\n            // Otherwise, use response as-is\n            response = new Response(body, responseOptions);\n            resolve(response);\n        });\n        // eslint-disable-next-line promise/prefer-await-to-then\n        writeToStream(request_, request).catch(reject);\n    });\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n    const LAST_CHUNK = node_buffer.Buffer.from(\"0\\r\\n\\r\\n\");\n    let isChunkedTransfer = false;\n    let properLastChunkReceived = false;\n    let previousChunk;\n    request.on(\"response\", (response)=>{\n        const { headers } = response;\n        isChunkedTransfer = headers[\"transfer-encoding\"] === \"chunked\" && !headers[\"content-length\"];\n    });\n    request.on(\"socket\", (socket)=>{\n        const onSocketClose = ()=>{\n            if (isChunkedTransfer && !properLastChunkReceived) {\n                const error = new Error(\"Premature close\");\n                error.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                errorCallback(error);\n            }\n        };\n        const onData = (buf)=>{\n            properLastChunkReceived = node_buffer.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;\n            // Sometimes final 0-length chunk and end of message code are in separate packets\n            if (!properLastChunkReceived && previousChunk) {\n                properLastChunkReceived = node_buffer.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && node_buffer.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;\n            }\n            previousChunk = buf;\n        };\n        socket.prependListener(\"close\", onSocketClose);\n        socket.on(\"data\", onData);\n        request.on(\"close\", ()=>{\n            socket.removeListener(\"close\", onSocketClose);\n            socket.removeListener(\"data\", onData);\n        });\n    });\n}\n/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */ /**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */ /**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */ const privateData = new WeakMap();\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */ const wrappers = new WeakMap();\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */ function pd(event) {\n    const retv = privateData.get(event);\n    console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n    return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */ function setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n            console.error(\"Unable to preventDefault inside passive event listener invocation.\", data.passiveListener);\n        }\n        return;\n    }\n    if (!data.event.cancelable) {\n        return;\n    }\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */ /**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */ function Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now()\n    });\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", {\n        value: false,\n        enumerable: true\n    });\n    // Define accessors\n    const keys = Object.keys(event);\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */ get type () {\n        return pd(this).event.type;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */ get target () {\n        return pd(this).eventTarget;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */ get currentTarget () {\n        return pd(this).currentTarget;\n    },\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */ composedPath () {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return [];\n        }\n        return [\n            currentTarget\n        ];\n    },\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */ get NONE () {\n        return 0;\n    },\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */ get CAPTURING_PHASE () {\n        return 1;\n    },\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */ get AT_TARGET () {\n        return 2;\n    },\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */ get BUBBLING_PHASE () {\n        return 3;\n    },\n    /**\n     * The target of this event.\n     * @type {number}\n     */ get eventPhase () {\n        return pd(this).eventPhase;\n    },\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */ stopPropagation () {\n        const data = pd(this);\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */ stopImmediatePropagation () {\n        const data = pd(this);\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */ get bubbles () {\n        return Boolean(pd(this).event.bubbles);\n    },\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */ get cancelable () {\n        return Boolean(pd(this).event.cancelable);\n    },\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */ preventDefault () {\n        setCancelFlag(pd(this));\n    },\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */ get defaultPrevented () {\n        return pd(this).canceled;\n    },\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */ get composed () {\n        return Boolean(pd(this).event.composed);\n    },\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */ get timeStamp () {\n        return pd(this).timeStamp;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */ get srcElement () {\n        return pd(this).eventTarget;\n    },\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */ get cancelBubble () {\n        return pd(this).stopped;\n    },\n    set cancelBubble (value){\n        if (!value) {\n            return;\n        }\n        const data = pd(this);\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */ get returnValue () {\n        return !pd(this).canceled;\n    },\n    set returnValue (value){\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */ initEvent () {\n    // Do nothing.\n    }\n};\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true\n});\n// Ensure `event instanceof window.Event` is `true`.\nif (false) {}\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */ function defineRedirectDescriptor(key) {\n    return {\n        get () {\n            return pd(this).event[key];\n        },\n        set (value1) {\n            pd(this).event[key] = value1;\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */ function defineCallDescriptor(key) {\n    return {\n        value () {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments);\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */ function defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent;\n    }\n    /** CustomEvent */ function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: {\n            value: CustomEvent,\n            configurable: true,\n            writable: true\n        }\n    });\n    // Define accessors.\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));\n        }\n    }\n    return CustomEvent;\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */ function getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event;\n    }\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper;\n}\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */ function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event);\n}\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */ function isStopped(event) {\n    return pd(event).immediateStopped;\n}\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */ function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */ function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */ function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */ /**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */ const listenersMap = new WeakMap();\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */ function isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n    ;\n}\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */ function getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n    }\n    return listeners;\n}\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */ function defineEventAttributeDescriptor(eventName) {\n    return {\n        get () {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while(node != null){\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener;\n                }\n                node = node.next;\n            }\n            return null;\n        },\n        set (listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while(node != null){\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n                node = node.next;\n            }\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */ function defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));\n}\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */ function defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */ function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true\n        }\n    });\n    for(let i = 0; i < eventNames.length; ++i){\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n    return CustomEventTarget;\n}\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */ function EventTarget() {\n    /*eslint-disable consistent-return */ if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return;\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0]);\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for(let i = 0; i < arguments.length; ++i){\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types);\n    }\n    throw new TypeError(\"Cannot call a class as a function\");\n/*eslint-enable consistent-return */ }\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */ addEventListener (eventName, listener, options) {\n        if (listener == null) {\n            return;\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\");\n        }\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null\n        };\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return;\n        }\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while(node != null){\n            if (node.listener === listener && node.listenerType === listenerType) {\n                // Should ignore duplication.\n                return;\n            }\n            prev = node;\n            node = node.next;\n        }\n        // Add it.\n        prev.next = newNode;\n    },\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */ removeEventListener (eventName, listener, options) {\n        if (listener == null) {\n            return;\n        }\n        const listeners = getListeners(this);\n        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        let prev = null;\n        let node = listeners.get(eventName);\n        while(node != null){\n            if (node.listener === listener && node.listenerType === listenerType) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return;\n            }\n            prev = node;\n            node = node.next;\n        }\n    },\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */ dispatchEvent (event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.');\n        }\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true;\n        }\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while(node != null){\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n            // Call this listener\n            setPassiveListener(wrappedEvent, node.passive ? node.listener : null);\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n                        console.error(err);\n                    }\n                }\n            } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n                node.listener.handleEvent(wrappedEvent);\n            }\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break;\n            }\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n        return !wrappedEvent.defaultPrevented;\n    }\n};\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true\n});\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (false) {}\n/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * See LICENSE file in root directory for full license.\n */ /**\n * The signal class.\n * @see https://dom.spec.whatwg.org/#abortsignal\n */ class AbortSignal extends EventTarget {\n    /**\n     * AbortSignal cannot be constructed directly.\n     */ constructor(){\n        super();\n        throw new TypeError(\"AbortSignal cannot be constructed directly\");\n    }\n    /**\n     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.\n     */ get aborted() {\n        const aborted = abortedFlags.get(this);\n        if (typeof aborted !== \"boolean\") {\n            throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? \"null\" : typeof this}`);\n        }\n        return aborted;\n    }\n}\ndefineEventAttribute(AbortSignal.prototype, \"abort\");\n/**\n * Create an AbortSignal object.\n */ function createAbortSignal() {\n    const signal = Object.create(AbortSignal.prototype);\n    EventTarget.call(signal);\n    abortedFlags.set(signal, false);\n    return signal;\n}\n/**\n * Abort a given signal.\n */ function abortSignal(signal) {\n    if (abortedFlags.get(signal) !== false) {\n        return;\n    }\n    abortedFlags.set(signal, true);\n    signal.dispatchEvent({\n        type: \"abort\"\n    });\n}\n/**\n * Aborted flag for each instances.\n */ const abortedFlags = new WeakMap();\n// Properties should be enumerable.\nObject.defineProperties(AbortSignal.prototype, {\n    aborted: {\n        enumerable: true\n    }\n});\n// `toString()` should return `\"[object AbortSignal]\"`\nif (typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\") {\n    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \"AbortSignal\"\n    });\n}\n/**\n * The AbortController.\n * @see https://dom.spec.whatwg.org/#abortcontroller\n */ class AbortController$1 {\n    /**\n     * Initialize this controller.\n     */ constructor(){\n        signals.set(this, createAbortSignal());\n    }\n    /**\n     * Returns the `AbortSignal` object associated with this object.\n     */ get signal() {\n        return getSignal(this);\n    }\n    /**\n     * Abort and signal to any observers that the associated activity is to be aborted.\n     */ abort() {\n        abortSignal(getSignal(this));\n    }\n}\n/**\n * Associated signals.\n */ const signals = new WeakMap();\n/**\n * Get the associated signal of a given controller.\n */ function getSignal(controller) {\n    const signal = signals.get(controller);\n    if (signal == null) {\n        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? \"null\" : typeof controller}`);\n    }\n    return signal;\n}\n// Properties should be enumerable.\nObject.defineProperties(AbortController$1.prototype, {\n    signal: {\n        enumerable: true\n    },\n    abort: {\n        enumerable: true\n    }\n});\nif (typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\") {\n    Object.defineProperty(AbortController$1.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \"AbortController\"\n    });\n}\nexports.AbortController = AbortController$1;\nexports.AbortError = AbortError;\nexports.FetchError = FetchError;\nexports.File = File$1;\nexports.FormData = FormData;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports._Blob = _Blob$1;\nexports.fetch = fetch;\nexports.isRedirect = isRedirect;\nexports.nodeDomexception = nodeDomexception;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9zaGFyZWQvbm9kZS1mZXRjaC1uYXRpdmUuOGFmZDNmZWEuY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDckIsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDdEIsTUFBTUUsT0FBT0YsbUJBQU9BLENBQUM7QUFDckIsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUksY0FBY0osbUJBQU9BLENBQUM7QUFDNUIsTUFBTUssWUFBWUwsbUJBQU9BLENBQUM7QUFDMUIsTUFBTU0sV0FBV04sbUJBQU9BLENBQUM7QUFDekIsTUFBTU8sV0FBV1AsbUJBQU9BLENBQUM7QUFDekJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVI7Ozs7OztDQU1DLEdBQ0QsU0FBU1EsZ0JBQWdCQyxHQUFHO0lBQ3hCLElBQUksQ0FBQyxVQUFVQyxJQUFJLENBQUNELE1BQU07UUFDdEIsTUFBTSxJQUFJRSxVQUFVO0lBQ3hCO0lBQ0EsaUJBQWlCO0lBQ2pCRixNQUFNQSxJQUFJRyxPQUFPLENBQUMsVUFBVTtJQUM1QiwrREFBK0Q7SUFDL0QsTUFBTUMsYUFBYUosSUFBSUssT0FBTyxDQUFDO0lBQy9CLElBQUlELGVBQWUsQ0FBQyxLQUFLQSxjQUFjLEdBQUc7UUFDdEMsTUFBTSxJQUFJRixVQUFVO0lBQ3hCO0lBQ0EsbURBQW1EO0lBQ25ELE1BQU1JLE9BQU9OLElBQUlPLFNBQVMsQ0FBQyxHQUFHSCxZQUFZSSxLQUFLLENBQUM7SUFDaEQsSUFBSUMsVUFBVTtJQUNkLElBQUlDLFNBQVM7SUFDYixNQUFNQyxPQUFPTCxJQUFJLENBQUMsRUFBRSxJQUFJO0lBQ3hCLElBQUlNLFdBQVdEO0lBQ2YsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlQLEtBQUtRLE1BQU0sRUFBRUQsSUFBSztRQUNsQyxJQUFJUCxJQUFJLENBQUNPLEVBQUUs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azovL2Zpbml4Ly4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gtbmF0aXZlL2Rpc3Qvc2hhcmVkL25vZGUtZmV0Y2gtbmF0aXZlLjhhZmQzZmVhLmNqcz9lN2I4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ25vZGU6aHR0cCcpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdub2RlOmh0dHBzJyk7XG5jb25zdCB6bGliID0gcmVxdWlyZSgnbm9kZTp6bGliJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpO1xuY29uc3Qgbm9kZV9idWZmZXIgPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpO1xuY29uc3Qgbm9kZV91dGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJyk7XG5jb25zdCBub2RlX3VybCA9IHJlcXVpcmUoJ25vZGU6dXJsJyk7XG5jb25zdCBub2RlX25ldCA9IHJlcXVpcmUoJ25vZGU6bmV0Jyk7XG5yZXF1aXJlKCdub2RlOmZzJyk7XG5yZXF1aXJlKCdub2RlOnBhdGgnKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYEJ1ZmZlcmAgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBVUkkgYHVyaWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaSBEYXRhIFVSSSB0byB0dXJuIGludG8gYSBCdWZmZXIgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEJ1ZmZlciBpbnN0YW5jZSBmcm9tIERhdGEgVVJJXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkYXRhVXJpVG9CdWZmZXIodXJpKSB7XG4gICAgaWYgKCEvXmRhdGE6L2kudGVzdCh1cmkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2B1cmlgIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIERhdGEgVVJJIChtdXN0IGJlZ2luIHdpdGggXCJkYXRhOlwiKScpO1xuICAgIH1cbiAgICAvLyBzdHJpcCBuZXdsaW5lc1xuICAgIHVyaSA9IHVyaS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKTtcbiAgICAvLyBzcGxpdCB0aGUgVVJJIHVwIGludG8gdGhlIFwibWV0YWRhdGFcIiBhbmQgdGhlIFwiZGF0YVwiIHBvcnRpb25zXG4gICAgY29uc3QgZmlyc3RDb21tYSA9IHVyaS5pbmRleE9mKCcsJyk7XG4gICAgaWYgKGZpcnN0Q29tbWEgPT09IC0xIHx8IGZpcnN0Q29tbWEgPD0gNCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYWxmb3JtZWQgZGF0YTogVVJJJyk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSB0aGUgXCJkYXRhOlwiIHNjaGVtZSBhbmQgcGFyc2UgdGhlIG1ldGFkYXRhXG4gICAgY29uc3QgbWV0YSA9IHVyaS5zdWJzdHJpbmcoNSwgZmlyc3RDb21tYSkuc3BsaXQoJzsnKTtcbiAgICBsZXQgY2hhcnNldCA9ICcnO1xuICAgIGxldCBiYXNlNjQgPSBmYWxzZTtcbiAgICBjb25zdCB0eXBlID0gbWV0YVswXSB8fCAndGV4dC9wbGFpbic7XG4gICAgbGV0IHR5cGVGdWxsID0gdHlwZTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1ldGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1ldGFbaV0gPT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICBiYXNlNjQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHlwZUZ1bGwgKz0gYDske21ldGFbaV19YDtcbiAgICAgICAgICAgIGlmIChtZXRhW2ldLmluZGV4T2YoJ2NoYXJzZXQ9JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjaGFyc2V0ID0gbWV0YVtpXS5zdWJzdHJpbmcoOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZGVmYXVsdHMgdG8gVVMtQVNDSUkgb25seSBpZiB0eXBlIGlzIG5vdCBwcm92aWRlZFxuICAgIGlmICghbWV0YVswXSAmJiAhY2hhcnNldC5sZW5ndGgpIHtcbiAgICAgICAgdHlwZUZ1bGwgKz0gJztjaGFyc2V0PVVTLUFTQ0lJJztcbiAgICAgICAgY2hhcnNldCA9ICdVUy1BU0NJSSc7XG4gICAgfVxuICAgIC8vIGdldCB0aGUgZW5jb2RlZCBkYXRhIHBvcnRpb24gYW5kIGRlY29kZSBVUkktZW5jb2RlZCBjaGFyc1xuICAgIGNvbnN0IGVuY29kaW5nID0gYmFzZTY0ID8gJ2Jhc2U2NCcgOiAnYXNjaWknO1xuICAgIGNvbnN0IGRhdGEgPSB1bmVzY2FwZSh1cmkuc3Vic3RyaW5nKGZpcnN0Q29tbWEgKyAxKSk7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jb2RpbmcpO1xuICAgIC8vIHNldCBgLnR5cGVgIGFuZCBgLnR5cGVGdWxsYCBwcm9wZXJ0aWVzIHRvIE1JTUUgdHlwZVxuICAgIGJ1ZmZlci50eXBlID0gdHlwZTtcbiAgICBidWZmZXIudHlwZUZ1bGwgPSB0eXBlRnVsbDtcbiAgICAvLyBzZXQgdGhlIGAuY2hhcnNldGAgcHJvcGVydHlcbiAgICBidWZmZXIuY2hhcnNldCA9IGNoYXJzZXQ7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBwb255ZmlsbF9lczIwMTggPSB7ZXhwb3J0czoge319O1xuXG4vKipcbiAqIHdlYi1zdHJlYW1zLXBvbHlmaWxsIHYzLjIuMVxuICovXG5cbnZhciBoYXNSZXF1aXJlZFBvbnlmaWxsX2VzMjAxODtcblxuZnVuY3Rpb24gcmVxdWlyZVBvbnlmaWxsX2VzMjAxOCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFBvbnlmaWxsX2VzMjAxOCkgcmV0dXJuIHBvbnlmaWxsX2VzMjAxOC5leHBvcnRzO1xuXHRoYXNSZXF1aXJlZFBvbnlmaWxsX2VzMjAxOCA9IDE7XG5cdChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0XHQgICAgZmFjdG9yeShleHBvcnRzKSA7XG5cdFx0fShjb21tb25qc0dsb2JhbCwgKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0ICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5zeW1ib2xcIiAvPlxuXHRcdCAgICBjb25zdCBTeW1ib2xQb2x5ZmlsbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcgP1xuXHRcdCAgICAgICAgU3ltYm9sIDpcblx0XHQgICAgICAgIGRlc2NyaXB0aW9uID0+IGBTeW1ib2woJHtkZXNjcmlwdGlvbn0pYDtcblxuXHRcdCAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuXHRcdCAgICBmdW5jdGlvbiBub29wKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBnZXRHbG9iYWxzKCkge1xuXHRcdCAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBzZWxmO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gd2luZG93O1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbW1vbmpzR2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBjb21tb25qc0dsb2JhbDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgY29uc3QgZ2xvYmFscyA9IGdldEdsb2JhbHMoKTtcblxuXHRcdCAgICBmdW5jdGlvbiB0eXBlSXNPYmplY3QoeCkge1xuXHRcdCAgICAgICAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCkgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG5cdFx0ICAgIH1cblx0XHQgICAgY29uc3QgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uID0gbm9vcDtcblxuXHRcdCAgICBjb25zdCBvcmlnaW5hbFByb21pc2UgPSBQcm9taXNlO1xuXHRcdCAgICBjb25zdCBvcmlnaW5hbFByb21pc2VUaGVuID0gUHJvbWlzZS5wcm90b3R5cGUudGhlbjtcblx0XHQgICAgY29uc3Qgb3JpZ2luYWxQcm9taXNlUmVzb2x2ZSA9IFByb21pc2UucmVzb2x2ZS5iaW5kKG9yaWdpbmFsUHJvbWlzZSk7XG5cdFx0ICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZVJlamVjdCA9IFByb21pc2UucmVqZWN0LmJpbmQob3JpZ2luYWxQcm9taXNlKTtcblx0XHQgICAgZnVuY3Rpb24gbmV3UHJvbWlzZShleGVjdXRvcikge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBvcmlnaW5hbFByb21pc2UoZXhlY3V0b3IpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIHByb21pc2VSZXNvbHZlZFdpdGgodmFsdWUpIHtcblx0XHQgICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2VSZXNvbHZlKHZhbHVlKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYXNvbikge1xuXHRcdCAgICAgICAgcmV0dXJuIG9yaWdpbmFsUHJvbWlzZVJlamVjdChyZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuXHRcdCAgICAgICAgLy8gVGhlcmUgZG9lc24ndCBhcHBlYXIgdG8gYmUgYW55IHdheSB0byBjb3JyZWN0bHkgZW11bGF0ZSB0aGUgYmVoYXZpb3VyIGZyb20gSmF2YVNjcmlwdCwgc28gdGhpcyBpcyBqdXN0IGFuXG5cdFx0ICAgICAgICAvLyBhcHByb3hpbWF0aW9uLlxuXHRcdCAgICAgICAgcmV0dXJuIG9yaWdpbmFsUHJvbWlzZVRoZW4uY2FsbChwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcblx0XHQgICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpLCB1bmRlZmluZWQsIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gdXBvbkZ1bGZpbGxtZW50KHByb21pc2UsIG9uRnVsZmlsbGVkKSB7XG5cdFx0ICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlLCBvbkZ1bGZpbGxlZCk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gdXBvblJlamVjdGlvbihwcm9taXNlLCBvblJlamVjdGVkKSB7XG5cdFx0ICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlLCB1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVByb21pc2VXaXRoKHByb21pc2UsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuXHRcdCAgICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocHJvbWlzZSkge1xuXHRcdCAgICAgICAgUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIHVuZGVmaW5lZCwgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uKTtcblx0XHQgICAgfVxuXHRcdCAgICBjb25zdCBxdWV1ZU1pY3JvdGFzayA9ICgoKSA9PiB7XG5cdFx0ICAgICAgICBjb25zdCBnbG9iYWxRdWV1ZU1pY3JvdGFzayA9IGdsb2JhbHMgJiYgZ2xvYmFscy5xdWV1ZU1pY3JvdGFzaztcblx0XHQgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsUXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZ2xvYmFsUXVldWVNaWNyb3Rhc2s7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCByZXNvbHZlZFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICByZXR1cm4gKGZuKSA9PiBQZXJmb3JtUHJvbWlzZVRoZW4ocmVzb2x2ZWRQcm9taXNlLCBmbik7XG5cdFx0ICAgIH0pKCk7XG5cdFx0ICAgIGZ1bmN0aW9uIHJlZmxlY3RDYWxsKEYsIFYsIGFyZ3MpIHtcblx0XHQgICAgICAgIGlmICh0eXBlb2YgRiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoRiwgViwgYXJncyk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gcHJvbWlzZUNhbGwoRiwgViwgYXJncykge1xuXHRcdCAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aChyZWZsZWN0Q2FsbChGLCBWLCBhcmdzKSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjYXRjaCAodmFsdWUpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh2YWx1ZSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvLyBPcmlnaW5hbCBmcm9tIENocm9taXVtXG5cdFx0ICAgIC8vIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMvKy8wYWVlNDQzNGE0ZGJhNDJhNDJhYmFlYTliZmJjMGNkMTk2YTYzYmMxL3RoaXJkX3BhcnR5L2JsaW5rL3JlbmRlcmVyL2NvcmUvc3RyZWFtcy9TaW1wbGVRdWV1ZS5qc1xuXHRcdCAgICBjb25zdCBRVUVVRV9NQVhfQVJSQVlfU0laRSA9IDE2Mzg0O1xuXHRcdCAgICAvKipcblx0XHQgICAgICogU2ltcGxlIHF1ZXVlIHN0cnVjdHVyZS5cblx0XHQgICAgICpcblx0XHQgICAgICogQXZvaWRzIHNjYWxhYmlsaXR5IGlzc3VlcyB3aXRoIHVzaW5nIGEgcGFja2VkIGFycmF5IGRpcmVjdGx5IGJ5IHVzaW5nXG5cdFx0ICAgICAqIG11bHRpcGxlIGFycmF5cyBpbiBhIGxpbmtlZCBsaXN0IGFuZCBrZWVwaW5nIHRoZSBhcnJheSBzaXplIGJvdW5kZWQuXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBTaW1wbGVRdWV1ZSB7XG5cdFx0ICAgICAgICBjb25zdHJ1Y3RvcigpIHtcblx0XHQgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSAwO1xuXHRcdCAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwO1xuXHRcdCAgICAgICAgICAgIC8vIF9mcm9udCBhbmQgX2JhY2sgYXJlIGFsd2F5cyBkZWZpbmVkLlxuXHRcdCAgICAgICAgICAgIHRoaXMuX2Zyb250ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfZWxlbWVudHM6IFtdLFxuXHRcdCAgICAgICAgICAgICAgICBfbmV4dDogdW5kZWZpbmVkXG5cdFx0ICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICB0aGlzLl9iYWNrID0gdGhpcy5fZnJvbnQ7XG5cdFx0ICAgICAgICAgICAgLy8gVGhlIGN1cnNvciBpcyB1c2VkIHRvIGF2b2lkIGNhbGxpbmcgQXJyYXkuc2hpZnQoKS5cblx0XHQgICAgICAgICAgICAvLyBJdCBjb250YWlucyB0aGUgaW5kZXggb2YgdGhlIGZyb250IGVsZW1lbnQgb2YgdGhlIGFycmF5IGluc2lkZSB0aGVcblx0XHQgICAgICAgICAgICAvLyBmcm9udC1tb3N0IG5vZGUuIEl0IGlzIGFsd2F5cyBpbiB0aGUgcmFuZ2UgWzAsIFFVRVVFX01BWF9BUlJBWV9TSVpFKS5cblx0XHQgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSAwO1xuXHRcdCAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgb25seSBvbmUgbm9kZSwgc2l6ZSA9PT0gZWxlbWVudHMubGVuZ3RoIC0gY3Vyc29yLlxuXHRcdCAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZ2V0IGxlbmd0aCgpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIEZvciBleGNlcHRpb24gc2FmZXR5LCB0aGlzIG1ldGhvZCBpcyBzdHJ1Y3R1cmVkIGluIG9yZGVyOlxuXHRcdCAgICAgICAgLy8gMS4gUmVhZCBzdGF0ZVxuXHRcdCAgICAgICAgLy8gMi4gQ2FsY3VsYXRlIHJlcXVpcmVkIHN0YXRlIG11dGF0aW9uc1xuXHRcdCAgICAgICAgLy8gMy4gUGVyZm9ybSBzdGF0ZSBtdXRhdGlvbnNcblx0XHQgICAgICAgIHB1c2goZWxlbWVudCkge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IG9sZEJhY2sgPSB0aGlzLl9iYWNrO1xuXHRcdCAgICAgICAgICAgIGxldCBuZXdCYWNrID0gb2xkQmFjaztcblx0XHQgICAgICAgICAgICBpZiAob2xkQmFjay5fZWxlbWVudHMubGVuZ3RoID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSAtIDEpIHtcblx0XHQgICAgICAgICAgICAgICAgbmV3QmFjayA9IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIF9lbGVtZW50czogW10sXG5cdFx0ICAgICAgICAgICAgICAgICAgICBfbmV4dDogdW5kZWZpbmVkXG5cdFx0ICAgICAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIC8vIHB1c2goKSBpcyB0aGUgbXV0YXRpb24gbW9zdCBsaWtlbHkgdG8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBpdFxuXHRcdCAgICAgICAgICAgIC8vIGdvZXMgZmlyc3QuXG5cdFx0ICAgICAgICAgICAgb2xkQmFjay5fZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0XHQgICAgICAgICAgICBpZiAobmV3QmFjayAhPT0gb2xkQmFjaykge1xuXHRcdCAgICAgICAgICAgICAgICB0aGlzLl9iYWNrID0gbmV3QmFjaztcblx0XHQgICAgICAgICAgICAgICAgb2xkQmFjay5fbmV4dCA9IG5ld0JhY2s7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICsrdGhpcy5fc2l6ZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIExpa2UgcHVzaCgpLCBzaGlmdCgpIGZvbGxvd3MgdGhlIHJlYWQgLT4gY2FsY3VsYXRlIC0+IG11dGF0ZSBwYXR0ZXJuIGZvclxuXHRcdCAgICAgICAgLy8gZXhjZXB0aW9uIHNhZmV0eS5cblx0XHQgICAgICAgIHNoaWZ0KCkgeyAvLyBtdXN0IG5vdCBiZSBjYWxsZWQgb24gYW4gZW1wdHkgcXVldWVcblx0XHQgICAgICAgICAgICBjb25zdCBvbGRGcm9udCA9IHRoaXMuX2Zyb250O1xuXHRcdCAgICAgICAgICAgIGxldCBuZXdGcm9udCA9IG9sZEZyb250O1xuXHRcdCAgICAgICAgICAgIGNvbnN0IG9sZEN1cnNvciA9IHRoaXMuX2N1cnNvcjtcblx0XHQgICAgICAgICAgICBsZXQgbmV3Q3Vyc29yID0gb2xkQ3Vyc29yICsgMTtcblx0XHQgICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IG9sZEZyb250Ll9lbGVtZW50cztcblx0XHQgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbb2xkQ3Vyc29yXTtcblx0XHQgICAgICAgICAgICBpZiAobmV3Q3Vyc29yID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSkge1xuXHRcdCAgICAgICAgICAgICAgICBuZXdGcm9udCA9IG9sZEZyb250Ll9uZXh0O1xuXHRcdCAgICAgICAgICAgICAgICBuZXdDdXJzb3IgPSAwO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAvLyBObyBtdXRhdGlvbnMgYmVmb3JlIHRoaXMgcG9pbnQuXG5cdFx0ICAgICAgICAgICAgLS10aGlzLl9zaXplO1xuXHRcdCAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG5ld0N1cnNvcjtcblx0XHQgICAgICAgICAgICBpZiAob2xkRnJvbnQgIT09IG5ld0Zyb250KSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRoaXMuX2Zyb250ID0gbmV3RnJvbnQ7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIC8vIFBlcm1pdCBzaGlmdGVkIGVsZW1lbnQgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG5cdFx0ICAgICAgICAgICAgZWxlbWVudHNbb2xkQ3Vyc29yXSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIFRoZSB0cmlja3kgdGhpbmcgYWJvdXQgZm9yRWFjaCgpIGlzIHRoYXQgaXQgY2FuIGJlIGNhbGxlZFxuXHRcdCAgICAgICAgLy8gcmUtZW50cmFudGx5LiBUaGUgcXVldWUgbWF5IGJlIG11dGF0ZWQgaW5zaWRlIHRoZSBjYWxsYmFjay4gSXQgaXMgZWFzeSB0b1xuXHRcdCAgICAgICAgLy8gc2VlIHRoYXQgcHVzaCgpIHdpdGhpbiB0aGUgY2FsbGJhY2sgaGFzIG5vIG5lZ2F0aXZlIGVmZmVjdHMgc2luY2UgdGhlIGVuZFxuXHRcdCAgICAgICAgLy8gb2YgdGhlIHF1ZXVlIGlzIGNoZWNrZWQgZm9yIG9uIGV2ZXJ5IGl0ZXJhdGlvbi4gSWYgc2hpZnQoKSBpcyBjYWxsZWRcblx0XHQgICAgICAgIC8vIHJlcGVhdGVkbHkgd2l0aGluIHRoZSBjYWxsYmFjayB0aGVuIHRoZSBuZXh0IGl0ZXJhdGlvbiBtYXkgcmV0dXJuIGFuXG5cdFx0ICAgICAgICAvLyBlbGVtZW50IHRoYXQgaGFzIGJlZW4gcmVtb3ZlZC4gSW4gdGhpcyBjYXNlIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuXHRcdCAgICAgICAgLy8gd2l0aCB1bmRlZmluZWQgdmFsdWVzIHVudGlsIHdlIGVpdGhlciBcImNhdGNoIHVwXCIgd2l0aCBlbGVtZW50cyB0aGF0IHN0aWxsXG5cdFx0ICAgICAgICAvLyBleGlzdCBvciByZWFjaCB0aGUgYmFjayBvZiB0aGUgcXVldWUuXG5cdFx0ICAgICAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XG5cdFx0ICAgICAgICAgICAgbGV0IGkgPSB0aGlzLl9jdXJzb3I7XG5cdFx0ICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9mcm9udDtcblx0XHQgICAgICAgICAgICBsZXQgZWxlbWVudHMgPSBub2RlLl9lbGVtZW50cztcblx0XHQgICAgICAgICAgICB3aGlsZSAoaSAhPT0gZWxlbWVudHMubGVuZ3RoIHx8IG5vZGUuX25leHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoaSA9PT0gZWxlbWVudHMubGVuZ3RoKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5fbmV4dDtcblx0XHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gbm9kZS5fZWxlbWVudHM7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpID0gMDtcblx0XHQgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50c1tpXSk7XG5cdFx0ICAgICAgICAgICAgICAgICsraTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBSZXR1cm4gdGhlIGVsZW1lbnQgdGhhdCB3b3VsZCBiZSByZXR1cm5lZCBpZiBzaGlmdCgpIHdhcyBjYWxsZWQgbm93LFxuXHRcdCAgICAgICAgLy8gd2l0aG91dCBtb2RpZnlpbmcgdGhlIHF1ZXVlLlxuXHRcdCAgICAgICAgcGVlaygpIHsgLy8gbXVzdCBub3QgYmUgY2FsbGVkIG9uIGFuIGVtcHR5IHF1ZXVlXG5cdFx0ICAgICAgICAgICAgY29uc3QgZnJvbnQgPSB0aGlzLl9mcm9udDtcblx0XHQgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLl9jdXJzb3I7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZyb250Ll9lbGVtZW50c1tjdXJzb3JdO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZShyZWFkZXIsIHN0cmVhbSkge1xuXHRcdCAgICAgICAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID0gc3RyZWFtO1xuXHRcdCAgICAgICAgc3RyZWFtLl9yZWFkZXIgPSByZWFkZXI7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHJlYWRlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQSBjbGllbnQgb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIGFuZCBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlXG5cdFx0ICAgIC8vIGNoZWNrLlxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwocmVhZGVyLCByZWFzb24pIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcblx0XHQgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIHJlYXNvbik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpIHtcblx0XHQgICAgICAgIGlmIChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCBuZXcgVHlwZUVycm9yKGBSZWFkZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHJlYWRlciwgbmV3IFR5cGVFcnJvcihgUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0uX3JlYWRlciA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9IHVuZGVmaW5lZDtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgcmVhZGVycy5cblx0XHQgICAgZnVuY3Rpb24gcmVhZGVyTG9ja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQ2Fubm90ICcgKyBuYW1lICsgJyBhIHN0cmVhbSB1c2luZyBhIHJlbGVhc2VkIHJlYWRlcicpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpIHtcblx0XHQgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdCAgICAgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHQgICAgICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZChyZWFkZXIsIHJlYXNvbikge1xuXHRcdCAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG5cdFx0ICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIHJlYXNvbik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZChyZWFkZXIpIHtcblx0XHQgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuXHRcdCAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCByZWFzb24pIHtcblx0XHQgICAgICAgIGlmIChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHJlYWRlci5fY2xvc2VkUHJvbWlzZSk7XG5cdFx0ICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG5cdFx0ICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQocmVhZGVyLCByZWFzb24pIHtcblx0XHQgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCByZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpIHtcblx0XHQgICAgICAgIGlmIChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGNvbnN0IEFib3J0U3RlcHMgPSBTeW1ib2xQb2x5ZmlsbCgnW1tBYm9ydFN0ZXBzXV0nKTtcblx0XHQgICAgY29uc3QgRXJyb3JTdGVwcyA9IFN5bWJvbFBvbHlmaWxsKCdbW0Vycm9yU3RlcHNdXScpO1xuXHRcdCAgICBjb25zdCBDYW5jZWxTdGVwcyA9IFN5bWJvbFBvbHlmaWxsKCdbW0NhbmNlbFN0ZXBzXV0nKTtcblx0XHQgICAgY29uc3QgUHVsbFN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbUHVsbFN0ZXBzXV0nKTtcblxuXHRcdCAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuY29yZVwiIC8+XG5cdFx0ICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc0Zpbml0ZSNQb2x5ZmlsbFxuXHRcdCAgICBjb25zdCBOdW1iZXJJc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAoeCkge1xuXHRcdCAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh4KTtcblx0XHQgICAgfTtcblxuXHRcdCAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuY29yZVwiIC8+XG5cdFx0ICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvdHJ1bmMjUG9seWZpbGxcblx0XHQgICAgY29uc3QgTWF0aFRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xuXHRcdCAgICAgICAgcmV0dXJuIHYgPCAwID8gTWF0aC5jZWlsKHYpIDogTWF0aC5mbG9vcih2KTtcblx0XHQgICAgfTtcblxuXHRcdCAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtZGljdGlvbmFyaWVzXG5cdFx0ICAgIGZ1bmN0aW9uIGlzRGljdGlvbmFyeSh4KSB7XG5cdFx0ICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGFzc2VydERpY3Rpb25hcnkob2JqLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgIWlzRGljdGlvbmFyeShvYmopKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1jYWxsYmFjay1mdW5jdGlvbnNcblx0XHQgICAgZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24oeCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBmdW5jdGlvbi5gKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtb2JqZWN0XG5cdFx0ICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcblx0XHQgICAgICAgIHJldHVybiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGFzc2VydE9iamVjdCh4LCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBpZiAoIWlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoeCwgcG9zaXRpb24sIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJHtwb3NpdGlvbn0gaXMgcmVxdWlyZWQgaW4gJyR7Y29udGV4dH0nLmApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkRmllbGQoeCwgZmllbGQsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2ZpZWxkfSBpcyByZXF1aXJlZCBpbiAnJHtjb250ZXh0fScuYCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLXVucmVzdHJpY3RlZC1kb3VibGVcblx0XHQgICAgZnVuY3Rpb24gY29udmVydFVucmVzdHJpY3RlZERvdWJsZSh2YWx1ZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY2Vuc29yTmVnYXRpdmVaZXJvKHgpIHtcblx0XHQgICAgICAgIHJldHVybiB4ID09PSAwID8gMCA6IHg7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gaW50ZWdlclBhcnQoeCkge1xuXHRcdCAgICAgICAgcmV0dXJuIGNlbnNvck5lZ2F0aXZlWmVybyhNYXRoVHJ1bmMoeCkpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC11bnNpZ25lZC1sb25nLWxvbmdcblx0XHQgICAgZnVuY3Rpb24gY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKHZhbHVlLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBjb25zdCBsb3dlckJvdW5kID0gMDtcblx0XHQgICAgICAgIGNvbnN0IHVwcGVyQm91bmQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblx0XHQgICAgICAgIGxldCB4ID0gTnVtYmVyKHZhbHVlKTtcblx0XHQgICAgICAgIHggPSBjZW5zb3JOZWdhdGl2ZVplcm8oeCk7XG5cdFx0ICAgICAgICBpZiAoIU51bWJlcklzRmluaXRlKHgpKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBmaW5pdGUgbnVtYmVyYCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICB4ID0gaW50ZWdlclBhcnQoeCk7XG5cdFx0ICAgICAgICBpZiAoeCA8IGxvd2VyQm91bmQgfHwgeCA+IHVwcGVyQm91bmQpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG91dHNpZGUgdGhlIGFjY2VwdGVkIHJhbmdlIG9mICR7bG93ZXJCb3VuZH0gdG8gJHt1cHBlckJvdW5kfSwgaW5jbHVzaXZlYCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIU51bWJlcklzRmluaXRlKHgpIHx8IHggPT09IDApIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gMDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIFRPRE8gVXNlIEJpZ0ludCBpZiBzdXBwb3J0ZWQ/XG5cdFx0ICAgICAgICAvLyBsZXQgeEJpZ0ludCA9IEJpZ0ludChpbnRlZ2VyUGFydCh4KSk7XG5cdFx0ICAgICAgICAvLyB4QmlnSW50ID0gQmlnSW50LmFzVWludE4oNjQsIHhCaWdJbnQpO1xuXHRcdCAgICAgICAgLy8gcmV0dXJuIE51bWJlcih4QmlnSW50KTtcblx0XHQgICAgICAgIHJldHVybiB4O1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gYXNzZXJ0UmVhZGFibGVTdHJlYW0oeCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHgpKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBSZWFkYWJsZVN0cmVhbS5gKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cblx0XHQgICAgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gUmVhZGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0KHN0cmVhbSwgcmVhZFJlcXVlc3QpIHtcblx0XHQgICAgICAgIHN0cmVhbS5fcmVhZGVyLl9yZWFkUmVxdWVzdHMucHVzaChyZWFkUmVxdWVzdCk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZG9uZSkge1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cdFx0ICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHJlYWRlci5fcmVhZFJlcXVlc3RzLnNoaWZ0KCk7XG5cdFx0ICAgICAgICBpZiAoZG9uZSkge1xuXHRcdCAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSB7XG5cdFx0ICAgICAgICByZXR1cm4gc3RyZWFtLl9yZWFkZXIuX3JlYWRSZXF1ZXN0cy5sZW5ndGg7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkge1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cdFx0ICAgICAgICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgfVxuXHRcdCAgICAvKipcblx0XHQgICAgICogQSBkZWZhdWx0IHJlYWRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW19LlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXInKTtcblx0XHQgICAgICAgICAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlcicpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgc3RyZWFtIGJlY29tZXMgY2xvc2VkLFxuXHRcdCAgICAgICAgICogb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvciB0aGUgcmVhZGVyJ3MgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgY2xvc2VkKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBSZWFkYWJsZVN0cmVhbS5jYW5jZWwgfCBzdHJlYW0uY2FuY2VsKHJlYXNvbil9LlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBjYW5jZWwocmVhc29uID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCh0aGlzLCByZWFzb24pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGFsbG93cyBhY2Nlc3MgdG8gdGhlIG5leHQgY2h1bmsgZnJvbSB0aGUgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUsIGlmIGF2YWlsYWJsZS5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBJZiByZWFkaW5nIGEgY2h1bmsgY2F1c2VzIHRoZSBxdWV1ZSB0byBiZWNvbWUgZW1wdHksIG1vcmUgZGF0YSB3aWxsIGJlIHB1bGxlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIHNvdXJjZS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgcmVhZCgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ3JlYWQgZnJvbScpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgbGV0IHJlc29sdmVQcm9taXNlO1xuXHRcdCAgICAgICAgICAgIGxldCByZWplY3RQcm9taXNlO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuXHRcdCAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRSZXF1ZXN0ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pLFxuXHRcdCAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pLFxuXHRcdCAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogZSA9PiByZWplY3RQcm9taXNlKGUpXG5cdFx0ICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHRoaXMsIHJlYWRSZXF1ZXN0KTtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmVsZWFzZXMgdGhlIHJlYWRlcidzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuXHRcdCAgICAgICAgICogSWYgdGhlIGFzc29jaWF0ZWQgc3RyZWFtIGlzIGVycm9yZWQgd2hlbiB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBlcnJvcmVkIGluIHRoZSBzYW1lIHdheVxuXHRcdCAgICAgICAgICogZnJvbSBub3cgb247IG90aGVyd2lzZSwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBjbG9zZWQuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogQSByZWFkZXIncyBsb2NrIGNhbm5vdCBiZSByZWxlYXNlZCB3aGlsZSBpdCBzdGlsbCBoYXMgYSBwZW5kaW5nIHJlYWQgcmVxdWVzdCwgaS5lLiwgaWYgYSBwcm9taXNlIHJldHVybmVkIGJ5XG5cdFx0ICAgICAgICAgKiB0aGUgcmVhZGVyJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5yZWFkIHwgcmVhZCgpfSBtZXRob2QgaGFzIG5vdCB5ZXQgYmVlbiBzZXR0bGVkLiBBdHRlbXB0aW5nIHRvXG5cdFx0ICAgICAgICAgKiBkbyBzbyB3aWxsIHRocm93IGEgYFR5cGVFcnJvcmAgYW5kIGxlYXZlIHRoZSByZWFkZXIgbG9ja2VkIHRvIHRoZSBzdHJlYW0uXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIHJlbGVhc2VMb2NrKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fcmVhZFJlcXVlc3RzLmxlbmd0aCA+IDApIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHJpZWQgdG8gcmVsZWFzZSBhIHJlYWRlciBsb2NrIHdoZW4gdGhhdCByZWFkZXIgaGFzIHBlbmRpbmcgcmVhZCgpIGNhbGxzIHVuLXNldHRsZWQnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLCB7XG5cdFx0ICAgICAgICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXInLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXG5cdFx0ICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkUmVxdWVzdHMnKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCkge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuXHRcdCAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyYCk7XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTguYXN5bmNpdGVyYWJsZVwiIC8+XG5cdFx0ICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvbiAqL1xuXHRcdCAgICBjb25zdCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbiogKCkgeyB9KS5wcm90b3R5cGUpO1xuXG5cdFx0ICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxOC5hc3luY2l0ZXJhYmxlXCIgLz5cblx0XHQgICAgY2xhc3MgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbCB7XG5cdFx0ICAgICAgICBjb25zdHJ1Y3RvcihyZWFkZXIsIHByZXZlbnRDYW5jZWwpIHtcblx0XHQgICAgICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xuXHRcdCAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRDYW5jZWwgPSBwcmV2ZW50Q2FuY2VsO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgbmV4dCgpIHtcblx0XHQgICAgICAgICAgICBjb25zdCBuZXh0U3RlcHMgPSAoKSA9PiB0aGlzLl9uZXh0U3RlcHMoKTtcblx0XHQgICAgICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHRoaXMuX29uZ29pbmdQcm9taXNlID9cblx0XHQgICAgICAgICAgICAgICAgdHJhbnNmb3JtUHJvbWlzZVdpdGgodGhpcy5fb25nb2luZ1Byb21pc2UsIG5leHRTdGVwcywgbmV4dFN0ZXBzKSA6XG5cdFx0ICAgICAgICAgICAgICAgIG5leHRTdGVwcygpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybih2YWx1ZSkge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJldHVyblN0ZXBzID0gKCkgPT4gdGhpcy5fcmV0dXJuU3RlcHModmFsdWUpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/XG5cdFx0ICAgICAgICAgICAgICAgIHRyYW5zZm9ybVByb21pc2VXaXRoKHRoaXMuX29uZ29pbmdQcm9taXNlLCByZXR1cm5TdGVwcywgcmV0dXJuU3RlcHMpIDpcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuU3RlcHMoKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIF9uZXh0U3RlcHMoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX2lzRmluaXNoZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuX3JlYWRlcjtcblx0XHQgICAgICAgICAgICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbignaXRlcmF0ZScpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgbGV0IHJlc29sdmVQcm9taXNlO1xuXHRcdCAgICAgICAgICAgIGxldCByZWplY3RQcm9taXNlO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuXHRcdCAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRSZXF1ZXN0ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYnkgb25lIG1pY3JvdGFzaywgb3RoZXJ3aXNlIHdlIHN0b3AgcHVsbGluZyB0b28gZWFybHkgd2hpY2ggYnJlYWtzIGEgdGVzdC5cblx0XHQgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIElzIHRoaXMgYSBidWcgaW4gdGhlIHNwZWNpZmljYXRpb24sIG9yIGluIHRoZSB0ZXN0P1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pKTtcblx0XHQgICAgICAgICAgICAgICAgfSxcblx0XHQgICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSk7XG5cdFx0ICAgICAgICAgICAgICAgIH0sXG5cdFx0ICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiByZWFzb24gPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlamVjdFByb21pc2UocmVhc29uKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIF9yZXR1cm5TdGVwcyh2YWx1ZSkge1xuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWx1ZSwgZG9uZTogdHJ1ZSB9KTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gdGhpcy5fcmVhZGVyO1xuXHRcdCAgICAgICAgICAgIGlmIChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdmaW5pc2ggaXRlcmF0aW5nJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoIXRoaXMuX3ByZXZlbnRDYW5jZWwpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHJlYWRlciwgdmFsdWUpO1xuXHRcdCAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChyZXN1bHQsICgpID0+ICh7IHZhbHVlLCBkb25lOiB0cnVlIH0pKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgY29uc3QgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0ge1xuXHRcdCAgICAgICAgbmV4dCgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKCduZXh0JykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXN5bmNJdGVyYXRvckltcGwubmV4dCgpO1xuXHRcdCAgICAgICAgfSxcblx0XHQgICAgICAgIHJldHVybih2YWx1ZSkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JldHVybicpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLnJldHVybih2YWx1ZSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH07XG5cdFx0ICAgIGlmIChBc3luY0l0ZXJhdG9yUHJvdG90eXBlICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cblx0XHQgICAgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0sIHByZXZlbnRDYW5jZWwpIHtcblx0XHQgICAgICAgIGNvbnN0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcblx0XHQgICAgICAgIGNvbnN0IGltcGwgPSBuZXcgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbChyZWFkZXIsIHByZXZlbnRDYW5jZWwpO1xuXHRcdCAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBpdGVyYXRvci5fYXN5bmNJdGVyYXRvckltcGwgPSBpbXBsO1xuXHRcdCAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19hc3luY0l0ZXJhdG9ySW1wbCcpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gU3VzcGljaW91c1R5cGVPZkd1YXJkXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHguX2FzeW5jSXRlcmF0b3JJbXBsIGluc3RhbmNlb2Zcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNhdGNoIChfYSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cdFx0ICAgIGZ1bmN0aW9uIHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdGVhbUFzeW5jSXRlcmF0b3JgKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb3JlXCIgLz5cblx0XHQgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzTmFOI1BvbHlmaWxsXG5cdFx0ICAgIGNvbnN0IE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uICh4KSB7XG5cdFx0ICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cdFx0ICAgICAgICByZXR1cm4geCAhPT0geDtcblx0XHQgICAgfTtcblxuXHRcdCAgICBmdW5jdGlvbiBDcmVhdGVBcnJheUZyb21MaXN0KGVsZW1lbnRzKSB7XG5cdFx0ICAgICAgICAvLyBXZSB1c2UgYXJyYXlzIHRvIHJlcHJlc2VudCBsaXN0cywgc28gdGhpcyBpcyBiYXNpY2FsbHkgYSBuby1vcC5cblx0XHQgICAgICAgIC8vIERvIGEgc2xpY2UgdGhvdWdoIGp1c3QgaW4gY2FzZSB3ZSBoYXBwZW4gdG8gZGVwZW5kIG9uIHRoZSB1bmlxdWUtbmVzcy5cblx0XHQgICAgICAgIHJldHVybiBlbGVtZW50cy5zbGljZSgpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIENvcHlEYXRhQmxvY2tCeXRlcyhkZXN0LCBkZXN0T2Zmc2V0LCBzcmMsIHNyY09mZnNldCwgbikge1xuXHRcdCAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZGVzdCkuc2V0KG5ldyBVaW50OEFycmF5KHNyYywgc3JjT2Zmc2V0LCBuKSwgZGVzdE9mZnNldCk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gTm90IGltcGxlbWVudGVkIGNvcnJlY3RseVxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2ZlckFycmF5QnVmZmVyKE8pIHtcblx0XHQgICAgICAgIHJldHVybiBPO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHlcblx0XHQgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuXHRcdCAgICBmdW5jdGlvbiBJc0RldGFjaGVkQnVmZmVyKE8pIHtcblx0XHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBBcnJheUJ1ZmZlclNsaWNlKGJ1ZmZlciwgYmVnaW4sIGVuZCkge1xuXHRcdCAgICAgICAgLy8gQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBhdmFpbGFibGUgb24gSUUxMFxuXHRcdCAgICAgICAgLy8gaHR0cHM6Ly93d3cuY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfYXJyYXlidWZmZXJfc2xpY2Vcblx0XHQgICAgICAgIGlmIChidWZmZXIuc2xpY2UpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKGJlZ2luLCBlbmQpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgbGVuZ3RoID0gZW5kIC0gYmVnaW47XG5cdFx0ICAgICAgICBjb25zdCBzbGljZSA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGgpO1xuXHRcdCAgICAgICAgQ29weURhdGFCbG9ja0J5dGVzKHNsaWNlLCAwLCBidWZmZXIsIGJlZ2luLCBsZW5ndGgpO1xuXHRcdCAgICAgICAgcmV0dXJuIHNsaWNlO1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gSXNOb25OZWdhdGl2ZU51bWJlcih2KSB7XG5cdFx0ICAgICAgICBpZiAodHlwZW9mIHYgIT09ICdudW1iZXInKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKE51bWJlcklzTmFOKHYpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHYgPCAwKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gQ2xvbmVBc1VpbnQ4QXJyYXkoTykge1xuXHRcdCAgICAgICAgY29uc3QgYnVmZmVyID0gQXJyYXlCdWZmZXJTbGljZShPLmJ1ZmZlciwgTy5ieXRlT2Zmc2V0LCBPLmJ5dGVPZmZzZXQgKyBPLmJ5dGVMZW5ndGgpO1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBEZXF1ZXVlVmFsdWUoY29udGFpbmVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5zaGlmdCgpO1xuXHRcdCAgICAgICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBwYWlyLnNpemU7XG5cdFx0ICAgICAgICBpZiAoY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA8IDApIHtcblx0XHQgICAgICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplID0gMDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBwYWlyLnZhbHVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRhaW5lciwgdmFsdWUsIHNpemUpIHtcblx0XHQgICAgICAgIGlmICghSXNOb25OZWdhdGl2ZU51bWJlcihzaXplKSB8fCBzaXplID09PSBJbmZpbml0eSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdTaXplIG11c3QgYmUgYSBmaW5pdGUsIG5vbi1OYU4sIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb250YWluZXIuX3F1ZXVlLnB1c2goeyB2YWx1ZSwgc2l6ZSB9KTtcblx0XHQgICAgICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgKz0gc2l6ZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBQZWVrUXVldWVWYWx1ZShjb250YWluZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IHBhaXIgPSBjb250YWluZXIuX3F1ZXVlLnBlZWsoKTtcblx0XHQgICAgICAgIHJldHVybiBwYWlyLnZhbHVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlc2V0UXVldWUoY29udGFpbmVyKSB7XG5cdFx0ICAgICAgICBjb250YWluZXIuX3F1ZXVlID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cdFx0ICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplID0gMDtcblx0XHQgICAgfVxuXG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBIHB1bGwtaW50byByZXF1ZXN0IGluIGEge0BsaW5rIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJ9LlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyB0aGUgdmlldyBmb3Igd3JpdGluZyBpbiB0bywgb3IgYG51bGxgIGlmIHRoZSBCWU9CIHJlcXVlc3QgaGFzIGFscmVhZHkgYmVlbiByZXNwb25kZWQgdG8uXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCB2aWV3KCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigndmlldycpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlldztcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJlc3BvbmQoYnl0ZXNXcml0dGVuKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoYnl0ZXNXcml0dGVuLCAxLCAncmVzcG9uZCcpO1xuXHRcdCAgICAgICAgICAgIGJ5dGVzV3JpdHRlbiA9IGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZShieXRlc1dyaXR0ZW4sICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIEJZT0IgcmVxdWVzdCBoYXMgYmVlbiBpbnZhbGlkYXRlZCcpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih0aGlzLl92aWV3LmJ1ZmZlcikpIDtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZCh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgYnl0ZXNXcml0dGVuKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJlc3BvbmRXaXRoTmV3Vmlldyh2aWV3KSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kV2l0aE5ld1ZpZXcnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCh2aWV3LCAxLCAncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XG5cdFx0ICAgICAgICAgICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcodmlldykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbiBvbmx5IHJlc3BvbmQgd2l0aCBhcnJheSBidWZmZXIgdmlld3MnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKSA7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3Vmlldyh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgdmlldyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUsIHtcblx0XHQgICAgICAgIHJlc3BvbmQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcmVzcG9uZFdpdGhOZXdWaWV3OiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHZpZXc6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuXHRcdCAgICAgICAgICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCcsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICAvKipcblx0XHQgICAgICogQWxsb3dzIGNvbnRyb2wgb2YgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBieXRlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEBwdWJsaWNcblx0XHQgICAgICovXG5cdFx0ICAgIGNsYXNzIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IoKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IEJZT0IgcHVsbCByZXF1ZXN0LCBvciBgbnVsbGAgaWYgdGhlcmUgaXNuJ3Qgb25lLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgYnlvYlJlcXVlc3QoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdieW9iUmVxdWVzdCcpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgY29udHJvbGxlZCBzdHJlYW0ncyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXNcblx0XHQgICAgICAgICAqIG92ZXItZnVsbC4gQW4gdW5kZXJseWluZyBieXRlIHNvdXJjZSBvdWdodCB0byB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgd2hlbiBhbmQgaG93IHRvIGFwcGx5IGJhY2twcmVzc3VyZS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbS4gQ29uc3VtZXJzIHdpbGwgc3RpbGwgYmUgYWJsZSB0byByZWFkIGFueSBwcmV2aW91c2x5LWVucXVldWVkIGNodW5rcyBmcm9tXG5cdFx0ICAgICAgICAgKiB0aGUgc3RyZWFtLCBidXQgb25jZSB0aG9zZSBhcmUgcmVhZCwgdGhlIHN0cmVhbSB3aWxsIGJlY29tZSBjbG9zZWQuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGNsb3NlKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQ7IGRvIG5vdCBjbG9zZSBpdCBhZ2FpbiEnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgICAgICBpZiAoc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtzdGF0ZX0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgcmVhZGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBjbG9zZWRgKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZW5xdWV1ZShjaHVuaykge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZW5xdWV1ZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGNodW5rLCAxLCAnZW5xdWV1ZScpO1xuXHRcdCAgICAgICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KGNodW5rKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaHVuayBtdXN0IGJlIGFuIGFycmF5IGJ1ZmZlciB2aWV3Jyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChjaHVuay5idWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjaHVuaydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aGApO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyZWFtIGlzIGNsb3NlZCBvciBkcmFpbmluZycpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGVucXVldWVkIHRvYCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogRXJyb3JzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmUgaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGVycm9yKGUgPSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Vycm9yJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cblx0XHQgICAgICAgIFtDYW5jZWxTdGVwc10ocmVhc29uKSB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyh0aGlzKTtcblx0XHQgICAgICAgICAgICBSZXNldFF1ZXVlKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cblx0XHQgICAgICAgIFtQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0KSB7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblx0XHQgICAgICAgICAgICAgICAgdGhpcy5fcXVldWVUb3RhbFNpemUgLT0gZW50cnkuYnl0ZUxlbmd0aDtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4odGhpcyk7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShlbnRyeS5idWZmZXIsIGVudHJ5LmJ5dGVPZmZzZXQsIGVudHJ5LmJ5dGVMZW5ndGgpO1xuXHRcdCAgICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyh2aWV3KTtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSB0aGlzLl9hdXRvQWxsb2NhdGVDaHVua1NpemU7XG5cdFx0ICAgICAgICAgICAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGxldCBidWZmZXI7XG5cdFx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYXV0b0FsbG9jYXRlQ2h1bmtTaXplKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBjYXRjaCAoYnVmZmVyRSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoYnVmZmVyRSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgYnVmZmVyLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgYnVmZmVyQnl0ZUxlbmd0aDogYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldDogMCxcblx0XHQgICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGg6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcblx0XHQgICAgICAgICAgICAgICAgICAgIGJ5dGVzRmlsbGVkOiAwLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNpemU6IDEsXG5cdFx0ICAgICAgICAgICAgICAgICAgICB2aWV3Q29uc3RydWN0b3I6IFVpbnQ4QXJyYXksXG5cdFx0ICAgICAgICAgICAgICAgICAgICByZWFkZXJUeXBlOiAnZGVmYXVsdCdcblx0XHQgICAgICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUsIHtcblx0XHQgICAgICAgIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgYnlvYlJlcXVlc3Q6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuXHRcdCAgICAgICAgICAgIHZhbHVlOiAnUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcicsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5cblx0XHQgICAgZnVuY3Rpb24gSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcicpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0O1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IHNob3VsZFB1bGwgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBpZiAoIXNob3VsZFB1bGwpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IHRydWU7XG5cdFx0ICAgICAgICAvLyBUT0RPOiBUZXN0IGNvbnRyb2xsZXIgYXJndW1lbnRcblx0XHQgICAgICAgIGNvbnN0IHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgdXBvblByb21pc2UocHVsbFByb21pc2UsICgpID0+IHtcblx0XHQgICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxBZ2Fpbikge1xuXHRcdCAgICAgICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfSwgZSA9PiB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyhjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3Ioc3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcblx0XHQgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICBkb25lID0gdHJ1ZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IGZpbGxlZFZpZXcgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvcihwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXHRcdCAgICAgICAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5yZWFkZXJUeXBlID09PSAnZGVmYXVsdCcpIHtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGZpbGxlZFZpZXcsIGRvbmUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgZmlsbGVkVmlldywgZG9uZSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKSB7XG5cdFx0ICAgICAgICBjb25zdCBieXRlc0ZpbGxlZCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcblx0XHQgICAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBwdWxsSW50b0Rlc2NyaXB0b3Iudmlld0NvbnN0cnVjdG9yKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCBieXRlc0ZpbGxlZCAvIGVsZW1lbnRTaXplKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCBidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlLnB1c2goeyBidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggfSk7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSArPSBieXRlTGVuZ3RoO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuXHRcdCAgICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemU7XG5cdFx0ICAgICAgICBjb25zdCBjdXJyZW50QWxpZ25lZEJ5dGVzID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgZWxlbWVudFNpemU7XG5cdFx0ICAgICAgICBjb25zdCBtYXhCeXRlc1RvQ29weSA9IE1hdGgubWluKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZUxlbmd0aCAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG5cdFx0ICAgICAgICBjb25zdCBtYXhCeXRlc0ZpbGxlZCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIG1heEJ5dGVzVG9Db3B5O1xuXHRcdCAgICAgICAgY29uc3QgbWF4QWxpZ25lZEJ5dGVzID0gbWF4Qnl0ZXNGaWxsZWQgLSBtYXhCeXRlc0ZpbGxlZCAlIGVsZW1lbnRTaXplO1xuXHRcdCAgICAgICAgbGV0IHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPSBtYXhCeXRlc1RvQ29weTtcblx0XHQgICAgICAgIGxldCByZWFkeSA9IGZhbHNlO1xuXHRcdCAgICAgICAgaWYgKG1heEFsaWduZWRCeXRlcyA+IGN1cnJlbnRBbGlnbmVkQnl0ZXMpIHtcblx0XHQgICAgICAgICAgICB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID0gbWF4QWxpZ25lZEJ5dGVzIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuXHRcdCAgICAgICAgICAgIHJlYWR5ID0gdHJ1ZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IHF1ZXVlID0gY29udHJvbGxlci5fcXVldWU7XG5cdFx0ICAgICAgICB3aGlsZSAodG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA+IDApIHtcblx0XHQgICAgICAgICAgICBjb25zdCBoZWFkT2ZRdWV1ZSA9IHF1ZXVlLnBlZWsoKTtcblx0XHQgICAgICAgICAgICBjb25zdCBieXRlc1RvQ29weSA9IE1hdGgubWluKHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcsIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGgpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGRlc3RTdGFydCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuXHRcdCAgICAgICAgICAgIENvcHlEYXRhQmxvY2tCeXRlcyhwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBkZXN0U3RhcnQsIGhlYWRPZlF1ZXVlLmJ1ZmZlciwgaGVhZE9mUXVldWUuYnl0ZU9mZnNldCwgYnl0ZXNUb0NvcHkpO1xuXHRcdCAgICAgICAgICAgIGlmIChoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoID09PSBieXRlc1RvQ29weSkge1xuXHRcdCAgICAgICAgICAgICAgICBxdWV1ZS5zaGlmdCgpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgaGVhZE9mUXVldWUuYnl0ZU9mZnNldCArPSBieXRlc1RvQ29weTtcblx0XHQgICAgICAgICAgICAgICAgaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCAtPSBieXRlc1RvQ29weTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgLT0gYnl0ZXNUb0NvcHk7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIGJ5dGVzVG9Db3B5LCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXHRcdCAgICAgICAgICAgIHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgLT0gYnl0ZXNUb0NvcHk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gcmVhZHk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIHNpemUsIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuXHRcdCAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICs9IHNpemU7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4oY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID09PSAwICYmIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdC5fdmlldyA9IG51bGw7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9IG51bGw7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICB3aGlsZSAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG5cdFx0ICAgICAgICAgICAgaWYgKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikpIHtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50byhjb250cm9sbGVyLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cdFx0ICAgICAgICBsZXQgZWxlbWVudFNpemUgPSAxO1xuXHRcdCAgICAgICAgaWYgKHZpZXcuY29uc3RydWN0b3IgIT09IERhdGFWaWV3KSB7XG5cdFx0ICAgICAgICAgICAgZWxlbWVudFNpemUgPSB2aWV3LmNvbnN0cnVjdG9yLkJZVEVTX1BFUl9FTEVNRU5UO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgY3RvciA9IHZpZXcuY29uc3RydWN0b3I7XG5cdFx0ICAgICAgICAvLyB0cnkge1xuXHRcdCAgICAgICAgY29uc3QgYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcih2aWV3LmJ1ZmZlcik7XG5cdFx0ICAgICAgICAvLyB9IGNhdGNoIChlKSB7XG5cdFx0ICAgICAgICAvLyAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcblx0XHQgICAgICAgIC8vICAgcmV0dXJuO1xuXHRcdCAgICAgICAgLy8gfVxuXHRcdCAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0ge1xuXHRcdCAgICAgICAgICAgIGJ1ZmZlcixcblx0XHQgICAgICAgICAgICBidWZmZXJCeXRlTGVuZ3RoOiBidWZmZXIuYnl0ZUxlbmd0aCxcblx0XHQgICAgICAgICAgICBieXRlT2Zmc2V0OiB2aWV3LmJ5dGVPZmZzZXQsXG5cdFx0ICAgICAgICAgICAgYnl0ZUxlbmd0aDogdmlldy5ieXRlTGVuZ3RoLFxuXHRcdCAgICAgICAgICAgIGJ5dGVzRmlsbGVkOiAwLFxuXHRcdCAgICAgICAgICAgIGVsZW1lbnRTaXplLFxuXHRcdCAgICAgICAgICAgIHZpZXdDb25zdHJ1Y3RvcjogY3Rvcixcblx0XHQgICAgICAgICAgICByZWFkZXJUeXBlOiAnYnlvYidcblx0XHQgICAgICAgIH07XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cdFx0ICAgICAgICAgICAgLy8gTm8gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoKSBjYWxsIHNpbmNlOlxuXHRcdCAgICAgICAgICAgIC8vIC0gTm8gY2hhbmdlIGhhcHBlbnMgb24gZGVzaXJlZFNpemVcblx0XHQgICAgICAgICAgICAvLyAtIFRoZSBzb3VyY2UgaGFzIGFscmVhZHkgYmVlbiBub3RpZmllZCBvZiB0aGF0IHRoZXJlJ3MgYXQgbGVhc3QgMSBwZW5kaW5nIHJlYWQodmlldylcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZW1wdHlWaWV3ID0gbmV3IGN0b3IocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQsIDApO1xuXHRcdCAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhlbXB0eVZpZXcpO1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcblx0XHQgICAgICAgICAgICBpZiAoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yKSkge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4oY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2h1bmtTdGVwcyhmaWxsZWRWaWV3KTtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBUeXBlRXJyb3IoJ0luc3VmZmljaWVudCBieXRlcyB0byBmaWxsIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBidWZmZXInKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuXHRcdCAgICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcblx0XHQgICAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgcmVhZEludG9SZXF1ZXN0KTtcblx0XHQgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZShjb250cm9sbGVyLCBmaXJzdERlc2NyaXB0b3IpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cdFx0ICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcblx0XHQgICAgICAgICAgICB3aGlsZSAoUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihzdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXHRcdCAgICAgICAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA8IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGNvbnN0IHJlbWFpbmRlclNpemUgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgJSBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemU7XG5cdFx0ICAgICAgICBpZiAocmVtYWluZGVyU2l6ZSA+IDApIHtcblx0XHQgICAgICAgICAgICBjb25zdCBlbmQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcblx0XHQgICAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSBBcnJheUJ1ZmZlclNsaWNlKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIGVuZCAtIHJlbWFpbmRlclNpemUsIGVuZCk7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgcmVtYWluZGVyLCAwLCByZW1haW5kZXIuYnl0ZUxlbmd0aCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgLT0gcmVtYWluZGVyU2l6ZTtcblx0XHQgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKTtcblx0XHQgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pIHtcblx0XHQgICAgICAgIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuXHRcdCAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJblJlYWRhYmxlU3RhdGUoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBmaXJzdERlc2NyaXB0b3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnNoaWZ0KCk7XG5cdFx0ICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFjb250cm9sbGVyLl9zdGFydGVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBkZXNpcmVkU2l6ZSA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGlmIChkZXNpcmVkU2l6ZSA+IDApIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQSBjbGllbnQgb2YgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcblx0XHQgICAgICAgICAgICBjb25zdCBmaXJzdFBlbmRpbmdQdWxsSW50byA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuXHRcdCAgICAgICAgICAgIGlmIChmaXJzdFBlbmRpbmdQdWxsSW50by5ieXRlc0ZpbGxlZCA+IDApIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBUeXBlRXJyb3IoJ0luc3VmZmljaWVudCBieXRlcyB0byBmaWxsIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBidWZmZXInKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgfHwgc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGNodW5rLmJ1ZmZlcjtcblx0XHQgICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBjaHVuay5ieXRlT2Zmc2V0O1xuXHRcdCAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGNodW5rLmJ5dGVMZW5ndGg7XG5cdFx0ICAgICAgICBjb25zdCB0cmFuc2ZlcnJlZEJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIoYnVmZmVyKTtcblx0XHQgICAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcblx0XHQgICAgICAgICAgICBjb25zdCBmaXJzdFBlbmRpbmdQdWxsSW50byA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuXHRcdCAgICAgICAgICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ1ZmZlcikpIDtcblx0XHQgICAgICAgICAgICBmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ1ZmZlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPT09IDApIHtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVycmVkVmlldyA9IG5ldyBVaW50OEFycmF5KHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCB0cmFuc2ZlcnJlZFZpZXcsIGZhbHNlKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSkge1xuXHRcdCAgICAgICAgICAgIC8vIFRPRE86IElkZWFsbHkgaW4gdGhpcyBicmFuY2ggZGV0YWNoaW5nIHNob3VsZCBoYXBwZW4gb25seSBpZiB0aGUgYnVmZmVyIGlzIG5vdCBjb25zdW1lZCBmdWxseS5cblx0XHQgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBSZWFkYWJsZVN0cmVhbUVycm9yKHN0cmVhbSwgZSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGlmIChjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9PT0gbnVsbCAmJiBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcblx0XHQgICAgICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcblx0XHQgICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciwgZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQsIGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoIC0gZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkKTtcblx0XHQgICAgICAgICAgICBjb25zdCBieW9iUmVxdWVzdCA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUpO1xuXHRcdCAgICAgICAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdChieW9iUmVxdWVzdCwgY29udHJvbGxlciwgdmlldyk7XG5cdFx0ICAgICAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBieW9iUmVxdWVzdDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBjb250cm9sbGVyLl9ieW9iUmVxdWVzdDtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIDA7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pIHtcblx0XHQgICAgICAgIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICBpZiAoYnl0ZXNXcml0dGVuICE9PSAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzV3JpdHRlbiBtdXN0IGJlIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmQoKSBvbiBhIGNsb3NlZCBzdHJlYW0nKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzV3JpdHRlbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSByZWFkYWJsZSBzdHJlYW0nKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIGJ5dGVzV3JpdHRlbiA+IGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdieXRlc1dyaXR0ZW4gb3V0IG9mIHJhbmdlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlcik7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3Vmlldyhjb250cm9sbGVyLCB2aWV3KSB7XG5cdFx0ICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCAhPT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmlld1xcJ3MgbGVuZ3RoIG11c3QgYmUgMCB3aGVuIGNhbGxpbmcgcmVzcG9uZFdpdGhOZXdWaWV3KCkgb24gYSBjbG9zZWQgc3RyZWFtJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmlld1xcJ3MgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgcmVhZGFibGUgc3RyZWFtJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICE9PSB2aWV3LmJ5dGVPZmZzZXQpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHJlZ2lvbiBzcGVjaWZpZWQgYnkgdmlldyBkb2VzIG5vdCBtYXRjaCBieW9iUmVxdWVzdCcpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKGZpcnN0RGVzY3JpcHRvci5idWZmZXJCeXRlTGVuZ3RoICE9PSB2aWV3LmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBidWZmZXIgb2YgdmlldyBoYXMgZGlmZmVyZW50IGNhcGFjaXR5IHRoYW4gYnlvYlJlcXVlc3QnKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyB2aWV3LmJ5dGVMZW5ndGggPiBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGlzIGxhcmdlciB0aGFuIGJ5b2JSZXF1ZXN0Jyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCB2aWV3Qnl0ZUxlbmd0aCA9IHZpZXcuYnl0ZUxlbmd0aDtcblx0XHQgICAgICAgIGZpcnN0RGVzY3JpcHRvci5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKHZpZXcuYnVmZmVyKTtcblx0XHQgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgdmlld0J5dGVMZW5ndGgpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSkge1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSA9IHN0cmVhbTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBudWxsO1xuXHRcdCAgICAgICAgLy8gTmVlZCB0byBzZXQgdGhlIHNsb3RzIHNvIHRoYXQgdGhlIGFzc2VydCBkb2Vzbid0IGZpcmUuIEluIHRoZSBzcGVjIHRoZSBzbG90cyBhbHJlYWR5IGV4aXN0IGltcGxpY2l0bHkuXG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9xdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gZmFsc2U7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gcHVsbEFsZ29yaXRobTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IGNhbmNlbEFsZ29yaXRobTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcblx0XHQgICAgICAgIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcblx0XHQgICAgICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcblx0XHQgICAgICAgIHVwb25Qcm9taXNlKHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpLCAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9LCByID0+IHtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgcik7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZShzdHJlYW0sIHVuZGVybHlpbmdCeXRlU291cmNlLCBoaWdoV2F0ZXJNYXJrKSB7XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBsZXQgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBsZXQgcHVsbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIGxldCBjYW5jZWxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ0J5dGVTb3VyY2Uuc3RhcnQoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2UucHVsbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdCeXRlU291cmNlLnB1bGwoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBjYW5jZWxBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsKHJlYXNvbik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5hdXRvQWxsb2NhdGVDaHVua1NpemU7XG5cdFx0ICAgICAgICBpZiAoYXV0b0FsbG9jYXRlQ2h1bmtTaXplID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXV0b0FsbG9jYXRlQ2h1bmtTaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHJlcXVlc3QsIGNvbnRyb2xsZXIsIHZpZXcpIHtcblx0XHQgICAgICAgIHJlcXVlc3QuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcblx0XHQgICAgICAgIHJlcXVlc3QuX3ZpZXcgPSB2aWV3O1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LlxuXHRcdCAgICBmdW5jdGlvbiBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3RgKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5cblx0XHQgICAgZnVuY3Rpb24gYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyYCk7XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cdFx0ICAgIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpIHtcblx0XHQgICAgICAgIHN0cmVhbS5fcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLnB1c2gocmVhZEludG9SZXF1ZXN0KTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZG9uZSkge1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cdFx0ICAgICAgICBjb25zdCByZWFkSW50b1JlcXVlc3QgPSByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuc2hpZnQoKTtcblx0XHQgICAgICAgIGlmIChkb25lKSB7XG5cdFx0ICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKGNodW5rKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbSkge1xuXHRcdCAgICAgICAgcmV0dXJuIHN0cmVhbS5fcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aDtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcblx0XHQgICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBIEJZT0IgcmVhZGVyIHZlbmRlZCBieSBhIHtAbGluayBSZWFkYWJsZVN0cmVhbX0uXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEBwdWJsaWNcblx0XHQgICAgICovXG5cdFx0ICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciB7XG5cdFx0ICAgICAgICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcblx0XHQgICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcicpO1xuXHRcdCAgICAgICAgICAgIGFzc2VydFJlYWRhYmxlU3RyZWFtKHN0cmVhbSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29uc3RydWN0IGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIGZvciBhIHN0cmVhbSBub3QgY29uc3RydWN0ZWQgd2l0aCBhIGJ5dGUgJyArXG5cdFx0ICAgICAgICAgICAgICAgICAgICAnc291cmNlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUodGhpcywgc3RyZWFtKTtcblx0XHQgICAgICAgICAgICB0aGlzLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgc3RyZWFtIGJlY29tZXMgY2xvc2VkLCBvciByZWplY3RlZCBpZiB0aGUgc3RyZWFtIGV2ZXIgZXJyb3JzIG9yXG5cdFx0ICAgICAgICAgKiB0aGUgcmVhZGVyJ3MgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgY2xvc2VkKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBSZWFkYWJsZVN0cmVhbS5jYW5jZWwgfCBzdHJlYW0uY2FuY2VsKHJlYXNvbil9LlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBjYW5jZWwocmVhc29uID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCh0aGlzLCByZWFzb24pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBBdHRlbXB0cyB0byByZWFkcyBieXRlcyBpbnRvIHZpZXcsIGFuZCByZXR1cm5zIGEgcHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHQuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogSWYgcmVhZGluZyBhIGNodW5rIGNhdXNlcyB0aGUgcXVldWUgdG8gYmVjb21lIGVtcHR5LCBtb3JlIGRhdGEgd2lsbCBiZSBwdWxsZWQgZnJvbSB0aGUgdW5kZXJseWluZyBzb3VyY2UuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIHJlYWQodmlldykge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWQnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXcgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlldycpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3IG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodmlldy5idWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGB2aWV3J3MgYnVmZmVyIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoYCkpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpIDtcblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ3JlYWQgZnJvbScpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgbGV0IHJlc29sdmVQcm9taXNlO1xuXHRcdCAgICAgICAgICAgIGxldCByZWplY3RQcm9taXNlO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuXHRcdCAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdCA9IHtcblx0XHQgICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSxcblx0XHQgICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiB0cnVlIH0pLFxuXHRcdCAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogZSA9PiByZWplY3RQcm9taXNlKGUpXG5cdFx0ICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHRoaXMsIHZpZXcsIHJlYWRJbnRvUmVxdWVzdCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJlbGVhc2VzIHRoZSByZWFkZXIncyBsb2NrIG9uIHRoZSBjb3JyZXNwb25kaW5nIHN0cmVhbS4gQWZ0ZXIgdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgaXMgbm8gbG9uZ2VyIGFjdGl2ZS5cblx0XHQgICAgICAgICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXlcblx0XHQgICAgICAgICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIEEgcmVhZGVyJ3MgbG9jayBjYW5ub3QgYmUgcmVsZWFzZWQgd2hpbGUgaXQgc3RpbGwgaGFzIGEgcGVuZGluZyByZWFkIHJlcXVlc3QsIGkuZS4sIGlmIGEgcHJvbWlzZSByZXR1cm5lZCBieVxuXHRcdCAgICAgICAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xuXHRcdCAgICAgICAgICogZG8gc28gd2lsbCB0aHJvdyBhIGBUeXBlRXJyb3JgIGFuZCBsZWF2ZSB0aGUgcmVhZGVyIGxvY2tlZCB0byB0aGUgc3RyZWFtLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICByZWxlYXNlTG9jaygpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUcmllZCB0byByZWxlYXNlIGEgcmVhZGVyIGxvY2sgd2hlbiB0aGF0IHJlYWRlciBoYXMgcGVuZGluZyByZWFkKCkgY2FsbHMgdW4tc2V0dGxlZCcpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUsIHtcblx0XHQgICAgICAgIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICByZWFkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cblx0XHQgICAgfSk7XG5cdFx0ICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcicsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgcmVhZGVycy5cblx0XHQgICAgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoeCkge1xuXHRcdCAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRJbnRvUmVxdWVzdHMnKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQocmVhZGVyLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcblx0XHQgICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8oc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHZpZXcsIHJlYWRJbnRvUmVxdWVzdCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5cblx0XHQgICAgZnVuY3Rpb24gYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyYCk7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgZGVmYXVsdEhXTSkge1xuXHRcdCAgICAgICAgY29uc3QgeyBoaWdoV2F0ZXJNYXJrIH0gPSBzdHJhdGVneTtcblx0XHQgICAgICAgIGlmIChoaWdoV2F0ZXJNYXJrID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEhXTTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChOdW1iZXJJc05hTihoaWdoV2F0ZXJNYXJrKSB8fCBoaWdoV2F0ZXJNYXJrIDwgMCkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGhpZ2hXYXRlck1hcmsnKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBoaWdoV2F0ZXJNYXJrO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIEV4dHJhY3RTaXplQWxnb3JpdGhtKHN0cmF0ZWd5KSB7XG5cdFx0ICAgICAgICBjb25zdCB7IHNpemUgfSA9IHN0cmF0ZWd5O1xuXHRcdCAgICAgICAgaWYgKCFzaXplKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuICgpID0+IDE7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gc2l6ZTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3koaW5pdCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShpbml0LCBjb250ZXh0KTtcblx0XHQgICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGlnaFdhdGVyTWFyaztcblx0XHQgICAgICAgIGNvbnN0IHNpemUgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuc2l6ZTtcblx0XHQgICAgICAgIHJldHVybiB7XG5cdFx0ICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFVucmVzdHJpY3RlZERvdWJsZShoaWdoV2F0ZXJNYXJrKSxcblx0XHQgICAgICAgICAgICBzaXplOiBzaXplID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5U2l6ZShzaXplLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzaXplJyB0aGF0YClcblx0XHQgICAgICAgIH07XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUoZm4sIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiBjaHVuayA9PiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGZuKGNodW5rKSk7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1Npbmsob3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydERpY3Rpb25hcnkob3JpZ2luYWwsIGNvbnRleHQpO1xuXHRcdCAgICAgICAgY29uc3QgYWJvcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuYWJvcnQ7XG5cdFx0ICAgICAgICBjb25zdCBjbG9zZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5jbG9zZTtcblx0XHQgICAgICAgIGNvbnN0IHN0YXJ0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnN0YXJ0O1xuXHRcdCAgICAgICAgY29uc3QgdHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC50eXBlO1xuXHRcdCAgICAgICAgY29uc3Qgd3JpdGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwud3JpdGU7XG5cdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgICAgIGFib3J0OiBhYm9ydCA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayhhYm9ydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2Fib3J0JyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgY2xvc2U6IGNsb3NlID09PSB1bmRlZmluZWQgP1xuXHRcdCAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuXHRcdCAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrKGNsb3NlLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2xvc2UnIHRoYXRgKSxcblx0XHQgICAgICAgICAgICBzdGFydDogc3RhcnQgPT09IHVuZGVmaW5lZCA/XG5cdFx0ICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2soc3RhcnQsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLFxuXHRcdCAgICAgICAgICAgIHdyaXRlOiB3cml0ZSA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjayh3cml0ZSwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3dyaXRlJyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgdHlwZVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChyZWFzb24pID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW3JlYXNvbl0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG5cdFx0ICAgICAgICByZXR1cm4gKCkgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbXSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG5cdFx0ICAgICAgICByZXR1cm4gKGNodW5rLCBjb250cm9sbGVyKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjaHVuaywgY29udHJvbGxlcl0pO1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gYXNzZXJ0V3JpdGFibGVTdHJlYW0oeCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHgpKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBXcml0YWJsZVN0cmVhbS5gKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGlzQWJvcnRTaWduYWwodmFsdWUpIHtcblx0XHQgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLmFib3J0ZWQgPT09ICdib29sZWFuJztcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNhdGNoIChfYSkge1xuXHRcdCAgICAgICAgICAgIC8vIEFib3J0U2lnbmFsLnByb3RvdHlwZS5hYm9ydGVkIHRocm93cyBpZiBpdHMgYnJhbmQgY2hlY2sgZmFpbHNcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgY29uc3Qgc3VwcG9ydHNBYm9ydENvbnRyb2xsZXIgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSAnZnVuY3Rpb24nO1xuXHRcdCAgICAvKipcblx0XHQgICAgICogQ29uc3RydWN0IGEgbmV3IEFib3J0Q29udHJvbGxlciwgaWYgc3VwcG9ydGVkIGJ5IHRoZSBwbGF0Zm9ybS5cblx0XHQgICAgICpcblx0XHQgICAgICogQGludGVybmFsXG5cdFx0ICAgICAqL1xuXHRcdCAgICBmdW5jdGlvbiBjcmVhdGVBYm9ydENvbnRyb2xsZXIoKSB7XG5cdFx0ICAgICAgICBpZiAoc3VwcG9ydHNBYm9ydENvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0XHQgICAgfVxuXG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBIHdyaXRhYmxlIHN0cmVhbSByZXByZXNlbnRzIGEgZGVzdGluYXRpb24gZm9yIGRhdGEsIGludG8gd2hpY2ggeW91IGNhbiB3cml0ZS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgV3JpdGFibGVTdHJlYW0ge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IocmF3VW5kZXJseWluZ1NpbmsgPSB7fSwgcmF3U3RyYXRlZ3kgPSB7fSkge1xuXHRcdCAgICAgICAgICAgIGlmIChyYXdVbmRlcmx5aW5nU2luayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJhd1VuZGVybHlpbmdTaW5rID0gbnVsbDtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGFzc2VydE9iamVjdChyYXdVbmRlcmx5aW5nU2luaywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3U3RyYXRlZ3ksICdTZWNvbmQgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgdW5kZXJseWluZ1NpbmsgPSBjb252ZXJ0VW5kZXJseWluZ1NpbmsocmF3VW5kZXJseWluZ1NpbmssICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0odGhpcyk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgdHlwZSA9IHVuZGVybHlpbmdTaW5rLnR5cGU7XG5cdFx0ICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlIGlzIHNwZWNpZmllZCcpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCBzaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0oc3RyYXRlZ3kpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMSk7XG5cdFx0ICAgICAgICAgICAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rKHRoaXMsIHVuZGVybHlpbmdTaW5rLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgd3JpdGFibGUgc3RyZWFtIGlzIGxvY2tlZCB0byBhIHdyaXRlci5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGxvY2tlZCgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdsb2NrZWQnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIEFib3J0cyB0aGUgc3RyZWFtLCBzaWduYWxpbmcgdGhhdCB0aGUgcHJvZHVjZXIgY2FuIG5vIGxvbmdlciBzdWNjZXNzZnVsbHkgd3JpdGUgdG8gdGhlIHN0cmVhbSBhbmQgaXQgaXMgdG8gYmVcblx0XHQgICAgICAgICAqIGltbWVkaWF0ZWx5IG1vdmVkIHRvIGFuIGVycm9yZWQgc3RhdGUsIHdpdGggYW55IHF1ZXVlZC11cCB3cml0ZXMgZGlzY2FyZGVkLiBUaGlzIHdpbGwgYWxzbyBleGVjdXRlIGFueSBhYm9ydFxuXHRcdCAgICAgICAgICogbWVjaGFuaXNtIG9mIHRoZSB1bmRlcmx5aW5nIHNpbmsuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogVGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBmdWxmaWxsIGlmIHRoZSBzdHJlYW0gc2h1dHMgZG93biBzdWNjZXNzZnVsbHksIG9yIHJlamVjdCBpZiB0aGUgdW5kZXJseWluZyBzaW5rIHNpZ25hbGVkXG5cdFx0ICAgICAgICAgKiB0aGF0IHRoZXJlIHdhcyBhbiBlcnJvciBkb2luZyBzby4gQWRkaXRpb25hbGx5LCBpdCB3aWxsIHJlamVjdCB3aXRoIGEgYFR5cGVFcnJvcmAgKHdpdGhvdXQgYXR0ZW1wdGluZyB0byBjYW5jZWxcblx0XHQgICAgICAgICAqIHRoZSBzdHJlYW0pIGlmIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGxvY2tlZC5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgYWJvcnQocmVhc29uID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMignYWJvcnQnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBhYm9ydCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgd3JpdGVyJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydCh0aGlzLCByZWFzb24pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBDbG9zZXMgdGhlIHN0cmVhbS4gVGhlIHVuZGVybHlpbmcgc2luayB3aWxsIGZpbmlzaCBwcm9jZXNzaW5nIGFueSBwcmV2aW91c2x5LXdyaXR0ZW4gY2h1bmtzLCBiZWZvcmUgaW52b2tpbmcgaXRzXG5cdFx0ICAgICAgICAgKiBjbG9zZSBiZWhhdmlvci4gRHVyaW5nIHRoaXMgdGltZSBhbnkgZnVydGhlciBhdHRlbXB0cyB0byB3cml0ZSB3aWxsIGZhaWwgKHdpdGhvdXQgZXJyb3JpbmcgdGhlIHN0cmVhbSkuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogVGhlIG1ldGhvZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCBpZiBhbGwgcmVtYWluaW5nIGNodW5rcyBhcmUgc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gYW5kIHRoZSBzdHJlYW1cblx0XHQgICAgICAgICAqIHN1Y2Nlc3NmdWxseSBjbG9zZXMsIG9yIHJlamVjdHMgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgZHVyaW5nIHRoaXMgcHJvY2Vzcy4gQWRkaXRpb25hbGx5LCBpdCB3aWxsIHJlamVjdCB3aXRoXG5cdFx0ICAgICAgICAgKiBhIGBUeXBlRXJyb3JgICh3aXRob3V0IGF0dGVtcHRpbmcgdG8gY2FuY2VsIHRoZSBzdHJlYW0pIGlmIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGxvY2tlZC5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgY2xvc2UoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMignY2xvc2UnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgd3JpdGVyJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW0nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUNsb3NlKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBDcmVhdGVzIGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciB8IHdyaXRlcn0gYW5kIGxvY2tzIHRoZSBzdHJlYW0gdG8gdGhlIG5ldyB3cml0ZXIuIFdoaWxlIHRoZSBzdHJlYW1cblx0XHQgICAgICAgICAqIGlzIGxvY2tlZCwgbm8gb3RoZXIgd3JpdGVyIGNhbiBiZSBhY3F1aXJlZCB1bnRpbCB0aGlzIG9uZSBpcyByZWxlYXNlZC5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIGNyZWF0aW5nIGFic3RyYWN0aW9ucyB0aGF0IGRlc2lyZSB0aGUgYWJpbGl0eSB0byB3cml0ZSB0byBhIHN0cmVhbVxuXHRcdCAgICAgICAgICogd2l0aG91dCBpbnRlcnJ1cHRpb24gb3IgaW50ZXJsZWF2aW5nLiBCeSBnZXR0aW5nIGEgd3JpdGVyIGZvciB0aGUgc3RyZWFtLCB5b3UgY2FuIGVuc3VyZSBub2JvZHkgZWxzZSBjYW4gd3JpdGUgYXRcblx0XHQgICAgICAgICAqIHRoZSBzYW1lIHRpbWUsIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSByZXN1bHRpbmcgd3JpdHRlbiBkYXRhIHRvIGJlIHVucHJlZGljdGFibGUgYW5kIHByb2JhYmx5IHVzZWxlc3MuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldFdyaXRlcigpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdnZXRXcml0ZXInKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLCB7XG5cdFx0ICAgICAgICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBnZXRXcml0ZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgbG9ja2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbScsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW0uXG5cdFx0ICAgIGZ1bmN0aW9uIEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoc3RyZWFtKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcihzdHJlYW0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG5cdFx0ICAgIGZ1bmN0aW9uIENyZWF0ZVdyaXRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrID0gMSwgc2l6ZUFsZ29yaXRobSA9ICgpID0+IDEpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlKTtcblx0XHQgICAgICAgIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbShzdHJlYW0pO1xuXHRcdCAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuXHRcdCAgICAgICAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuXHRcdCAgICAgICAgcmV0dXJuIHN0cmVhbTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0oc3RyZWFtKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ3dyaXRhYmxlJztcblx0XHQgICAgICAgIC8vIFRoZSBlcnJvciB0aGF0IHdpbGwgYmUgcmVwb3J0ZWQgYnkgbmV3IG1ldGhvZCBjYWxscyBvbmNlIHRoZSBzdGF0ZSBiZWNvbWVzIGVycm9yZWQuIE9ubHkgc2V0IHdoZW4gW1tzdGF0ZV1dIGlzXG5cdFx0ICAgICAgICAvLyAnZXJyb3JpbmcnIG9yICdlcnJvcmVkJy4gTWF5IGJlIHNldCB0byBhbiB1bmRlZmluZWQgdmFsdWUuXG5cdFx0ICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgc3RyZWFtLl93cml0ZXIgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAvLyBJbml0aWFsaXplIHRvIHVuZGVmaW5lZCBmaXJzdCBiZWNhdXNlIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgY29udHJvbGxlciBjaGVja3MgdGhpc1xuXHRcdCAgICAgICAgLy8gdmFyaWFibGUgdG8gdmFsaWRhdGUgdGhlIGNhbGxlci5cblx0XHQgICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgLy8gVGhpcyBxdWV1ZSBpcyBwbGFjZWQgaGVyZSBpbnN0ZWFkIG9mIHRoZSB3cml0ZXIgY2xhc3MgaW4gb3JkZXIgdG8gYWxsb3cgZm9yIHBhc3NpbmcgYSB3cml0ZXIgdG8gdGhlIG5leHQgZGF0YVxuXHRcdCAgICAgICAgLy8gcHJvZHVjZXIgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgcXVldWVkIHdyaXRlcyB0byBmaW5pc2guXG5cdFx0ICAgICAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcblx0XHQgICAgICAgIC8vIFdyaXRlIHJlcXVlc3RzIGFyZSByZW1vdmVkIGZyb20gX3dyaXRlUmVxdWVzdHMgd2hlbiB3cml0ZSgpIGlzIGNhbGxlZCBvbiB0aGUgdW5kZXJseWluZyBzaW5rLiBUaGlzIHByZXZlbnRzXG5cdFx0ICAgICAgICAvLyB0aGVtIGZyb20gYmVpbmcgZXJyb25lb3VzbHkgcmVqZWN0ZWQgb24gZXJyb3IuIElmIGEgd3JpdGUoKSBjYWxsIGlzIGluLWZsaWdodCwgdGhlIHJlcXVlc3QgaXMgc3RvcmVkIGhlcmUuXG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgLy8gVGhlIHByb21pc2UgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB3cml0ZXIuY2xvc2UoKS4gU3RvcmVkIGhlcmUgYmVjYXVzZSBpdCBtYXkgYmUgZnVsZmlsbGVkIGFmdGVyIHRoZSB3cml0ZXJcblx0XHQgICAgICAgIC8vIGhhcyBiZWVuIGRldGFjaGVkLlxuXHRcdCAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAvLyBDbG9zZSByZXF1ZXN0IGlzIHJlbW92ZWQgZnJvbSBfY2xvc2VSZXF1ZXN0IHdoZW4gY2xvc2UoKSBpcyBjYWxsZWQgb24gdGhlIHVuZGVybHlpbmcgc2luay4gVGhpcyBwcmV2ZW50cyBpdFxuXHRcdCAgICAgICAgLy8gZnJvbSBiZWluZyBlcnJvbmVvdXNseSByZWplY3RlZCBvbiBlcnJvci4gSWYgYSBjbG9zZSgpIGNhbGwgaXMgaW4tZmxpZ2h0LCB0aGUgcmVxdWVzdCBpcyBzdG9yZWQgaGVyZS5cblx0XHQgICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAvLyBUaGUgcHJvbWlzZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHdyaXRlci5hYm9ydCgpLiBUaGlzIG1heSBhbHNvIGJlIGZ1bGZpbGxlZCBhZnRlciB0aGUgd3JpdGVyIGhhcyBkZXRhY2hlZC5cblx0XHQgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIC8vIFRoZSBiYWNrcHJlc3N1cmUgc2lnbmFsIHNldCBieSB0aGUgY29udHJvbGxlci5cblx0XHQgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gZmFsc2U7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbSh4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl93cml0ZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQWJvcnQoc3RyZWFtLCByZWFzb24pIHtcblx0XHQgICAgICAgIHZhciBfYTtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIuX2Fib3J0UmVhc29uID0gcmVhc29uO1xuXHRcdCAgICAgICAgKF9hID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIuX2Fib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0KCk7XG5cdFx0ICAgICAgICAvLyBUeXBlU2NyaXB0IG5hcnJvd3MgdGhlIHR5cGUgb2YgYHN0cmVhbS5fc3RhdGVgIGRvd24gdG8gJ3dyaXRhYmxlJyB8ICdlcnJvcmluZycsXG5cdFx0ICAgICAgICAvLyBidXQgaXQgZG9lc24ndCBrbm93IHRoYXQgc2lnbmFsaW5nIGFib3J0IHJ1bnMgYXV0aG9yIGNvZGUgdGhhdCBtaWdodCBoYXZlIGNoYW5nZWQgdGhlIHN0YXRlLlxuXHRcdCAgICAgICAgLy8gV2lkZW4gdGhlIHR5cGUgYWdhaW4gYnkgY2FzdGluZyB0byBXcml0YWJsZVN0cmVhbVN0YXRlLlxuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Byb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBsZXQgd2FzQWxyZWFkeUVycm9yaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcblx0XHQgICAgICAgICAgICB3YXNBbHJlYWR5RXJyb3JpbmcgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIC8vIHJlYXNvbiB3aWxsIG5vdCBiZSB1c2VkLCBzbyBkb24ndCBrZWVwIGEgcmVmZXJlbmNlIHRvIGl0LlxuXHRcdCAgICAgICAgICAgIHJlYXNvbiA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB7XG5cdFx0ICAgICAgICAgICAgICAgIF9wcm9taXNlOiB1bmRlZmluZWQsXG5cdFx0ICAgICAgICAgICAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuXHRcdCAgICAgICAgICAgICAgICBfcmVqZWN0OiByZWplY3QsXG5cdFx0ICAgICAgICAgICAgICAgIF9yZWFzb246IHJlYXNvbixcblx0XHQgICAgICAgICAgICAgICAgX3dhc0FscmVhZHlFcnJvcmluZzogd2FzQWxyZWFkeUVycm9yaW5nXG5cdFx0ICAgICAgICAgICAgfTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9wcm9taXNlID0gcHJvbWlzZTtcblx0XHQgICAgICAgIGlmICghd2FzQWxyZWFkeUVycm9yaW5nKSB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnIHx8IHN0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSB3cml0YWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQgICAgICAgICAgICBjb25zdCBjbG9zZVJlcXVlc3QgPSB7XG5cdFx0ICAgICAgICAgICAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuXHRcdCAgICAgICAgICAgICAgICBfcmVqZWN0OiByZWplY3Rcblx0XHQgICAgICAgICAgICB9O1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gY2xvc2VSZXF1ZXN0O1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcblx0XHQgICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCAmJiBzdHJlYW0uX2JhY2twcmVzc3VyZSAmJiBzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2Uoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gV3JpdGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUFkZFdyaXRlUmVxdWVzdChzdHJlYW0pIHtcblx0XHQgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQgICAgICAgICAgICBjb25zdCB3cml0ZVJlcXVlc3QgPSB7XG5cdFx0ICAgICAgICAgICAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuXHRcdCAgICAgICAgICAgICAgICBfcmVqZWN0OiByZWplY3Rcblx0XHQgICAgICAgICAgICB9O1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5wdXNoKHdyaXRlUmVxdWVzdCk7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgZXJyb3IpO1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCByZWFzb24pIHtcblx0XHQgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtcblx0XHQgICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JpbmcnO1xuXHRcdCAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcblx0XHQgICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuXHRcdCAgICAgICAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbSkgJiYgY29udHJvbGxlci5fc3RhcnRlZCkge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSkge1xuXHRcdCAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmVkJztcblx0XHQgICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Vycm9yU3RlcHNdKCk7XG5cdFx0ICAgICAgICBjb25zdCBzdG9yZWRFcnJvciA9IHN0cmVhbS5fc3RvcmVkRXJyb3I7XG5cdFx0ICAgICAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMuZm9yRWFjaCh3cml0ZVJlcXVlc3QgPT4ge1xuXHRcdCAgICAgICAgICAgIHdyaXRlUmVxdWVzdC5fcmVqZWN0KHN0b3JlZEVycm9yKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgYWJvcnRSZXF1ZXN0ID0gc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0O1xuXHRcdCAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgaWYgKGFib3J0UmVxdWVzdC5fd2FzQWxyZWFkeUVycm9yaW5nKSB7XG5cdFx0ICAgICAgICAgICAgYWJvcnRSZXF1ZXN0Ll9yZWplY3Qoc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBwcm9taXNlID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbQWJvcnRTdGVwc10oYWJvcnRSZXF1ZXN0Ll9yZWFzb24pO1xuXHRcdCAgICAgICAgdXBvblByb21pc2UocHJvbWlzZSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgIGFib3J0UmVxdWVzdC5fcmVzb2x2ZSgpO1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcblx0XHQgICAgICAgIH0sIChyZWFzb24pID0+IHtcblx0XHQgICAgICAgICAgICBhYm9ydFJlcXVlc3QuX3JlamVjdChyZWFzb24pO1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZShzdHJlYW0pIHtcblx0XHQgICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QuX3Jlc29sdmUodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yKHN0cmVhbSwgZXJyb3IpIHtcblx0XHQgICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QuX3JlamVjdChlcnJvcik7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2Uoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZXNvbHZlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG5cdFx0ICAgICAgICAgICAgLy8gVGhlIGVycm9yIHdhcyB0b28gbGF0ZSB0byBkbyBhbnl0aGluZywgc28gaXQgaXMgaWdub3JlZC5cblx0XHQgICAgICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Jlc29sdmUoKTtcblx0XHQgICAgICAgICAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnY2xvc2VkJztcblx0XHQgICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuXHRcdCAgICAgICAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yKHN0cmVhbSwgZXJyb3IpIHtcblx0XHQgICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QuX3JlamVjdChlcnJvcik7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgLy8gTmV2ZXIgZXhlY3V0ZSBzaW5rIGFib3J0KCkgYWZ0ZXIgc2luayBjbG9zZSgpLlxuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcik7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gVE9ETyhyaWNlYSk6IEZpeCBhbHBoYWJldGljYWwgb3JkZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkge1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodChzdHJlYW0pIHtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID09PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gc3RyZWFtLl9jbG9zZVJlcXVlc3Q7XG5cdFx0ICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbU1hcmtGaXJzdFdyaXRlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSkge1xuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5zaGlmdCgpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9jbG9zZVJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0Ll9yZWplY3Qoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcblx0XHQgICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpIHtcblx0XHQgICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuXHRcdCAgICAgICAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkICYmIGJhY2twcmVzc3VyZSAhPT0gc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcblx0XHQgICAgICAgICAgICBpZiAoYmFja3ByZXNzdXJlKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXIpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGJhY2twcmVzc3VyZTtcblx0XHQgICAgfVxuXHRcdCAgICAvKipcblx0XHQgICAgICogQSBkZWZhdWx0IHdyaXRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgV3JpdGFibGVTdHJlYW19LlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXInKTtcblx0XHQgICAgICAgICAgICBhc3NlcnRXcml0YWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgd3JpdGluZyBieSBhbm90aGVyIHdyaXRlcicpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID0gc3RyZWFtO1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fd3JpdGVyID0gdGhpcztcblx0XHQgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuXHRcdCAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcblx0XHQgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcblx0XHQgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHRoaXMsIHN0b3JlZEVycm9yKTtcblx0XHQgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCwgb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvclxuXHRcdCAgICAgICAgICogdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgY2xvc2VkKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBzdHJlYW3igJlzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpcyBvdmVyLWZ1bGwuXG5cdFx0ICAgICAgICAgKiBBIHByb2R1Y2VyIGNhbiB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgdGhlIHJpZ2h0IGFtb3VudCBvZiBkYXRhIHRvIHdyaXRlLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIEl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZSBzdHJlYW0gY2Fubm90IGJlIHN1Y2Nlc3NmdWxseSB3cml0dGVuIHRvIChkdWUgdG8gZWl0aGVyIGJlaW5nIGVycm9yZWQsIG9yIGhhdmluZyBhbiBhYm9ydFxuXHRcdCAgICAgICAgICogcXVldWVkIHVwKS4gSXQgd2lsbCByZXR1cm4gemVybyBpZiB0aGUgc3RyZWFtIGlzIGNsb3NlZC4gQW5kIHRoZSBnZXR0ZXIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgaW52b2tlZCB3aGVuXG5cdFx0ICAgICAgICAgKiB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgZGVzaXJlZFNpemUoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBzdHJlYW3igJlzIGludGVybmFsIHF1ZXVlIHRyYW5zaXRpb25zXG5cdFx0ICAgICAgICAgKiBmcm9tIG5vbi1wb3NpdGl2ZSB0byBwb3NpdGl2ZSwgc2lnbmFsaW5nIHRoYXQgaXQgaXMgbm8gbG9uZ2VyIGFwcGx5aW5nIGJhY2twcmVzc3VyZS4gT25jZSB0aGUgZGVzaXJlZCBzaXplIGRpcHNcblx0XHQgICAgICAgICAqIGJhY2sgdG8gemVybyBvciBiZWxvdywgdGhlIGdldHRlciB3aWxsIHJldHVybiBhIG5ldyBwcm9taXNlIHRoYXQgc3RheXMgcGVuZGluZyB1bnRpbCB0aGUgbmV4dCB0cmFuc2l0aW9uLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIElmIHRoZSBzdHJlYW0gYmVjb21lcyBlcnJvcmVkIG9yIGFib3J0ZWQsIG9yIHRoZSB3cml0ZXLigJlzIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmVjb21lXG5cdFx0ICAgICAgICAgKiByZWplY3RlZC5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IHJlYWR5KCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWR5JykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHlQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgV3JpdGFibGVTdHJlYW0uYWJvcnQgfCBzdHJlYW0uYWJvcnQocmVhc29uKX0uXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGFib3J0KHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Fib3J0JykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdhYm9ydCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0KHRoaXMsIHJlYXNvbik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBXcml0YWJsZVN0cmVhbS5jbG9zZSB8IHN0cmVhbS5jbG9zZSgpfS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgY2xvc2UoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW07XG5cdFx0ICAgICAgICAgICAgaWYgKHN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdjbG9zZScpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW0nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmVsZWFzZXMgdGhlIHdyaXRlcuKAmXMgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgd3JpdGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXG5cdFx0ICAgICAgICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgd3JpdGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5IGZyb21cblx0XHQgICAgICAgICAqIG5vdyBvbjsgb3RoZXJ3aXNlLCB0aGUgd3JpdGVyIHdpbGwgYXBwZWFyIGNsb3NlZC5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGxvY2sgY2FuIHN0aWxsIGJlIHJlbGVhc2VkIGV2ZW4gaWYgc29tZSBvbmdvaW5nIHdyaXRlcyBoYXZlIG5vdCB5ZXQgZmluaXNoZWQgKGkuZS4gZXZlbiBpZiB0aGVcblx0XHQgICAgICAgICAqIHByb21pc2VzIHJldHVybmVkIGZyb20gcHJldmlvdXMgY2FsbHMgdG8ge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci53cml0ZSB8IHdyaXRlKCl9IGhhdmUgbm90IHlldCBzZXR0bGVkKS5cblx0XHQgICAgICAgICAqIEl04oCZcyBub3QgbmVjZXNzYXJ5IHRvIGhvbGQgdGhlIGxvY2sgb24gdGhlIHdyaXRlciBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSB3cml0ZTsgdGhlIGxvY2sgaW5zdGVhZCBzaW1wbHkgcHJldmVudHNcblx0XHQgICAgICAgICAqIG90aGVyIHByb2R1Y2VycyBmcm9tIHdyaXRpbmcgaW4gYW4gaW50ZXJsZWF2ZWQgbWFubmVyLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICByZWxlYXNlTG9jaygpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICB3cml0ZShjaHVuayA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3dyaXRlJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCd3cml0ZSB0bycpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHRoaXMsIGNodW5rKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCB7XG5cdFx0ICAgICAgICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICB3cml0ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcmVhZHk6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXInLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5cblx0XHQgICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoeCkge1xuXHRcdCAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX293bmVyV3JpdGFibGVTdHJlYW0nKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEEgY2xpZW50IG9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0KHdyaXRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG5cdFx0ICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydChzdHJlYW0sIHJlYXNvbik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2Uod3JpdGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG5cdFx0ICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24od3JpdGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB8fCBzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh3cml0ZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCh3cml0ZXIsIGVycm9yKSB7XG5cdFx0ICAgICAgICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJykge1xuXHRcdCAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgZXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCBlcnJvcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCBlcnJvcikge1xuXHRcdCAgICAgICAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJykge1xuXHRcdCAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3Qod3JpdGVyLCBlcnJvcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgZXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplKHdyaXRlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmluZycpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gMDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2Uod3JpdGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBjb25zdCByZWxlYXNlZEVycm9yID0gbmV3IFR5cGVFcnJvcihgV3JpdGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKTtcblx0XHQgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVsZWFzZWRFcnJvcik7XG5cdFx0ICAgICAgICAvLyBUaGUgc3RhdGUgdHJhbnNpdGlvbnMgdG8gXCJlcnJvcmVkXCIgYmVmb3JlIHRoZSBzaW5rIGFib3J0KCkgbWV0aG9kIHJ1bnMsIGJ1dCB0aGUgd3JpdGVyLmNsb3NlZCBwcm9taXNlIGlzIG5vdFxuXHRcdCAgICAgICAgLy8gcmVqZWN0ZWQgdW50aWwgYWZ0ZXJ3YXJkcy4gVGhpcyBtZWFucyB0aGF0IHNpbXBseSB0ZXN0aW5nIHN0YXRlIHdpbGwgbm90IHdvcmsuXG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWxlYXNlZEVycm9yKTtcblx0XHQgICAgICAgIHN0cmVhbS5fd3JpdGVyID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtID0gdW5kZWZpbmVkO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHdyaXRlciwgY2h1bmspIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcblx0XHQgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtcblx0XHQgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemUoY29udHJvbGxlciwgY2h1bmspO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbSAhPT0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ3dyaXRlIHRvJykpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHx8IHN0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgY2xvc2luZyBvciBjbG9zZWQgYW5kIGNhbm5vdCBiZSB3cml0dGVuIHRvJykpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBwcm9taXNlID0gV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3Qoc3RyZWFtKTtcblx0XHQgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcblx0XHQgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IGNsb3NlU2VudGluZWwgPSB7fTtcblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtIHwgd3JpdGFibGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciB7XG5cdFx0ICAgICAgICBjb25zdHJ1Y3RvcigpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFRoZSByZWFzb24gd2hpY2ggd2FzIHBhc3NlZCB0byBgV3JpdGFibGVTdHJlYW0uYWJvcnQocmVhc29uKWAgd2hlbiB0aGUgc3RyZWFtIHdhcyBhYm9ydGVkLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIEBkZXByZWNhdGVkXG5cdFx0ICAgICAgICAgKiAgVGhpcyBwcm9wZXJ0eSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHNwZWNpZmljYXRpb24sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3N0cmVhbXMvcHVsbC8xMTc3LlxuXHRcdCAgICAgICAgICogIFVzZSB7QGxpbmsgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5zaWduYWx9J3MgYHJlYXNvbmAgaW5zdGVhZC5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGFib3J0UmVhc29uKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdhYm9ydFJlYXNvbicpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJvcnRSZWFzb247XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIEFuIGBBYm9ydFNpZ25hbGAgdGhhdCBjYW4gYmUgdXNlZCB0byBhYm9ydCB0aGUgcGVuZGluZyB3cml0ZSBvciBjbG9zZSBvcGVyYXRpb24gd2hlbiB0aGUgc3RyZWFtIGlzIGFib3J0ZWQuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCBzaWduYWwoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIoJ3NpZ25hbCcpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fYWJvcnRDb250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgLy8gT2xkZXIgYnJvd3NlcnMgb3Igb2xkZXIgTm9kZSB2ZXJzaW9ucyBtYXkgbm90IHN1cHBvcnQgYEFib3J0Q29udHJvbGxlcmAgb3IgYEFib3J0U2lnbmFsYC5cblx0XHQgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBidW5kbGUgYW5kIHNoaXAgYW4gYEFib3J0Q29udHJvbGxlcmAgcG9seWZpbGwgdG9nZXRoZXIgd2l0aCBvdXIgcG9seWZpbGwsXG5cdFx0ICAgICAgICAgICAgICAgIC8vIHNvIGluc3RlYWQgd2Ugb25seSBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgYHNpZ25hbGAgaWYgd2UgZmluZCBhIGdsb2JhbCBgQWJvcnRDb250cm9sbGVyYCBjb25zdHJ1Y3Rvci5cblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuc2lnbmFsIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0Q29udHJvbGxlci5zaWduYWw7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCB3cml0YWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHJhcmVseSB1c2VkLCBzaW5jZSB1c3VhbGx5IGl0IHN1ZmZpY2VzIHRvIHJldHVybiBhIHJlamVjdGVkIHByb21pc2UgZnJvbSBvbmUgb2YgdGhlIHVuZGVybHlpbmdcblx0XHQgICAgICAgICAqIHNpbmsncyBtZXRob2RzLiBIb3dldmVyLCBpdCBjYW4gYmUgdXNlZnVsIGZvciBzdWRkZW5seSBzaHV0dGluZyBkb3duIGEgc3RyZWFtIGluIHJlc3BvbnNlIHRvIGFuIGV2ZW50IG91dHNpZGUgdGhlXG5cdFx0ICAgICAgICAgKiBub3JtYWwgbGlmZWN5Y2xlIG9mIGludGVyYWN0aW9ucyB3aXRoIHRoZSB1bmRlcmx5aW5nIHNpbmsuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGVycm9yKGUgPSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMignZXJyb3InKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gJ3dyaXRhYmxlJykge1xuXHRcdCAgICAgICAgICAgICAgICAvLyBUaGUgc3RyZWFtIGlzIGNsb3NlZCwgZXJyb3JlZCBvciB3aWxsIGJlIHNvb24uIFRoZSBzaW5rIGNhbid0IGRvIGFueXRoaW5nIHVzZWZ1bCBpZiBpdCBnZXRzIGFuIGVycm9yIGhlcmUsIHNvXG5cdFx0ICAgICAgICAgICAgICAgIC8vIGp1c3QgdHJlYXQgaXQgYXMgYSBuby1vcC5cblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgZSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKiogQGludGVybmFsICovXG5cdFx0ICAgICAgICBbQWJvcnRTdGVwc10ocmVhc29uKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fYWJvcnRBbGdvcml0aG0ocmVhc29uKTtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKiogQGludGVybmFsICovXG5cdFx0ICAgICAgICBbRXJyb3JTdGVwc10oKSB7XG5cdFx0ICAgICAgICAgICAgUmVzZXRRdWV1ZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgYWJvcnRSZWFzb246IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgc2lnbmFsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBpbXBsZW1lbnRpbmcgaW50ZXJmYWNlIHJlcXVpcmVkIGJ5IHRoZSBXcml0YWJsZVN0cmVhbS5cblx0XHQgICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkV3JpdGFibGVTdHJlYW0nKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtID0gc3RyZWFtO1xuXHRcdCAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXHRcdCAgICAgICAgLy8gTmVlZCB0byBzZXQgdGhlIHNsb3RzIHNvIHRoYXQgdGhlIGFzc2VydCBkb2Vzbid0IGZpcmUuIEluIHRoZSBzcGVjIHRoZSBzbG90cyBhbHJlYWR5IGV4aXN0IGltcGxpY2l0bHkuXG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9xdWV1ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2Fib3J0UmVhc29uID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKCk7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSBzaXplQWxnb3JpdGhtO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB3cml0ZUFsZ29yaXRobTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtID0gY2xvc2VBbGdvcml0aG07XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IGFib3J0QWxnb3JpdGhtO1xuXHRcdCAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcblx0XHQgICAgICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcblx0XHQgICAgICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpO1xuXHRcdCAgICAgICAgdXBvblByb21pc2Uoc3RhcnRQcm9taXNlLCAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfSwgciA9PiB7XG5cdFx0ICAgICAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIHIpO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rKHN0cmVhbSwgdW5kZXJseWluZ1NpbmssIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcblx0XHQgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblx0XHQgICAgICAgIGxldCBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGxldCB3cml0ZUFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIGxldCBjbG9zZUFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIGxldCBhYm9ydEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIGlmICh1bmRlcmx5aW5nU2luay5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU2luay5zdGFydChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh1bmRlcmx5aW5nU2luay53cml0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgd3JpdGVBbGdvcml0aG0gPSBjaHVuayA9PiB1bmRlcmx5aW5nU2luay53cml0ZShjaHVuaywgY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ1NpbmsuY2xvc2UgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGNsb3NlQWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NpbmsuY2xvc2UoKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh1bmRlcmx5aW5nU2luay5hYm9ydCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ1NpbmsuYWJvcnQocmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBDbGVhckFsZ29yaXRobXMgbWF5IGJlIGNhbGxlZCB0d2ljZS4gRXJyb3JpbmcgdGhlIHNhbWUgc3RyZWFtIGluIG11bHRpcGxlIHdheXMgd2lsbCBvZnRlbiByZXN1bHQgaW4gcmVkdW5kYW50IGNhbGxzLlxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2xvc2VTZW50aW5lbCwgMCk7XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldENodW5rU2l6ZShjb250cm9sbGVyLCBjaHVuaykge1xuXHRcdCAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNhdGNoIChjaHVua1NpemVFKSB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgY2h1bmtTaXplRSk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIDE7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneUhXTSAtIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKSB7XG5cdFx0ICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY2F0Y2ggKGVucXVldWVFKSB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgZW5xdWV1ZUUpO1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcblx0XHQgICAgICAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pO1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCB2YWx1ZSA9IFBlZWtRdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgaWYgKHZhbHVlID09PSBjbG9zZVNlbnRpbmVsKSB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NDbG9zZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzV3JpdGUoY29udHJvbGxlciwgdmFsdWUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGVycm9yKSB7XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlcnJvcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NDbG9zZShjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pO1xuXHRcdCAgICAgICAgRGVxdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgY29uc3Qgc2lua0Nsb3NlUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgdXBvblByb21pc2Uoc2lua0Nsb3NlUHJvbWlzZSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZShzdHJlYW0pO1xuXHRcdCAgICAgICAgfSwgcmVhc29uID0+IHtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3Ioc3RyZWFtLCByZWFzb24pO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZShjb250cm9sbGVyLCBjaHVuaykge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pO1xuXHRcdCAgICAgICAgY29uc3Qgc2lua1dyaXRlUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtKGNodW5rKTtcblx0XHQgICAgICAgIHVwb25Qcm9taXNlKHNpbmtXcml0ZVByb21pc2UsICgpID0+IHtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUoc3RyZWFtKTtcblx0XHQgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICAgICAgRGVxdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH0sIHJlYXNvbiA9PiB7XG5cdFx0ICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcblx0XHQgICAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3QgZGVzaXJlZFNpemUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICByZXR1cm4gZGVzaXJlZFNpemUgPD0gMDtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBIGNsaWVudCBvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGVycm9yKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgZXJyb3IpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbS5cblx0XHQgICAgZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1gKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIobmFtZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLlxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJgKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQ2Fubm90ICcgKyBuYW1lICsgJyBhIHN0cmVhbSB1c2luZyBhIHJlbGVhc2VkIHdyaXRlcicpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpIHtcblx0XHQgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdCAgICAgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHQgICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuXHRcdCAgICAgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gJ3BlbmRpbmcnO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuXHRcdCAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG5cdFx0ICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXIpIHtcblx0XHQgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuXHRcdCAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pIHtcblx0XHQgICAgICAgIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHdyaXRlci5fY2xvc2VkUHJvbWlzZSk7XG5cdFx0ICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG5cdFx0ICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcblx0XHQgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpIHtcblx0XHQgICAgICAgIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gJ3Jlc29sdmVkJztcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpIHtcblx0XHQgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0ICAgICAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ3BlbmRpbmcnO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuXHRcdCAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcblx0XHQgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXIpIHtcblx0XHQgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG5cdFx0ICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pIHtcblx0XHQgICAgICAgIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUod3JpdGVyLl9yZWFkeVByb21pc2UpO1xuXHRcdCAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0KHJlYXNvbik7XG5cdFx0ICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0KHdyaXRlcikge1xuXHRcdCAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcikge1xuXHRcdCAgICAgICAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ2Z1bGZpbGxlZCc7XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuXHRcdCAgICBjb25zdCBOYXRpdmVET01FeGNlcHRpb24gPSB0eXBlb2YgRE9NRXhjZXB0aW9uICE9PSAndW5kZWZpbmVkJyA/IERPTUV4Y2VwdGlvbiA6IHVuZGVmaW5lZDtcblxuXHRcdCAgICAvLy8gPHJlZmVyZW5jZSB0eXBlcz1cIm5vZGVcIiAvPlxuXHRcdCAgICBmdW5jdGlvbiBpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKGN0b3IpIHtcblx0XHQgICAgICAgIGlmICghKHR5cGVvZiBjdG9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjdG9yID09PSAnb2JqZWN0JykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgIG5ldyBjdG9yKCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjYXRjaCAoX2EpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY3JlYXRlRE9NRXhjZXB0aW9uUG9seWZpbGwoKSB7XG5cdFx0ICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cdFx0ICAgICAgICBjb25zdCBjdG9yID0gZnVuY3Rpb24gRE9NRXhjZXB0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcblx0XHQgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xuXHRcdCAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJ0Vycm9yJztcblx0XHQgICAgICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcblx0XHQgICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCB7IHZhbHVlOiBjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXHRcdCAgICAgICAgcmV0dXJuIGN0b3I7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXHRcdCAgICBjb25zdCBET01FeGNlcHRpb24kMSA9IGlzRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IoTmF0aXZlRE9NRXhjZXB0aW9uKSA/IE5hdGl2ZURPTUV4Y2VwdGlvbiA6IGNyZWF0ZURPTUV4Y2VwdGlvblBvbHlmaWxsKCk7XG5cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1QaXBlVG8oc291cmNlLCBkZXN0LCBwcmV2ZW50Q2xvc2UsIHByZXZlbnRBYm9ydCwgcHJldmVudENhbmNlbCwgc2lnbmFsKSB7XG5cdFx0ICAgICAgICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHNvdXJjZSk7XG5cdFx0ICAgICAgICBjb25zdCB3cml0ZXIgPSBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKGRlc3QpO1xuXHRcdCAgICAgICAgc291cmNlLl9kaXN0dXJiZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgbGV0IHNodXR0aW5nRG93biA9IGZhbHNlO1xuXHRcdCAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHNwZWMncyByZXF1aXJlbWVudCB0aGF0IHdlIHdhaXQgZm9yIG9uZ29pbmcgd3JpdGVzIGR1cmluZyBzaHV0ZG93bi5cblx0XHQgICAgICAgIGxldCBjdXJyZW50V3JpdGUgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgbGV0IGFib3J0QWxnb3JpdGhtO1xuXHRcdCAgICAgICAgICAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICBhYm9ydEFsZ29yaXRobSA9ICgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IERPTUV4Y2VwdGlvbiQxKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICghcHJldmVudEFib3J0KSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKCgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydChkZXN0LCBlcnJvcik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCgoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuX3N0YXRlID09PSAncmVhZGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBlcnJvcik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBQcm9taXNlLmFsbChhY3Rpb25zLm1hcChhY3Rpb24gPT4gYWN0aW9uKCkpKSwgdHJ1ZSwgZXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICB9O1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGFib3J0QWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbGdvcml0aG0pO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAvLyBVc2luZyByZWFkZXIgYW5kIHdyaXRlciwgcmVhZCBhbGwgY2h1bmtzIGZyb20gdGhpcyBhbmQgd3JpdGUgdGhlbSB0byBkZXN0XG5cdFx0ICAgICAgICAgICAgLy8gLSBCYWNrcHJlc3N1cmUgbXVzdCBiZSBlbmZvcmNlZFxuXHRcdCAgICAgICAgICAgIC8vIC0gU2h1dGRvd24gbXVzdCBzdG9wIGFsbCBhY3Rpdml0eVxuXHRcdCAgICAgICAgICAgIGZ1bmN0aW9uIHBpcGVMb29wKCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3UHJvbWlzZSgocmVzb2x2ZUxvb3AsIHJlamVjdExvb3ApID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG5leHQoZG9uZSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVMb29wKCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYFBlcmZvcm1Qcm9taXNlVGhlbmAgaW5zdGVhZCBvZiBgdXBvblByb21pc2VgIHRvIGF2b2lkXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGluZyB1bm5lY2Vzc2FyeSBgLmNhdGNoKHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbilgIGhhbmRsZXJzXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihwaXBlU3RlcCgpLCBuZXh0LCByZWplY3RMb29wKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBuZXh0KGZhbHNlKTtcblx0XHQgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGZ1bmN0aW9uIHBpcGVTdGVwKCkge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh0cnVlKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gUGVyZm9ybVByb21pc2VUaGVuKHdyaXRlci5fcmVhZHlQcm9taXNlLCAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3UHJvbWlzZSgocmVzb2x2ZVJlYWQsIHJlamVjdFJlYWQpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdyaXRlID0gUGVyZm9ybVByb21pc2VUaGVuKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHdyaXRlciwgY2h1bmspLCB1bmRlZmluZWQsIG5vb3ApO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVJlYWQoZmFsc2UpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4gcmVzb2x2ZVJlYWQodHJ1ZSksXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiByZWplY3RSZWFkXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIC8vIEVycm9ycyBtdXN0IGJlIHByb3BhZ2F0ZWQgZm9yd2FyZFxuXHRcdCAgICAgICAgICAgIGlzT3JCZWNvbWVzRXJyb3JlZChzb3VyY2UsIHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgc3RvcmVkRXJyb3IgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRBYm9ydCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgc3RvcmVkRXJyb3IpLCB0cnVlLCBzdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bih0cnVlLCBzdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICAvLyBFcnJvcnMgbXVzdCBiZSBwcm9wYWdhdGVkIGJhY2t3YXJkXG5cdFx0ICAgICAgICAgICAgaXNPckJlY29tZXNFcnJvcmVkKGRlc3QsIHdyaXRlci5fY2xvc2VkUHJvbWlzZSwgc3RvcmVkRXJyb3IgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgLy8gQ2xvc2luZyBtdXN0IGJlIHByb3BhZ2F0ZWQgZm9yd2FyZFxuXHRcdCAgICAgICAgICAgIGlzT3JCZWNvbWVzQ2xvc2VkKHNvdXJjZSwgcmVhZGVyLl9jbG9zZWRQcm9taXNlLCAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmICghcHJldmVudENsb3NlKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbih3cml0ZXIpKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHNodXRkb3duKCk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICAvLyBDbG9zaW5nIG11c3QgYmUgcHJvcGFnYXRlZCBiYWNrd2FyZFxuXHRcdCAgICAgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSB8fCBkZXN0Ll9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgZGVzdENsb3NlZCA9IG5ldyBUeXBlRXJyb3IoJ3RoZSBkZXN0aW5hdGlvbiB3cml0YWJsZSBzdHJlYW0gY2xvc2VkIGJlZm9yZSBhbGwgZGF0YSBjb3VsZCBiZSBwaXBlZCB0byBpdCcpO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIGRlc3RDbG9zZWQpLCB0cnVlLCBkZXN0Q2xvc2VkKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHNodXRkb3duKHRydWUsIGRlc3RDbG9zZWQpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocGlwZUxvb3AoKSk7XG5cdFx0ICAgICAgICAgICAgZnVuY3Rpb24gd2FpdEZvcldyaXRlc1RvRmluaXNoKCkge1xuXHRcdCAgICAgICAgICAgICAgICAvLyBBbm90aGVyIHdyaXRlIG1heSBoYXZlIHN0YXJ0ZWQgd2hpbGUgd2Ugd2VyZSB3YWl0aW5nIG9uIHRoaXMgY3VycmVudFdyaXRlLCBzbyB3ZSBoYXZlIHRvIGJlIHN1cmUgdG8gd2FpdFxuXHRcdCAgICAgICAgICAgICAgICAvLyBmb3IgdGhhdCB0b28uXG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IG9sZEN1cnJlbnRXcml0ZSA9IGN1cnJlbnRXcml0ZTtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbihjdXJyZW50V3JpdGUsICgpID0+IG9sZEN1cnJlbnRXcml0ZSAhPT0gY3VycmVudFdyaXRlID8gd2FpdEZvcldyaXRlc1RvRmluaXNoKCkgOiB1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBmdW5jdGlvbiBpc09yQmVjb21lc0Vycm9yZWQoc3RyZWFtLCBwcm9taXNlLCBhY3Rpb24pIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgdXBvblJlamVjdGlvbihwcm9taXNlLCBhY3Rpb24pO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGZ1bmN0aW9uIGlzT3JCZWNvbWVzQ2xvc2VkKHN0cmVhbSwgcHJvbWlzZSwgYWN0aW9uKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uKCk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB1cG9uRnVsZmlsbG1lbnQocHJvbWlzZSwgYWN0aW9uKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBmdW5jdGlvbiBzaHV0ZG93bldpdGhBY3Rpb24oYWN0aW9uLCBvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIHNodXR0aW5nRG93biA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyAmJiAhV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHVwb25GdWxmaWxsbWVudCh3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSwgZG9UaGVSZXN0KTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGRvVGhlUmVzdCgpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvVGhlUmVzdCgpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHVwb25Qcm9taXNlKGFjdGlvbigpLCAoKSA9PiBmaW5hbGl6ZShvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpLCBuZXdFcnJvciA9PiBmaW5hbGl6ZSh0cnVlLCBuZXdFcnJvcikpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGZ1bmN0aW9uIHNodXRkb3duKGlzRXJyb3IsIGVycm9yKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBzaHV0dGluZ0Rvd24gPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScgJiYgIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksICgpID0+IGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKSk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcik7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZnVuY3Rpb24gZmluYWxpemUoaXNFcnJvciwgZXJyb3IpIHtcblx0XHQgICAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh3cml0ZXIpO1xuXHRcdCAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbGdvcml0aG0pO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvKipcblx0XHQgICAgICogQWxsb3dzIGNvbnRyb2wgb2YgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBzdHJlYW19J3Mgc3RhdGUgYW5kIGludGVybmFsIHF1ZXVlLlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIGNvbnRyb2xsZWQgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzXG5cdFx0ICAgICAgICAgKiBvdmVyLWZ1bGwuIEFuIHVuZGVybHlpbmcgc291cmNlIG91Z2h0IHRvIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGRldGVybWluZSB3aGVuIGFuZCBob3cgdG8gYXBwbHkgYmFja3ByZXNzdXJlLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgZGVzaXJlZFNpemUoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2Rlc2lyZWRTaXplJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxuXHRcdCAgICAgICAgICogdGhlIHN0cmVhbSwgYnV0IG9uY2UgdGhvc2UgYXJlIHJlYWQsIHRoZSBzdHJlYW0gd2lsbCBiZWNvbWUgY2xvc2VkLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBjbG9zZSgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnY2xvc2UnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgY2xvc2UnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZW5xdWV1ZShjaHVuayA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdlbnF1ZXVlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogRXJyb3JzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmUgaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGVycm9yKGUgPSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZXJyb3InKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIGUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuXHRcdCAgICAgICAgW0NhbmNlbFN0ZXBzXShyZWFzb24pIHtcblx0XHQgICAgICAgICAgICBSZXNldFF1ZXVlKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cblx0XHQgICAgICAgIFtQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0KSB7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gRGVxdWV1ZVZhbHVlKHRoaXMpO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQgJiYgdGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0sIHJlYWRSZXF1ZXN0KTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG5cdFx0ICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc2hvdWxkUHVsbCA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGlmICghc2hvdWxkUHVsbCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsaW5nKSB7XG5cdFx0ICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcblx0XHQgICAgICAgIGNvbnN0IHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgdXBvblByb21pc2UocHVsbFByb21pc2UsICgpID0+IHtcblx0XHQgICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxBZ2Fpbikge1xuXHRcdCAgICAgICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfSwgZSA9PiB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblx0XHQgICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFjb250cm9sbGVyLl9zdGFydGVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgZGVzaXJlZFNpemUgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBpZiAoZGVzaXJlZFNpemUgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEEgY2xpZW50IG9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IHRydWU7XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspIHtcblx0XHQgICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGZhbHNlKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIGxldCBjaHVua1NpemU7XG5cdFx0ICAgICAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICAgICAgY2h1bmtTaXplID0gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY2F0Y2ggKGNodW5rU2l6ZUUpIHtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGNodW5rU2l6ZUUpO1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBjaHVua1NpemVFO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgICAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY2F0Y2ggKGVucXVldWVFKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlbnF1ZXVlRSk7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGVucXVldWVFO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiAwO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gVGhpcyBpcyB1c2VkIGluIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBUcmFuc2Zvcm1TdHJlYW0uXG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkICYmIHN0YXRlID09PSAncmVhZGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtID0gc3RyZWFtO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcXVldWUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSBzaXplQWxnb3JpdGhtO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHB1bGxBbGdvcml0aG07XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG5cdFx0ICAgICAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfSwgciA9PiB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIHIpO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2Uoc3RyZWFtLCB1bmRlcmx5aW5nU291cmNlLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBsZXQgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBsZXQgcHVsbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIGxldCBjYW5jZWxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU291cmNlLnN0YXJ0KGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2UucHVsbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTb3VyY2UucHVsbChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh1bmRlcmx5aW5nU291cmNlLmNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgY2FuY2VsQWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdTb3VyY2UuY2FuY2VsKHJlYXNvbik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEobmFtZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtVGVlKHN0cmVhbSwgY2xvbmVGb3JCcmFuY2gyKSB7XG5cdFx0ICAgICAgICBpZiAoSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1UZWUoc3RyZWFtKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRUZWUoc3RyZWFtKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRUZWUoc3RyZWFtLCBjbG9uZUZvckJyYW5jaDIpIHtcblx0XHQgICAgICAgIGNvbnN0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcblx0XHQgICAgICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICBsZXQgcmVhZEFnYWluID0gZmFsc2U7XG5cdFx0ICAgICAgICBsZXQgY2FuY2VsZWQxID0gZmFsc2U7XG5cdFx0ICAgICAgICBsZXQgY2FuY2VsZWQyID0gZmFsc2U7XG5cdFx0ICAgICAgICBsZXQgcmVhc29uMTtcblx0XHQgICAgICAgIGxldCByZWFzb24yO1xuXHRcdCAgICAgICAgbGV0IGJyYW5jaDE7XG5cdFx0ICAgICAgICBsZXQgYnJhbmNoMjtcblx0XHQgICAgICAgIGxldCByZXNvbHZlQ2FuY2VsUHJvbWlzZTtcblx0XHQgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdCAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlID0gcmVzb2x2ZTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpIHtcblx0XHQgICAgICAgICAgICBpZiAocmVhZGluZykge1xuXHRcdCAgICAgICAgICAgICAgICByZWFkQWdhaW4gPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZWFkaW5nID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcblx0XHQgICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBhIG1pY3JvdGFzayBiZWNhdXNlIGl0IHRha2VzIGF0IGxlYXN0IGEgbWljcm90YXNrIHRvIGRldGVjdCBlcnJvcnMgKHVzaW5nXG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyByZWFkZXIuX2Nsb3NlZFByb21pc2UgYmVsb3cpLCBhbmQgd2Ugd2FudCBlcnJvcnMgaW4gc3RyZWFtIHRvIGVycm9yIGJvdGggYnJhbmNoZXMgaW1tZWRpYXRlbHkuIFdlIGNhbm5vdCBsZXRcblx0XHQgICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG5cdFx0ICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsxID0gY2h1bms7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsyID0gY2h1bms7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIGFjY2VzcyB0aGUgY2xvbmluZyBjb2RlIHJpZ2h0IG5vdyBpbiB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLlxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFkZCBvbmUgdGhlbiB3ZSdsbCBuZWVkIGFuIGltcGxlbWVudGF0aW9uIGZvciBzZXJpYWxpemFibGUgb2JqZWN0cy5cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoIWNhbmNlbGVkMiAmJiBjbG9uZUZvckJyYW5jaDIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNodW5rMiA9IFN0cnVjdHVyZWREZXNlcmlhbGl6ZShTdHJ1Y3R1cmVkU2VyaWFsaXplKGNodW5rMikpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsyKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFkQWdhaW4pIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgfSxcblx0XHQgICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gY2FuY2VsMUFsZ29yaXRobShyZWFzb24pIHtcblx0XHQgICAgICAgICAgICBjYW5jZWxlZDEgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIHJlYXNvbjEgPSByZWFzb247XG5cdFx0ICAgICAgICAgICAgaWYgKGNhbmNlbGVkMikge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcblx0XHQgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBmdW5jdGlvbiBjYW5jZWwyQWxnb3JpdGhtKHJlYXNvbikge1xuXHRcdCAgICAgICAgICAgIGNhbmNlbGVkMiA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgcmVhc29uMiA9IHJlYXNvbjtcblx0XHQgICAgICAgICAgICBpZiAoY2FuY2VsZWQxKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuXHRcdCAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xuXHRcdCAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGJyYW5jaDEgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsMUFsZ29yaXRobSk7XG5cdFx0ICAgICAgICBicmFuY2gyID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbDJBbGdvcml0aG0pO1xuXHRcdCAgICAgICAgdXBvblJlamVjdGlvbihyZWFkZXIuX2Nsb3NlZFByb21pc2UsIChyKSA9PiB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG5cdFx0ICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuXHRcdCAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgcmV0dXJuIFticmFuY2gxLCBicmFuY2gyXTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1UZWUoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBsZXQgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuXHRcdCAgICAgICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgIGxldCByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG5cdFx0ICAgICAgICBsZXQgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IGNhbmNlbGVkMSA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IGNhbmNlbGVkMiA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IHJlYXNvbjE7XG5cdFx0ICAgICAgICBsZXQgcmVhc29uMjtcblx0XHQgICAgICAgIGxldCBicmFuY2gxO1xuXHRcdCAgICAgICAgbGV0IGJyYW5jaDI7XG5cdFx0ICAgICAgICBsZXQgcmVzb2x2ZUNhbmNlbFByb21pc2U7XG5cdFx0ICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHQgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSA9IHJlc29sdmU7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIGZ1bmN0aW9uIGZvcndhcmRSZWFkZXJFcnJvcih0aGlzUmVhZGVyKSB7XG5cdFx0ICAgICAgICAgICAgdXBvblJlamVjdGlvbih0aGlzUmVhZGVyLl9jbG9zZWRQcm9taXNlLCByID0+IHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHRoaXNSZWFkZXIgIT09IHJlYWRlcikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuXHRcdCAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCkge1xuXHRcdCAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihyZWFkZXIpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcblx0XHQgICAgICAgICAgICAgICAgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuXHRcdCAgICAgICAgICAgICAgICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XG5cdFx0ICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIHN5bmNocm9ub3VzbHktYXZhaWxhYmxlIHJlYWRzIGdldCBhaGVhZCBvZiBhc3luY2hyb25vdXNseS1hdmFpbGFibGUgZXJyb3JzLlxuXHRcdCAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gyID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsxID0gY2h1bms7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNodW5rMiA9IGNodW5rO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxICYmICFjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rMiA9IENsb25lQXNVaW50OEFycmF5KGNodW5rKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoY2xvbmVFKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY2xvbmVFKSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazEpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEFnYWluRm9yQnJhbmNoMSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsMUFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGwyQWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgIH0sXG5cdFx0ICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIGlmIChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgMCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIH0sXG5cdFx0ICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9O1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBmdW5jdGlvbiBwdWxsV2l0aEJZT0JSZWFkZXIodmlldywgZm9yQnJhbmNoMikge1xuXHRcdCAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcblx0XHQgICAgICAgICAgICAgICAgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0pO1xuXHRcdCAgICAgICAgICAgICAgICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3QgYnlvYkJyYW5jaCA9IGZvckJyYW5jaDIgPyBicmFuY2gyIDogYnJhbmNoMTtcblx0XHQgICAgICAgICAgICBjb25zdCBvdGhlckJyYW5jaCA9IGZvckJyYW5jaDIgPyBicmFuY2gxIDogYnJhbmNoMjtcblx0XHQgICAgICAgICAgICBjb25zdCByZWFkSW50b1JlcXVlc3QgPSB7XG5cdFx0ICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIHN5bmNocm9ub3VzbHktYXZhaWxhYmxlIHJlYWRzIGdldCBhaGVhZCBvZiBhc3luY2hyb25vdXNseS1hdmFpbGFibGUgZXJyb3JzLlxuXHRcdCAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gyID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnlvYkNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMiA6IGNhbmNlbGVkMTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMSA6IGNhbmNlbGVkMjtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNsb25lZENodW5rO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkQ2h1bmsgPSBDbG9uZUFzVWludDhBcnJheShjaHVuayk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGNsb25lRSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjbG9uZUUpKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyhieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZWRDaHVuayk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFieW9iQ2FuY2VsZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyhieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gxKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGwxQWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbDJBbGdvcml0aG0oKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICAgICAgfSxcblx0XHQgICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6IGNodW5rID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5b2JDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDIgOiBjYW5jZWxlZDE7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMSA6IGNhbmNlbGVkMjtcblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2Uob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCAmJiBvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgMCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQgfHwgIW90aGVyQ2FuY2VsZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHJlYWRlciwgdmlldywgcmVhZEludG9SZXF1ZXN0KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIHB1bGwxQWxnb3JpdGhtKCkge1xuXHRcdCAgICAgICAgICAgIGlmIChyZWFkaW5nKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZWFkaW5nID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICBjb25zdCBieW9iUmVxdWVzdCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgIGlmIChieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuXHRcdCAgICAgICAgICAgICAgICBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIHB1bGxXaXRoQllPQlJlYWRlcihieW9iUmVxdWVzdC5fdmlldywgZmFsc2UpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gcHVsbDJBbGdvcml0aG0oKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKHJlYWRpbmcpIHtcblx0XHQgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGJ5b2JSZXF1ZXN0ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgaWYgKGJ5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHB1bGxXaXRoRGVmYXVsdFJlYWRlcigpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgcHVsbFdpdGhCWU9CUmVhZGVyKGJ5b2JSZXF1ZXN0Ll92aWV3LCB0cnVlKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uKSB7XG5cdFx0ICAgICAgICAgICAgY2FuY2VsZWQxID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICByZWFzb24xID0gcmVhc29uO1xuXHRcdCAgICAgICAgICAgIGlmIChjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG5cdFx0ICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gY2FuY2VsMkFsZ29yaXRobShyZWFzb24pIHtcblx0XHQgICAgICAgICAgICBjYW5jZWxlZDIgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIHJlYXNvbjIgPSByZWFzb247XG5cdFx0ICAgICAgICAgICAgaWYgKGNhbmNlbGVkMSkge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcblx0XHQgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBicmFuY2gxID0gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsMUFsZ29yaXRobSwgY2FuY2VsMUFsZ29yaXRobSk7XG5cdFx0ICAgICAgICBicmFuY2gyID0gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsMkFsZ29yaXRobSwgY2FuY2VsMkFsZ29yaXRobSk7XG5cdFx0ICAgICAgICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcblx0XHQgICAgICAgIHJldHVybiBbYnJhbmNoMSwgYnJhbmNoMl07XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2Uoc291cmNlLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KHNvdXJjZSwgY29udGV4dCk7XG5cdFx0ICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHNvdXJjZTtcblx0XHQgICAgICAgIGNvbnN0IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5hdXRvQWxsb2NhdGVDaHVua1NpemU7XG5cdFx0ICAgICAgICBjb25zdCBjYW5jZWwgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuY2FuY2VsO1xuXHRcdCAgICAgICAgY29uc3QgcHVsbCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5wdWxsO1xuXHRcdCAgICAgICAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuc3RhcnQ7XG5cdFx0ICAgICAgICBjb25zdCB0eXBlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnR5cGU7XG5cdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgICAgIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTogYXV0b0FsbG9jYXRlQ2h1bmtTaXplID09PSB1bmRlZmluZWQgP1xuXHRcdCAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuXHRcdCAgICAgICAgICAgICAgICBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoYXV0b0FsbG9jYXRlQ2h1bmtTaXplLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdhdXRvQWxsb2NhdGVDaHVua1NpemUnIHRoYXRgKSxcblx0XHQgICAgICAgICAgICBjYW5jZWw6IGNhbmNlbCA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayhjYW5jZWwsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdjYW5jZWwnIHRoYXRgKSxcblx0XHQgICAgICAgICAgICBwdWxsOiBwdWxsID09PSB1bmRlZmluZWQgP1xuXHRcdCAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuXHRcdCAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayhwdWxsLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAncHVsbCcgdGhhdGApLFxuXHRcdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcblx0XHQgICAgICAgICAgICB0eXBlOiB0eXBlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UmVhZGFibGVTdHJlYW1UeXBlKHR5cGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3R5cGUnIHRoYXRgKVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChyZWFzb24pID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW3JlYXNvbl0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSh0eXBlLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICB0eXBlID0gYCR7dHlwZX1gO1xuXHRcdCAgICAgICAgaWYgKHR5cGUgIT09ICdieXRlcycpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9ICcke3R5cGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1UeXBlYCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdHlwZTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRSZWFkZXJPcHRpb25zKG9wdGlvbnMsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG5cdFx0ICAgICAgICBjb25zdCBtb2RlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGU7XG5cdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgICAgIG1vZGU6IG1vZGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnbW9kZScgdGhhdGApXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZSwgY29udGV4dCkge1xuXHRcdCAgICAgICAgbW9kZSA9IGAke21vZGV9YDtcblx0XHQgICAgICAgIGlmIChtb2RlICE9PSAnYnlvYicpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9ICcke21vZGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlYCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gbW9kZTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRJdGVyYXRvck9wdGlvbnMob3B0aW9ucywgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcblx0XHQgICAgICAgIGNvbnN0IHByZXZlbnRDYW5jZWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENhbmNlbDtcblx0XHQgICAgICAgIHJldHVybiB7IHByZXZlbnRDYW5jZWw6IEJvb2xlYW4ocHJldmVudENhbmNlbCkgfTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRQaXBlT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuXHRcdCAgICAgICAgY29uc3QgcHJldmVudEFib3J0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRBYm9ydDtcblx0XHQgICAgICAgIGNvbnN0IHByZXZlbnRDYW5jZWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENhbmNlbDtcblx0XHQgICAgICAgIGNvbnN0IHByZXZlbnRDbG9zZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV2ZW50Q2xvc2U7XG5cdFx0ICAgICAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsO1xuXHRcdCAgICAgICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0QWJvcnRTaWduYWwoc2lnbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzaWduYWwnIHRoYXRgKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB7XG5cdFx0ICAgICAgICAgICAgcHJldmVudEFib3J0OiBCb29sZWFuKHByZXZlbnRBYm9ydCksXG5cdFx0ICAgICAgICAgICAgcHJldmVudENhbmNlbDogQm9vbGVhbihwcmV2ZW50Q2FuY2VsKSxcblx0XHQgICAgICAgICAgICBwcmV2ZW50Q2xvc2U6IEJvb2xlYW4ocHJldmVudENsb3NlKSxcblx0XHQgICAgICAgICAgICBzaWduYWxcblx0XHQgICAgICAgIH07XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gYXNzZXJ0QWJvcnRTaWduYWwoc2lnbmFsLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBpZiAoIWlzQWJvcnRTaWduYWwoc2lnbmFsKSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIEFib3J0U2lnbmFsLmApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyKHBhaXIsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydERpY3Rpb25hcnkocGFpciwgY29udGV4dCk7XG5cdFx0ICAgICAgICBjb25zdCByZWFkYWJsZSA9IHBhaXIgPT09IG51bGwgfHwgcGFpciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFpci5yZWFkYWJsZTtcblx0XHQgICAgICAgIGFzc2VydFJlcXVpcmVkRmllbGQocmVhZGFibGUsICdyZWFkYWJsZScsICdSZWFkYWJsZVdyaXRhYmxlUGFpcicpO1xuXHRcdCAgICAgICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0ocmVhZGFibGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3JlYWRhYmxlJyB0aGF0YCk7XG5cdFx0ICAgICAgICBjb25zdCB3cml0YWJsZSA9IHBhaXIgPT09IG51bGwgfHwgcGFpciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFpci53cml0YWJsZTtcblx0XHQgICAgICAgIGFzc2VydFJlcXVpcmVkRmllbGQod3JpdGFibGUsICd3cml0YWJsZScsICdSZWFkYWJsZVdyaXRhYmxlUGFpcicpO1xuXHRcdCAgICAgICAgYXNzZXJ0V3JpdGFibGVTdHJlYW0od3JpdGFibGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3dyaXRhYmxlJyB0aGF0YCk7XG5cdFx0ICAgICAgICByZXR1cm4geyByZWFkYWJsZSwgd3JpdGFibGUgfTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBIHJlYWRhYmxlIHN0cmVhbSByZXByZXNlbnRzIGEgc291cmNlIG9mIGRhdGEsIGZyb20gd2hpY2ggeW91IGNhbiByZWFkLlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbSB7XG5cdFx0ICAgICAgICBjb25zdHJ1Y3RvcihyYXdVbmRlcmx5aW5nU291cmNlID0ge30sIHJhd1N0cmF0ZWd5ID0ge30pIHtcblx0XHQgICAgICAgICAgICBpZiAocmF3VW5kZXJseWluZ1NvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJhd1VuZGVybHlpbmdTb3VyY2UgPSBudWxsO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgYXNzZXJ0T2JqZWN0KHJhd1VuZGVybHlpbmdTb3VyY2UsICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHVuZGVybHlpbmdTb3VyY2UgPSBjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2UocmF3VW5kZXJseWluZ1NvdXJjZSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbSh0aGlzKTtcblx0XHQgICAgICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS50eXBlID09PSAnYnl0ZXMnKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneS5zaXplICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgc3RyYXRlZ3kgZm9yIGEgYnl0ZSBzdHJlYW0gY2Fubm90IGhhdmUgYSBzaXplIGZ1bmN0aW9uJyk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAwKTtcblx0XHQgICAgICAgICAgICAgICAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UodGhpcywgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyayk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBzaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0oc3RyYXRlZ3kpO1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xuXHRcdCAgICAgICAgICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSh0aGlzLCB1bmRlcmx5aW5nU291cmNlLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSByZWFkYWJsZSBzdHJlYW0gaXMgbG9ja2VkIHRvIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciB8IHJlYWRlcn0uXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCBsb2NrZWQoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnbG9ja2VkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBDYW5jZWxzIHRoZSBzdHJlYW0sIHNpZ25hbGluZyBhIGxvc3Mgb2YgaW50ZXJlc3QgaW4gdGhlIHN0cmVhbSBieSBhIGNvbnN1bWVyLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIFRoZSBzdXBwbGllZCBgcmVhc29uYCBhcmd1bWVudCB3aWxsIGJlIGdpdmVuIHRvIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSdzIHtAbGluayBVbmRlcmx5aW5nU291cmNlLmNhbmNlbCB8IGNhbmNlbCgpfVxuXHRcdCAgICAgICAgICogbWV0aG9kLCB3aGljaCBtaWdodCBvciBtaWdodCBub3QgdXNlIGl0LlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBjYW5jZWwocmVhc29uID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnY2FuY2VsJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FuY2VsIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSByZWFkZXInKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbCh0aGlzLCByZWFzb24pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZ2V0UmVhZGVyKHJhd09wdGlvbnMgPSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdnZXRSZWFkZXInKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnZlcnRSZWFkZXJPcHRpb25zKHJhd09wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBpZiAob3B0aW9ucy5tb2RlID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcGlwZVRocm91Z2gocmF3VHJhbnNmb3JtLCByYXdPcHRpb25zID0ge30pIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdwaXBlVGhyb3VnaCcpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHJhd1RyYW5zZm9ybSwgMSwgJ3BpcGVUaHJvdWdoJyk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyKHJhd1RyYW5zZm9ybSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0UGlwZU9wdGlvbnMocmF3T3B0aW9ucywgJ1NlY29uZCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW0nKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodHJhbnNmb3JtLndyaXRhYmxlKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW0nKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IFJlYWRhYmxlU3RyZWFtUGlwZVRvKHRoaXMsIHRyYW5zZm9ybS53cml0YWJsZSwgb3B0aW9ucy5wcmV2ZW50Q2xvc2UsIG9wdGlvbnMucHJldmVudEFib3J0LCBvcHRpb25zLnByZXZlbnRDYW5jZWwsIG9wdGlvbnMuc2lnbmFsKTtcblx0XHQgICAgICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHByb21pc2UpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0ucmVhZGFibGU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBwaXBlVG8oZGVzdGluYXRpb24sIHJhd09wdGlvbnMgPSB7fSkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3BpcGVUbycpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYFBhcmFtZXRlciAxIGlzIHJlcXVpcmVkIGluICdwaXBlVG8nLmApO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0oZGVzdGluYXRpb24pKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8ncyBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgV3JpdGFibGVTdHJlYW1gKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGxldCBvcHRpb25zO1xuXHRcdCAgICAgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBjb252ZXJ0UGlwZU9wdGlvbnMocmF3T3B0aW9ucywgJ1NlY29uZCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY2F0Y2ggKGUpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW0nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKGRlc3RpbmF0aW9uKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFdyaXRhYmxlU3RyZWFtJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1QaXBlVG8odGhpcywgZGVzdGluYXRpb24sIG9wdGlvbnMucHJldmVudENsb3NlLCBvcHRpb25zLnByZXZlbnRBYm9ydCwgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsLCBvcHRpb25zLnNpZ25hbCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFRlZXMgdGhpcyByZWFkYWJsZSBzdHJlYW0sIHJldHVybmluZyBhIHR3by1lbGVtZW50IGFycmF5IGNvbnRhaW5pbmcgdGhlIHR3byByZXN1bHRpbmcgYnJhbmNoZXMgYXNcblx0XHQgICAgICAgICAqIG5ldyB7QGxpbmsgUmVhZGFibGVTdHJlYW19IGluc3RhbmNlcy5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBUZWVpbmcgYSBzdHJlYW0gd2lsbCBsb2NrIGl0LCBwcmV2ZW50aW5nIGFueSBvdGhlciBjb25zdW1lciBmcm9tIGFjcXVpcmluZyBhIHJlYWRlci5cblx0XHQgICAgICAgICAqIFRvIGNhbmNlbCB0aGUgc3RyZWFtLCBjYW5jZWwgYm90aCBvZiB0aGUgcmVzdWx0aW5nIGJyYW5jaGVzOyBhIGNvbXBvc2l0ZSBjYW5jZWxsYXRpb24gcmVhc29uIHdpbGwgdGhlbiBiZVxuXHRcdCAgICAgICAgICogcHJvcGFnYXRlZCB0byB0aGUgc3RyZWFtJ3MgdW5kZXJseWluZyBzb3VyY2UuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBjaHVua3Mgc2VlbiBpbiBlYWNoIGJyYW5jaCB3aWxsIGJlIHRoZSBzYW1lIG9iamVjdC4gSWYgdGhlIGNodW5rcyBhcmUgbm90IGltbXV0YWJsZSxcblx0XHQgICAgICAgICAqIHRoaXMgY291bGQgYWxsb3cgaW50ZXJmZXJlbmNlIGJldHdlZW4gdGhlIHR3byBicmFuY2hlcy5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgdGVlKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3RlZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCBicmFuY2hlcyA9IFJlYWRhYmxlU3RyZWFtVGVlKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiBDcmVhdGVBcnJheUZyb21MaXN0KGJyYW5jaGVzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHZhbHVlcyhyYXdPcHRpb25zID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgndmFsdWVzJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0SXRlcmF0b3JPcHRpb25zKHJhd09wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzLCBvcHRpb25zLnByZXZlbnRDYW5jZWwpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGdldFJlYWRlcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBwaXBlVGhyb3VnaDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBwaXBlVG86IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgdGVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHZhbHVlczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBsb2NrZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwuYXN5bmNJdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLmFzeW5jSXRlcmF0b3IsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnZhbHVlcyxcblx0XHQgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cblx0XHQgICAgLy8gVGhyb3dzIGlmIGFuZCBvbmx5IGlmIHN0YXJ0QWxnb3JpdGhtIHRocm93cy5cblx0XHQgICAgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyayA9IDEsIHNpemVBbGdvcml0aG0gPSAoKSA9PiAxKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcblx0XHQgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblx0XHQgICAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuXHRcdCAgICAgICAgcmV0dXJuIHN0cmVhbTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuXHRcdCAgICBmdW5jdGlvbiBDcmVhdGVSZWFkYWJsZUJ5dGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSkge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuXHRcdCAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCAwLCB1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgcmV0dXJuIHN0cmVhbTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ3JlYWRhYmxlJztcblx0XHQgICAgICAgIHN0cmVhbS5fcmVhZGVyID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gZmFsc2U7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbSh4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZGFibGVTdHJlYW1Db250cm9sbGVyJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9yZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pIHtcblx0XHQgICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG5cdFx0ICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcblx0XHQgICAgICAgIGlmIChyZWFkZXIgIT09IHVuZGVmaW5lZCAmJiBJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihyZWFkZXIpKSB7XG5cdFx0ICAgICAgICAgICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmZvckVhY2gocmVhZEludG9SZXF1ZXN0ID0+IHtcblx0XHQgICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBzb3VyY2VDYW5jZWxQcm9taXNlID0gc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJbQ2FuY2VsU3RlcHNdKHJlYXNvbik7XG5cdFx0ICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoc291cmNlQ2FuY2VsUHJvbWlzZSwgbm9vcCk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pIHtcblx0XHQgICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnY2xvc2VkJztcblx0XHQgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXHRcdCAgICAgICAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcik7XG5cdFx0ICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuXHRcdCAgICAgICAgICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzLmZvckVhY2gocmVhZFJlcXVlc3QgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpIHtcblx0XHQgICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JlZCc7XG5cdFx0ICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gZTtcblx0XHQgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXHRcdCAgICAgICAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCBlKTtcblx0XHQgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XG5cdFx0ICAgICAgICAgICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMuZm9yRWFjaChyZWFkUmVxdWVzdCA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuZm9yRWFjaChyZWFkSW50b1JlcXVlc3QgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXHRcdCAgICBmdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEobmFtZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbWApO1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQoaW5pdCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShpbml0LCBjb250ZXh0KTtcblx0XHQgICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGlnaFdhdGVyTWFyaztcblx0XHQgICAgICAgIGFzc2VydFJlcXVpcmVkRmllbGQoaGlnaFdhdGVyTWFyaywgJ2hpZ2hXYXRlck1hcmsnLCAnUXVldWluZ1N0cmF0ZWd5SW5pdCcpO1xuXHRcdCAgICAgICAgcmV0dXJuIHtcblx0XHQgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGhpZ2hXYXRlck1hcmspXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICB9XG5cblx0XHQgICAgLy8gVGhlIHNpemUgZnVuY3Rpb24gbXVzdCBub3QgaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBub3IgYmUgYSBjb25zdHJ1Y3RvclxuXHRcdCAgICBjb25zdCBieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uID0gKGNodW5rKSA9PiB7XG5cdFx0ICAgICAgICByZXR1cm4gY2h1bmsuYnl0ZUxlbmd0aDtcblx0XHQgICAgfTtcblx0XHQgICAgdHJ5IHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uLCAnbmFtZScsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ3NpemUnLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgY2F0Y2ggKF9hKSB7XG5cdFx0ICAgICAgICAvLyBUaGlzIHByb3BlcnR5IGlzIG5vbi1jb25maWd1cmFibGUgaW4gb2xkZXIgYnJvd3NlcnMsIHNvIGlnbm9yZSBpZiB0aGlzIHRocm93cy5cblx0XHQgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL25hbWUjYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG5cdFx0ICAgIH1cblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEEgcXVldWluZyBzdHJhdGVneSB0aGF0IGNvdW50cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIGVhY2ggY2h1bmsuXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEBwdWJsaWNcblx0XHQgICAgICovXG5cdFx0ICAgIGNsYXNzIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdCAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQob3B0aW9ucywgMSwgJ0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3knKTtcblx0XHQgICAgICAgICAgICBvcHRpb25zID0gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQob3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIHRoaXMuX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBoaWdoIHdhdGVyIG1hcmsgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgaGlnaFdhdGVyTWFyaygpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignaGlnaFdhdGVyTWFyaycpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIE1lYXN1cmVzIHRoZSBzaXplIG9mIGBjaHVua2AgYnkgcmV0dXJuaW5nIHRoZSB2YWx1ZSBvZiBpdHMgYGJ5dGVMZW5ndGhgIHByb3BlcnR5LlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgc2l6ZSgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignc2l6ZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gYnl0ZUxlbmd0aFNpemVGdW5jdGlvbjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3knLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kuXG5cdFx0ICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5YCk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaycpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5O1xuXHRcdCAgICB9XG5cblx0XHQgICAgLy8gVGhlIHNpemUgZnVuY3Rpb24gbXVzdCBub3QgaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBub3IgYmUgYSBjb25zdHJ1Y3RvclxuXHRcdCAgICBjb25zdCBjb3VudFNpemVGdW5jdGlvbiA9ICgpID0+IHtcblx0XHQgICAgICAgIHJldHVybiAxO1xuXHRcdCAgICB9O1xuXHRcdCAgICB0cnkge1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvdW50U2l6ZUZ1bmN0aW9uLCAnbmFtZScsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ3NpemUnLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgY2F0Y2ggKF9hKSB7XG5cdFx0ICAgICAgICAvLyBUaGlzIHByb3BlcnR5IGlzIG5vbi1jb25maWd1cmFibGUgaW4gb2xkZXIgYnJvd3NlcnMsIHNvIGlnbm9yZSBpZiB0aGlzIHRocm93cy5cblx0XHQgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL25hbWUjYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG5cdFx0ICAgIH1cblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEEgcXVldWluZyBzdHJhdGVneSB0aGF0IGNvdW50cyB0aGUgbnVtYmVyIG9mIGNodW5rcy5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgQ291bnRRdWV1aW5nU3RyYXRlZ3kge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdCAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQob3B0aW9ucywgMSwgJ0NvdW50UXVldWluZ1N0cmF0ZWd5Jyk7XG5cdFx0ICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KG9wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICB0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsgPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJldHVybnMgdGhlIGhpZ2ggd2F0ZXIgbWFyayBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCBoaWdoV2F0ZXJNYXJrKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24oJ2hpZ2hXYXRlck1hcmsnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaztcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogTWVhc3VyZXMgdGhlIHNpemUgb2YgYGNodW5rYCBieSBhbHdheXMgcmV0dXJuaW5nIDEuXG5cdFx0ICAgICAgICAgKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdG90YWwgcXVldWUgc2l6ZSBpcyBhIGNvdW50IG9mIHRoZSBudW1iZXIgb2YgY2h1bmtzIGluIHRoZSBxdWV1ZS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IHNpemUoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbignc2l6ZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gY291bnRTaXplRnVuY3Rpb247XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCB7XG5cdFx0ICAgICAgICBoaWdoV2F0ZXJNYXJrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ0NvdW50UXVldWluZ1N0cmF0ZWd5Jyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBDb3VudFF1ZXVpbmdTdHJhdGVneS5cblx0XHQgICAgZnVuY3Rpb24gY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQ291bnRRdWV1aW5nU3RyYXRlZ3lgKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsnKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgQ291bnRRdWV1aW5nU3RyYXRlZ3k7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXIob3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydERpY3Rpb25hcnkob3JpZ2luYWwsIGNvbnRleHQpO1xuXHRcdCAgICAgICAgY29uc3QgZmx1c2ggPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuZmx1c2g7XG5cdFx0ICAgICAgICBjb25zdCByZWFkYWJsZVR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwucmVhZGFibGVUeXBlO1xuXHRcdCAgICAgICAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuc3RhcnQ7XG5cdFx0ICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHJhbnNmb3JtO1xuXHRcdCAgICAgICAgY29uc3Qgd3JpdGFibGVUeXBlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLndyaXRhYmxlVHlwZTtcblx0XHQgICAgICAgIHJldHVybiB7XG5cdFx0ICAgICAgICAgICAgZmx1c2g6IGZsdXNoID09PSB1bmRlZmluZWQgP1xuXHRcdCAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuXHRcdCAgICAgICAgICAgICAgICBjb252ZXJ0VHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrKGZsdXNoLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnZmx1c2gnIHRoYXRgKSxcblx0XHQgICAgICAgICAgICByZWFkYWJsZVR5cGUsXG5cdFx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuXHRcdCAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuXHRcdCAgICAgICAgICAgICAgICBjb252ZXJ0VHJhbnNmb3JtZXJTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcblx0XHQgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2sodHJhbnNmb3JtLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAndHJhbnNmb3JtJyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgd3JpdGFibGVUeXBlXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG5cdFx0ICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXJTdGFydENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG5cdFx0ICAgICAgICByZXR1cm4gKGNodW5rLCBjb250cm9sbGVyKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjaHVuaywgY29udHJvbGxlcl0pO1xuXHRcdCAgICB9XG5cblx0XHQgICAgLy8gQ2xhc3MgVHJhbnNmb3JtU3RyZWFtXG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBIHRyYW5zZm9ybSBzdHJlYW0gY29uc2lzdHMgb2YgYSBwYWlyIG9mIHN0cmVhbXM6IGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtIHwgd3JpdGFibGUgc3RyZWFtfSxcblx0XHQgICAgICoga25vd24gYXMgaXRzIHdyaXRhYmxlIHNpZGUsIGFuZCBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIHN0cmVhbX0sIGtub3duIGFzIGl0cyByZWFkYWJsZSBzaWRlLlxuXHRcdCAgICAgKiBJbiBhIG1hbm5lciBzcGVjaWZpYyB0byB0aGUgdHJhbnNmb3JtIHN0cmVhbSBpbiBxdWVzdGlvbiwgd3JpdGVzIHRvIHRoZSB3cml0YWJsZSBzaWRlIHJlc3VsdCBpbiBuZXcgZGF0YSBiZWluZ1xuXHRcdCAgICAgKiBtYWRlIGF2YWlsYWJsZSBmb3IgcmVhZGluZyBmcm9tIHRoZSByZWFkYWJsZSBzaWRlLlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBUcmFuc2Zvcm1TdHJlYW0ge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IocmF3VHJhbnNmb3JtZXIgPSB7fSwgcmF3V3JpdGFibGVTdHJhdGVneSA9IHt9LCByYXdSZWFkYWJsZVN0cmF0ZWd5ID0ge30pIHtcblx0XHQgICAgICAgICAgICBpZiAocmF3VHJhbnNmb3JtZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByYXdUcmFuc2Zvcm1lciA9IG51bGw7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlU3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1dyaXRhYmxlU3RyYXRlZ3ksICdTZWNvbmQgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVhZGFibGVTdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3UmVhZGFibGVTdHJhdGVneSwgJ1RoaXJkIHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gY29udmVydFRyYW5zZm9ybWVyKHJhd1RyYW5zZm9ybWVyLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyLnJlYWRhYmxlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHJlYWRhYmxlVHlwZSBzcGVjaWZpZWQnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyLndyaXRhYmxlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHdyaXRhYmxlVHlwZSBzcGVjaWZpZWQnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVhZGFibGVIaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsocmVhZGFibGVTdHJhdGVneSwgMCk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVhZGFibGVTaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0ocmVhZGFibGVTdHJhdGVneSk7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgd3JpdGFibGVIaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsod3JpdGFibGVTdHJhdGVneSwgMSk7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgd3JpdGFibGVTaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0od3JpdGFibGVTdHJhdGVneSk7XG5cdFx0ICAgICAgICAgICAgbGV0IHN0YXJ0UHJvbWlzZV9yZXNvbHZlO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IG5ld1Byb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIHN0YXJ0UHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtKHRoaXMsIHN0YXJ0UHJvbWlzZSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcblx0XHQgICAgICAgICAgICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVRyYW5zZm9ybWVyKHRoaXMsIHRyYW5zZm9ybWVyKTtcblx0XHQgICAgICAgICAgICBpZiAodHJhbnNmb3JtZXIuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSh0cmFuc2Zvcm1lci5zdGFydCh0aGlzLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogVGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHRyYW5zZm9ybSBzdHJlYW0uXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCByZWFkYWJsZSgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWRhYmxlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogVGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIHRyYW5zZm9ybSBzdHJlYW0uXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCB3cml0YWJsZSgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3dyaXRhYmxlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCB7XG5cdFx0ICAgICAgICByZWFkYWJsZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICB3cml0YWJsZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cblx0XHQgICAgfSk7XG5cdFx0ICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ1RyYW5zZm9ybVN0cmVhbScsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtKHN0cmVhbSwgc3RhcnRQcm9taXNlLCB3cml0YWJsZUhpZ2hXYXRlck1hcmssIHdyaXRhYmxlU2l6ZUFsZ29yaXRobSwgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLCByZWFkYWJsZVNpemVBbGdvcml0aG0pIHtcblx0XHQgICAgICAgIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBzdGFydFByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBmdW5jdGlvbiB3cml0ZUFsZ29yaXRobShjaHVuaykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtKHN0cmVhbSwgY2h1bmspO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gYWJvcnRBbGdvcml0aG0ocmVhc29uKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gY2xvc2VBbGdvcml0aG0oKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0oc3RyZWFtKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHN0cmVhbS5fd3JpdGFibGUgPSBDcmVhdGVXcml0YWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0pO1xuXHRcdCAgICAgICAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZVB1bGxBbGdvcml0aG0oc3RyZWFtKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIGNhbmNlbEFsZ29yaXRobShyZWFzb24pIHtcblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgcmVhc29uKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgc3RyZWFtLl9yZWFkYWJsZSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcblx0XHQgICAgICAgIC8vIFRoZSBbW2JhY2twcmVzc3VyZV1dIHNsb3QgaXMgc2V0IHRvIHVuZGVmaW5lZCBzbyB0aGF0IGl0IGNhbiBiZSBpbml0aWFsaXNlZCBieSBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUuXG5cdFx0ICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgdHJ1ZSk7XG5cdFx0ICAgICAgICBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSXNUcmFuc2Zvcm1TdHJlYW0oeCkge1xuXHRcdCAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXInKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgVHJhbnNmb3JtU3RyZWFtO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiBib3RoIHNpZGVzIGFyZSBhbHJlYWR5IGVycm9yZWQuXG5cdFx0ICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yKHN0cmVhbSwgZSkge1xuXHRcdCAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgZSk7XG5cdFx0ICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpIHtcblx0XHQgICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChzdHJlYW0uX3dyaXRhYmxlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsIGUpO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG5cdFx0ICAgICAgICAgICAgLy8gUHJldGVuZCB0aGF0IHB1bGwoKSB3YXMgY2FsbGVkIHRvIHBlcm1pdCBhbnkgcGVuZGluZyB3cml0ZSgpIGNhbGxzIHRvIGNvbXBsZXRlLiBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoKVxuXHRcdCAgICAgICAgICAgIC8vIGNhbm5vdCBiZSBjYWxsZWQgZnJvbSBlbnF1ZXVlKCkgb3IgcHVsbCgpIG9uY2UgdGhlIFJlYWRhYmxlU3RyZWFtIGlzIGVycm9yZWQsIHNvIHRoaXMgd2lsbCB3aWxsIGJlIHRoZSBmaW5hbCB0aW1lXG5cdFx0ICAgICAgICAgICAgLy8gX2JhY2twcmVzc3VyZSBpcyBzZXQuXG5cdFx0ICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgZmFsc2UpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSkge1xuXHRcdCAgICAgICAgLy8gUGFzc2VzIGFsc28gd2hlbiBjYWxsZWQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cblx0XHQgICAgICAgIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBiYWNrcHJlc3N1cmU7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQ2xhc3MgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEFsbG93cyBjb250cm9sIG9mIHRoZSB7QGxpbmsgUmVhZGFibGVTdHJlYW19IGFuZCB7QGxpbmsgV3JpdGFibGVTdHJlYW19IG9mIHRoZSBhc3NvY2lhdGVkIHtAbGluayBUcmFuc2Zvcm1TdHJlYW19LlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciB7XG5cdFx0ICAgICAgICBjb25zdHJ1Y3RvcigpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSByZWFkYWJsZSBzaWRl4oCZcyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXMgb3Zlci1mdWxsLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgZGVzaXJlZFNpemUoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtcblx0XHQgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHJlYWRhYmxlQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbnF1ZXVlKGNodW5rID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZW5xdWV1ZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBFcnJvcnMgYm90aCB0aGUgcmVhZGFibGUgc2lkZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIGNvbnRyb2xsZWQgdHJhbnNmb3JtIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmVcblx0XHQgICAgICAgICAqIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLiBBbnkgY2h1bmtzIHF1ZXVlZCBmb3IgdHJhbnNmb3JtYXRpb24gd2lsbCBiZSBkaXNjYXJkZWQuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGVycm9yKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Vycm9yJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogQ2xvc2VzIHRoZSByZWFkYWJsZSBzaWRlIGFuZCBlcnJvcnMgdGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIGNvbnRyb2xsZWQgdHJhbnNmb3JtIHN0cmVhbS4gVGhpcyBpcyB1c2VmdWwgd2hlbiB0aGVcblx0XHQgICAgICAgICAqIHRyYW5zZm9ybWVyIG9ubHkgbmVlZHMgdG8gY29uc3VtZSBhIHBvcnRpb24gb2YgdGhlIGNodW5rcyB3cml0dGVuIHRvIHRoZSB3cml0YWJsZSBzaWRlLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICB0ZXJtaW5hdGUoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbigndGVybWluYXRlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgZW5xdWV1ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICB0ZXJtaW5hdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFRyYW5zZm9ybSBTdHJlYW0gRGVmYXVsdCBDb250cm9sbGVyIEFic3RyYWN0IE9wZXJhdGlvbnNcblx0XHQgICAgZnVuY3Rpb24gSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbScpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgdHJhbnNmb3JtQWxnb3JpdGhtLCBmbHVzaEFsZ29yaXRobSkge1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSA9IHN0cmVhbTtcblx0XHQgICAgICAgIHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB0cmFuc2Zvcm1BbGdvcml0aG07XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9mbHVzaEFsZ29yaXRobSA9IGZsdXNoQWxnb3JpdGhtO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXIoc3RyZWFtLCB0cmFuc2Zvcm1lcikge1xuXHRcdCAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblx0XHQgICAgICAgIGxldCB0cmFuc2Zvcm1BbGdvcml0aG0gPSAoY2h1bmspID0+IHtcblx0XHQgICAgICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjYXRjaCAodHJhbnNmb3JtUmVzdWx0RSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh0cmFuc2Zvcm1SZXN1bHRFKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICAgICAgbGV0IGZsdXNoQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgaWYgKHRyYW5zZm9ybWVyLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgdHJhbnNmb3JtQWxnb3JpdGhtID0gY2h1bmsgPT4gdHJhbnNmb3JtZXIudHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh0cmFuc2Zvcm1lci5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgZmx1c2hBbGdvcml0aG0gPSAoKSA9PiB0cmFuc2Zvcm1lci5mbHVzaChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCB0cmFuc2Zvcm1BbGdvcml0aG0sIGZsdXNoQWxnb3JpdGhtKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9mbHVzaEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW07XG5cdFx0ICAgICAgICBjb25zdCByZWFkYWJsZUNvbnRyb2xsZXIgPSBzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShyZWFkYWJsZUNvbnRyb2xsZXIpKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGUgc2lkZSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgZW5xdWV1ZScpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gV2UgdGhyb3R0bGUgdHJhbnNmb3JtIGludm9jYXRpb25zIGJhc2VkIG9uIHRoZSBiYWNrcHJlc3N1cmUgb2YgdGhlIFJlYWRhYmxlU3RyZWFtLCBidXQgd2Ugc3RpbGxcblx0XHQgICAgICAgIC8vIGFjY2VwdCBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoKSBjYWxscy5cblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUocmVhZGFibGVDb250cm9sbGVyLCBjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjYXRjaCAoZSkge1xuXHRcdCAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyB3aGVuIHJlYWRhYmxlU3RyYXRlZ3kuc2l6ZSgpIHRocm93cy5cblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZSk7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgc3RyZWFtLl9yZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBiYWNrcHJlc3N1cmUgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlKHJlYWRhYmxlQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICBpZiAoYmFja3ByZXNzdXJlICE9PSBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuXHRcdCAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIHRydWUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSkge1xuXHRcdCAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3IoY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSwgZSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtKGNvbnRyb2xsZXIsIGNodW5rKSB7XG5cdFx0ICAgICAgICBjb25zdCB0cmFuc2Zvcm1Qcm9taXNlID0gY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtKGNodW5rKTtcblx0XHQgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0cmFuc2Zvcm1Qcm9taXNlLCB1bmRlZmluZWQsIHIgPT4ge1xuXHRcdCAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0sIHIpO1xuXHRcdCAgICAgICAgICAgIHRocm93IHI7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclRlcm1pbmF0ZShjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuXHRcdCAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHJlYWRhYmxlQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBUeXBlRXJyb3IoJ1RyYW5zZm9ybVN0cmVhbSB0ZXJtaW5hdGVkJyk7XG5cdFx0ICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZXJyb3IpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rIEFsZ29yaXRobXNcblx0XHQgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobShzdHJlYW0sIGNodW5rKSB7XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcblx0XHQgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCB3cml0YWJsZSA9IHN0cmVhbS5fd3JpdGFibGU7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gd3JpdGFibGUuX3N0YXRlO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHRocm93IHdyaXRhYmxlLl9zdG9yZWRFcnJvcjtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtKGNvbnRyb2xsZXIsIGNodW5rKTtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm0oY29udHJvbGxlciwgY2h1bmspO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pIHtcblx0XHQgICAgICAgIC8vIGFib3J0KCkgaXMgbm90IGNhbGxlZCBzeW5jaHJvbm91c2x5LCBzbyBpdCBpcyBwb3NzaWJsZSBmb3IgYWJvcnQoKSB0byBiZSBjYWxsZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGFscmVhZHlcblx0XHQgICAgICAgIC8vIGVycm9yZWQuXG5cdFx0ICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIHJlYXNvbik7XG5cdFx0ICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0oc3RyZWFtKSB7XG5cdFx0ICAgICAgICAvLyBzdHJlYW0uX3JlYWRhYmxlIGNhbm5vdCBjaGFuZ2UgYWZ0ZXIgY29uc3RydWN0aW9uLCBzbyBjYWNoaW5nIGl0IGFjcm9zcyBhIGNhbGwgdG8gdXNlciBjb2RlIGlzIHNhZmUuXG5cdFx0ICAgICAgICBjb25zdCByZWFkYWJsZSA9IHN0cmVhbS5fcmVhZGFibGU7XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO1xuXHRcdCAgICAgICAgY29uc3QgZmx1c2hQcm9taXNlID0gY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0oKTtcblx0XHQgICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgLy8gUmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZCBvbiBzdWNjZXNzLlxuXHRcdCAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKGZsdXNoUHJvbWlzZSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgIGlmIChyZWFkYWJsZS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyByZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcblx0XHQgICAgICAgIH0sIHIgPT4ge1xuXHRcdCAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKHN0cmVhbSwgcik7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZSBBbGdvcml0aG1zXG5cdFx0ICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSkge1xuXHRcdCAgICAgICAgLy8gSW52YXJpYW50LiBFbmZvcmNlZCBieSB0aGUgcHJvbWlzZXMgcmV0dXJuZWQgYnkgc3RhcnQoKSBhbmQgcHVsbCgpLlxuXHRcdCAgICAgICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgZmFsc2UpO1xuXHRcdCAgICAgICAgLy8gUHJldmVudCB0aGUgbmV4dCBwdWxsKCkgY2FsbCB1bnRpbCB0aGVyZSBpcyBiYWNrcHJlc3N1cmUuXG5cdFx0ICAgICAgICByZXR1cm4gc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgVHJhbnNmb3JtU3RyZWFtLlxuXHRcdCAgICBmdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbWApO1xuXHRcdCAgICB9XG5cblx0XHQgICAgZXhwb3J0cy5CeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5ID0gQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneTtcblx0XHQgICAgZXhwb3J0cy5Db3VudFF1ZXVpbmdTdHJhdGVneSA9IENvdW50UXVldWluZ1N0cmF0ZWd5O1xuXHRcdCAgICBleHBvcnRzLlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyO1xuXHRcdCAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtID0gUmVhZGFibGVTdHJlYW07XG5cdFx0ICAgIGV4cG9ydHMuUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyID0gUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xuXHRcdCAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QgPSBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0O1xuXHRcdCAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuXHRcdCAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjtcblx0XHQgICAgZXhwb3J0cy5UcmFuc2Zvcm1TdHJlYW0gPSBUcmFuc2Zvcm1TdHJlYW07XG5cdFx0ICAgIGV4cG9ydHMuVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgPSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcblx0XHQgICAgZXhwb3J0cy5Xcml0YWJsZVN0cmVhbSA9IFdyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICBleHBvcnRzLldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuXHRcdCAgICBleHBvcnRzLldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjtcblxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdFx0fSkpKTtcblx0XHRcbn0gKHBvbnlmaWxsX2VzMjAxOCwgcG9ueWZpbGxfZXMyMDE4LmV4cG9ydHMpKTtcblx0cmV0dXJuIHBvbnlmaWxsX2VzMjAxOC5leHBvcnRzO1xufVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cblxuLy8gNjQgS2lCIChzYW1lIHNpemUgY2hyb21lIHNsaWNlIHRoZWlycyBibG9iIGludG8gVWludDhhcnJheSdzKVxuY29uc3QgUE9PTF9TSVpFJDEgPSA2NTUzNjtcblxuaWYgKCFnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKSB7XG4gIC8vIGBub2RlOnN0cmVhbS93ZWJgIGdvdCBpbnRyb2R1Y2VkIGluIHYxNi41LjAgYXMgZXhwZXJpbWVudGFsXG4gIC8vIGFuZCBpdCdzIHByZWZlcnJlZCBvdmVyIHRoZSBwb2x5ZmlsbGVkIHZlcnNpb24uIFNvIHdlIGFsc29cbiAgLy8gc3VwcHJlc3MgdGhlIHdhcm5pbmcgdGhhdCBnZXRzIGVtaXR0ZWQgYnkgTm9kZUpTIGZvciB1c2luZyBpdC5cbiAgdHJ5IHtcbiAgICBjb25zdCBwcm9jZXNzID0gcmVxdWlyZSgnbm9kZTpwcm9jZXNzJyk7XG4gICAgY29uc3QgeyBlbWl0V2FybmluZyB9ID0gcHJvY2VzcztcbiAgICB0cnkge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyA9ICgpID0+IHt9O1xuICAgICAgT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCByZXF1aXJlKCdub2RlOnN0cmVhbS93ZWInKSk7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nID0gZW1pdFdhcm5pbmc7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcgPSBlbWl0V2FybmluZztcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIGZhbGxiYWNrIHRvIHBvbHlmaWxsIGltcGxlbWVudGF0aW9uXG4gICAgT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCByZXF1aXJlUG9ueWZpbGxfZXMyMDE4KCkpO1xuICB9XG59XG5cbnRyeSB7XG4gIC8vIERvbid0IHVzZSBub2RlOiBwcmVmaXggZm9yIHRoaXMsIHJlcXVpcmUrbm9kZTogaXMgbm90IHN1cHBvcnRlZCB1bnRpbCBub2RlIHYxNC4xNFxuICAvLyBPbmx5IGBpbXBvcnQoKWAgY2FuIHVzZSBwcmVmaXggaW4gMTIuMjAgYW5kIGxhdGVyXG4gIGNvbnN0IHsgQmxvYiB9ID0gcmVxdWlyZSgnYnVmZmVyJyk7XG4gIGlmIChCbG9iICYmICFCbG9iLnByb3RvdHlwZS5zdHJlYW0pIHtcbiAgICBCbG9iLnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbiBuYW1lIChwYXJhbXMpIHtcbiAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgICBjb25zdCBibG9iID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgIGFzeW5jIHB1bGwgKGN0cmwpIHtcbiAgICAgICAgICBjb25zdCBjaHVuayA9IGJsb2Iuc2xpY2UocG9zaXRpb24sIE1hdGgubWluKGJsb2Iuc2l6ZSwgcG9zaXRpb24gKyBQT09MX1NJWkUkMSkpO1xuICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNodW5rLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgcG9zaXRpb24gKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgY3RybC5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuXG4gICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBibG9iLnNpemUpIHtcbiAgICAgICAgICAgIGN0cmwuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgfVxufSBjYXRjaCAoZXJyb3IpIHt9XG5cbi8qISBmZXRjaC1ibG9iLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL1xuXG4vLyA2NCBLaUIgKHNhbWUgc2l6ZSBjaHJvbWUgc2xpY2UgdGhlaXJzIGJsb2IgaW50byBVaW50OGFycmF5J3MpXG5jb25zdCBQT09MX1NJWkUgPSA2NTUzNjtcblxuLyoqIEBwYXJhbSB7KEJsb2IgfCBVaW50OEFycmF5KVtdfSBwYXJ0cyAqL1xuYXN5bmMgZnVuY3Rpb24gKiB0b0l0ZXJhdG9yIChwYXJ0cywgY2xvbmUgPSB0cnVlKSB7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmICgnc3RyZWFtJyBpbiBwYXJ0KSB7XG4gICAgICB5aWVsZCAqICgvKiogQHR5cGUge0FzeW5jSXRlcmFibGVJdGVyYXRvcjxVaW50OEFycmF5Pn0gKi8gKHBhcnQuc3RyZWFtKCkpKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSkge1xuICAgICAgaWYgKGNsb25lKSB7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IHBhcnQuYnl0ZU9mZnNldDtcbiAgICAgICAgY29uc3QgZW5kID0gcGFydC5ieXRlT2Zmc2V0ICsgcGFydC5ieXRlTGVuZ3RoO1xuICAgICAgICB3aGlsZSAocG9zaXRpb24gIT09IGVuZCkge1xuICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbihlbmQgLSBwb3NpdGlvbiwgUE9PTF9TSVpFKTtcbiAgICAgICAgICBjb25zdCBjaHVuayA9IHBhcnQuYnVmZmVyLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHNpemUpO1xuICAgICAgICAgIHBvc2l0aW9uICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgeWllbGQgbmV3IFVpbnQ4QXJyYXkoY2h1bmspO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBwYXJ0O1xuICAgICAgfVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDEwICovXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBibG9icyB0aGF0IGhhdmUgYXJyYXlCdWZmZXIgYnV0IG5vIHN0cmVhbSBtZXRob2QgKG5vZGVzIGJ1ZmZlci5CbG9iKVxuICAgICAgbGV0IHBvc2l0aW9uID0gMCwgYiA9ICgvKiogQHR5cGUge0Jsb2J9ICovIChwYXJ0KSk7XG4gICAgICB3aGlsZSAocG9zaXRpb24gIT09IGIuc2l6ZSkge1xuICAgICAgICBjb25zdCBjaHVuayA9IGIuc2xpY2UocG9zaXRpb24sIE1hdGgubWluKGIuc2l6ZSwgcG9zaXRpb24gKyBQT09MX1NJWkUpKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgY2h1bmsuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcG9zaXRpb24gKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIHlpZWxkIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IF9CbG9iID0gY2xhc3MgQmxvYiB7XG4gIC8qKiBAdHlwZSB7QXJyYXkuPChCbG9ifFVpbnQ4QXJyYXkpPn0gKi9cbiAgI3BhcnRzID0gW11cbiAgI3R5cGUgPSAnJ1xuICAjc2l6ZSA9IDBcbiAgI2VuZGluZ3MgPSAndHJhbnNwYXJlbnQnXG5cbiAgLyoqXG4gICAqIFRoZSBCbG9iKCkgY29uc3RydWN0b3IgcmV0dXJucyBhIG5ldyBCbG9iIG9iamVjdC4gVGhlIGNvbnRlbnRcbiAgICogb2YgdGhlIGJsb2IgY29uc2lzdHMgb2YgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIHZhbHVlcyBnaXZlblxuICAgKiBpbiB0aGUgcGFyYW1ldGVyIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGJsb2JQYXJ0c1xuICAgKiBAcGFyYW0ge3sgdHlwZT86IHN0cmluZywgZW5kaW5ncz86IHN0cmluZyB9fSBbb3B0aW9uc11cbiAgICovXG4gIGNvbnN0cnVjdG9yIChibG9iUGFydHMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBibG9iUGFydHMgIT09ICdvYmplY3QnIHx8IGJsb2JQYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGNvbnN0cnVjdCBcXCdCbG9iXFwnOiBUaGUgcHJvdmlkZWQgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIHNlcXVlbmNlLicpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBibG9iUGFydHNbU3ltYm9sLml0ZXJhdG9yXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGNvbnN0cnVjdCBcXCdCbG9iXFwnOiBUaGUgb2JqZWN0IG11c3QgaGF2ZSBhIGNhbGxhYmxlIEBAaXRlcmF0b3IgcHJvcGVydHkuJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ0Jsb2JcXCc6IHBhcmFtZXRlciAyIGNhbm5vdCBjb252ZXJ0IHRvIGRpY3Rpb25hcnkuJylcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCkgb3B0aW9ucyA9IHt9O1xuXG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBibG9iUGFydHMpIHtcbiAgICAgIGxldCBwYXJ0O1xuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhlbGVtZW50KSkge1xuICAgICAgICBwYXJ0ID0gbmV3IFVpbnQ4QXJyYXkoZWxlbWVudC5idWZmZXIuc2xpY2UoZWxlbWVudC5ieXRlT2Zmc2V0LCBlbGVtZW50LmJ5dGVPZmZzZXQgKyBlbGVtZW50LmJ5dGVMZW5ndGgpKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHBhcnQgPSBuZXcgVWludDhBcnJheShlbGVtZW50LnNsaWNlKDApKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgcGFydCA9IGVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0ID0gZW5jb2Rlci5lbmNvZGUoYCR7ZWxlbWVudH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2l6ZSA9IEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSA/IHBhcnQuYnl0ZUxlbmd0aCA6IHBhcnQuc2l6ZTtcbiAgICAgIC8vIEF2b2lkIHB1c2hpbmcgZW1wdHkgcGFydHMgaW50byB0aGUgYXJyYXkgdG8gYmV0dGVyIEdDIHRoZW1cbiAgICAgIGlmIChzaXplKSB7XG4gICAgICAgIHRoaXMuI3NpemUgKz0gc2l6ZTtcbiAgICAgICAgdGhpcy4jcGFydHMucHVzaChwYXJ0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLiNlbmRpbmdzID0gYCR7b3B0aW9ucy5lbmRpbmdzID09PSB1bmRlZmluZWQgPyAndHJhbnNwYXJlbnQnIDogb3B0aW9ucy5lbmRpbmdzfWA7XG4gICAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcob3B0aW9ucy50eXBlKTtcbiAgICB0aGlzLiN0eXBlID0gL15bXFx4MjAtXFx4N0VdKiQvLnRlc3QodHlwZSkgPyB0eXBlIDogJyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIEJsb2IgaW50ZXJmYWNlJ3Mgc2l6ZSBwcm9wZXJ0eSByZXR1cm5zIHRoZVxuICAgKiBzaXplIG9mIHRoZSBCbG9iIGluIGJ5dGVzLlxuICAgKi9cbiAgZ2V0IHNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLiNzaXplXG4gIH1cblxuICAvKipcbiAgICogVGhlIHR5cGUgcHJvcGVydHkgb2YgYSBCbG9iIG9iamVjdCByZXR1cm5zIHRoZSBNSU1FIHR5cGUgb2YgdGhlIGZpbGUuXG4gICAqL1xuICBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3R5cGVcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCgpIG1ldGhvZCBpbiB0aGUgQmxvYiBpbnRlcmZhY2UgcmV0dXJucyBhIFByb21pc2VcbiAgICogdGhhdCByZXNvbHZlcyB3aXRoIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGNvbnRlbnRzIG9mXG4gICAqIHRoZSBibG9iLCBpbnRlcnByZXRlZCBhcyBVVEYtOC5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuICAgKi9cbiAgYXN5bmMgdGV4dCAoKSB7XG4gICAgLy8gTW9yZSBvcHRpbWl6ZWQgdGhhbiB1c2luZyB0aGlzLmFycmF5QnVmZmVyKClcbiAgICAvLyB0aGF0IHJlcXVpcmVzIHR3aWNlIGFzIG11Y2ggcmFtXG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgdG9JdGVyYXRvcih0aGlzLiNwYXJ0cywgZmFsc2UpKSB7XG4gICAgICBzdHIgKz0gZGVjb2Rlci5kZWNvZGUocGFydCwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfVxuICAgIC8vIFJlbWFpbmluZ1xuICAgIHN0ciArPSBkZWNvZGVyLmRlY29kZSgpO1xuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYXJyYXlCdWZmZXIoKSBtZXRob2QgaW4gdGhlIEJsb2IgaW50ZXJmYWNlIHJldHVybnMgYVxuICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIGJsb2IgYXNcbiAgICogYmluYXJ5IGRhdGEgY29udGFpbmVkIGluIGFuIEFycmF5QnVmZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cbiAgICovXG4gIGFzeW5jIGFycmF5QnVmZmVyICgpIHtcbiAgICAvLyBFYXNpZXIgd2F5Li4uIEp1c3QgYSB1bm5lY2Vzc2FyeSBvdmVyaGVhZFxuICAgIC8vIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemUpO1xuICAgIC8vIGF3YWl0IHRoaXMuc3RyZWFtKCkuZ2V0UmVhZGVyKHttb2RlOiAnYnlvYid9KS5yZWFkKHZpZXcpO1xuICAgIC8vIHJldHVybiB2aWV3LmJ1ZmZlcjtcblxuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemUpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdG9JdGVyYXRvcih0aGlzLiNwYXJ0cywgZmFsc2UpKSB7XG4gICAgICBkYXRhLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEuYnVmZmVyXG4gIH1cblxuICBzdHJlYW0gKCkge1xuICAgIGNvbnN0IGl0ID0gdG9JdGVyYXRvcih0aGlzLiNwYXJ0cywgdHJ1ZSk7XG5cbiAgICByZXR1cm4gbmV3IGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0oe1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgIGFzeW5jIHB1bGwgKGN0cmwpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgIGNodW5rLmRvbmUgPyBjdHJsLmNsb3NlKCkgOiBjdHJsLmVucXVldWUoY2h1bmsudmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgYXN5bmMgY2FuY2VsICgpIHtcbiAgICAgICAgYXdhaXQgaXQucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQmxvYiBpbnRlcmZhY2UncyBzbGljZSgpIG1ldGhvZCBjcmVhdGVzIGFuZCByZXR1cm5zIGFcbiAgICogbmV3IEJsb2Igb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGRhdGEgZnJvbSBhIHN1YnNldCBvZiB0aGVcbiAgICogYmxvYiBvbiB3aGljaCBpdCdzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV1cbiAgICovXG4gIHNsaWNlIChzdGFydCA9IDAsIGVuZCA9IHRoaXMuc2l6ZSwgdHlwZSA9ICcnKSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSB0aGlzO1xuXG4gICAgbGV0IHJlbGF0aXZlU3RhcnQgPSBzdGFydCA8IDAgPyBNYXRoLm1heChzaXplICsgc3RhcnQsIDApIDogTWF0aC5taW4oc3RhcnQsIHNpemUpO1xuICAgIGxldCByZWxhdGl2ZUVuZCA9IGVuZCA8IDAgPyBNYXRoLm1heChzaXplICsgZW5kLCAwKSA6IE1hdGgubWluKGVuZCwgc2l6ZSk7XG5cbiAgICBjb25zdCBzcGFuID0gTWF0aC5tYXgocmVsYXRpdmVFbmQgLSByZWxhdGl2ZVN0YXJ0LCAwKTtcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMuI3BhcnRzO1xuICAgIGNvbnN0IGJsb2JQYXJ0cyA9IFtdO1xuICAgIGxldCBhZGRlZCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIC8vIGRvbid0IGFkZCB0aGUgb3ZlcmZsb3cgdG8gbmV3IGJsb2JQYXJ0c1xuICAgICAgaWYgKGFkZGVkID49IHNwYW4pIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2l6ZSA9IEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSA/IHBhcnQuYnl0ZUxlbmd0aCA6IHBhcnQuc2l6ZTtcbiAgICAgIGlmIChyZWxhdGl2ZVN0YXJ0ICYmIHNpemUgPD0gcmVsYXRpdmVTdGFydCkge1xuICAgICAgICAvLyBTa2lwIHRoZSBiZWdpbm5pbmcgYW5kIGNoYW5nZSB0aGUgcmVsYXRpdmVcbiAgICAgICAgLy8gc3RhcnQgJiBlbmQgcG9zaXRpb24gYXMgd2Ugc2tpcCB0aGUgdW53YW50ZWQgcGFydHNcbiAgICAgICAgcmVsYXRpdmVTdGFydCAtPSBzaXplO1xuICAgICAgICByZWxhdGl2ZUVuZCAtPSBzaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNodW5rO1xuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpKSB7XG4gICAgICAgICAgY2h1bmsgPSBwYXJ0LnN1YmFycmF5KHJlbGF0aXZlU3RhcnQsIE1hdGgubWluKHNpemUsIHJlbGF0aXZlRW5kKSk7XG4gICAgICAgICAgYWRkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaHVuayA9IHBhcnQuc2xpY2UocmVsYXRpdmVTdGFydCwgTWF0aC5taW4oc2l6ZSwgcmVsYXRpdmVFbmQpKTtcbiAgICAgICAgICBhZGRlZCArPSBjaHVuay5zaXplO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF0aXZlRW5kIC09IHNpemU7XG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgcmVsYXRpdmVTdGFydCA9IDA7IC8vIEFsbCBuZXh0IHNlcXVlbnRpYWwgcGFydHMgc2hvdWxkIHN0YXJ0IGF0IDBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW10sIHsgdHlwZTogU3RyaW5nKHR5cGUpLnRvTG93ZXJDYXNlKCkgfSk7XG4gICAgYmxvYi4jc2l6ZSA9IHNwYW47XG4gICAgYmxvYi4jcGFydHMgPSBibG9iUGFydHM7XG5cbiAgICByZXR1cm4gYmxvYlxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICByZXR1cm4gJ0Jsb2InXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKG9iamVjdCkge1xuICAgIHJldHVybiAoXG4gICAgICBvYmplY3QgJiZcbiAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoXG4gICAgICAgIHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICkgJiZcbiAgICAgIC9eKEJsb2J8RmlsZSkkLy50ZXN0KG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddKVxuICAgIClcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX0Jsb2IucHJvdG90eXBlLCB7XG4gIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB0eXBlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc2xpY2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpcy5CbG9ifSAqL1xuY29uc3QgQmxvYiA9IF9CbG9iO1xuY29uc3QgX0Jsb2IkMSA9IEJsb2I7XG5cbmNvbnN0IF9GaWxlID0gY2xhc3MgRmlsZSBleHRlbmRzIF9CbG9iJDEge1xuICAjbGFzdE1vZGlmaWVkID0gMFxuICAjbmFtZSA9ICcnXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KltdfSBmaWxlQml0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZU5hbWVcbiAgICogQHBhcmFtIHt7bGFzdE1vZGlmaWVkPzogbnVtYmVyLCB0eXBlPzogc3RyaW5nfX0gb3B0aW9uc1xuICAgKi8vLyBAdHMtaWdub3JlXG4gIGNvbnN0cnVjdG9yIChmaWxlQml0cywgZmlsZU5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGNvbnN0cnVjdCAnRmlsZSc6IDIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYClcbiAgICB9XG4gICAgc3VwZXIoZmlsZUJpdHMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwpIG9wdGlvbnMgPSB7fTtcblxuICAgIC8vIFNpbXVsYXRlIFdlYklETCB0eXBlIGNhc3RpbmcgZm9yIE5hTiB2YWx1ZSBpbiBsYXN0TW9kaWZpZWQgb3B0aW9uLlxuICAgIGNvbnN0IGxhc3RNb2RpZmllZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkID09PSB1bmRlZmluZWQgPyBEYXRlLm5vdygpIDogTnVtYmVyKG9wdGlvbnMubGFzdE1vZGlmaWVkKTtcbiAgICBpZiAoIU51bWJlci5pc05hTihsYXN0TW9kaWZpZWQpKSB7XG4gICAgICB0aGlzLiNsYXN0TW9kaWZpZWQgPSBsYXN0TW9kaWZpZWQ7XG4gICAgfVxuXG4gICAgdGhpcy4jbmFtZSA9IFN0cmluZyhmaWxlTmFtZSk7XG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI25hbWVcbiAgfVxuXG4gIGdldCBsYXN0TW9kaWZpZWQgKCkge1xuICAgIHJldHVybiB0aGlzLiNsYXN0TW9kaWZpZWRcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdGaWxlJ1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChvYmplY3QpIHtcbiAgICByZXR1cm4gISFvYmplY3QgJiYgb2JqZWN0IGluc3RhbmNlb2YgX0Jsb2IkMSAmJlxuICAgICAgL14oRmlsZSkkLy50ZXN0KG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddKVxuICB9XG59O1xuXG4vKiogQHR5cGUge3R5cGVvZiBnbG9iYWxUaGlzLkZpbGV9ICovLy8gQHRzLWlnbm9yZVxuY29uc3QgRmlsZSA9IF9GaWxlO1xuY29uc3QgRmlsZSQxID0gRmlsZTtcblxuLyohIGZvcm1kYXRhLXBvbHlmaWxsLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL1xuXG52YXIge3RvU3RyaW5nVGFnOnQsaXRlcmF0b3I6aSxoYXNJbnN0YW5jZTpofT1TeW1ib2wsXG5yPU1hdGgucmFuZG9tLFxubT0nYXBwZW5kLHNldCxnZXQsZ2V0QWxsLGRlbGV0ZSxrZXlzLHZhbHVlcyxlbnRyaWVzLGZvckVhY2gsY29uc3RydWN0b3InLnNwbGl0KCcsJyksXG5mPShhLGIsYyk9PihhKz0nJywvXihCbG9ifEZpbGUpJC8udGVzdChiICYmIGJbdF0pP1soYz1jIT09dm9pZCAwP2MrJyc6Ylt0XT09J0ZpbGUnP2IubmFtZTonYmxvYicsYSksYi5uYW1lIT09Y3x8Ylt0XT09J2Jsb2InP25ldyBGaWxlJDEoW2JdLGMsYik6Yl06W2EsYisnJ10pLFxuZT0oYyxmKT0+KGY/YzpjLnJlcGxhY2UoL1xccj9cXG58XFxyL2csJ1xcclxcbicpKS5yZXBsYWNlKC9cXG4vZywnJTBBJykucmVwbGFjZSgvXFxyL2csJyUwRCcpLnJlcGxhY2UoL1wiL2csJyUyMicpLFxueD0obiwgYSwgZSk9PntpZihhLmxlbmd0aDxlKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnJHtufScgb24gJ0Zvcm1EYXRhJzogJHtlfSBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YS5sZW5ndGh9IHByZXNlbnQuYCl9fTtcblxuLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpcy5Gb3JtRGF0YX0gKi9cbmNvbnN0IEZvcm1EYXRhID0gY2xhc3MgRm9ybURhdGEge1xuI2Q9W107XG5jb25zdHJ1Y3RvciguLi5hKXtpZihhLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gY29uc3RydWN0ICdGb3JtRGF0YSc6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdIVE1MRm9ybUVsZW1lbnQnLmApfVxuZ2V0IFt0XSgpIHtyZXR1cm4gJ0Zvcm1EYXRhJ31cbltpXSgpe3JldHVybiB0aGlzLmVudHJpZXMoKX1cbnN0YXRpYyBbaF0obykge3JldHVybiBvJiZ0eXBlb2Ygbz09PSdvYmplY3QnJiZvW3RdPT09J0Zvcm1EYXRhJyYmIW0uc29tZShtPT50eXBlb2Ygb1ttXSE9J2Z1bmN0aW9uJyl9XG5hcHBlbmQoLi4uYSl7eCgnYXBwZW5kJyxhcmd1bWVudHMsMik7dGhpcy4jZC5wdXNoKGYoLi4uYSkpO31cbmRlbGV0ZShhKXt4KCdkZWxldGUnLGFyZ3VtZW50cywxKTthKz0nJzt0aGlzLiNkPXRoaXMuI2QuZmlsdGVyKChbYl0pPT5iIT09YSk7fVxuZ2V0KGEpe3goJ2dldCcsYXJndW1lbnRzLDEpO2ErPScnO2Zvcih2YXIgYj10aGlzLiNkLGw9Yi5sZW5ndGgsYz0wO2M8bDtjKyspaWYoYltjXVswXT09PWEpcmV0dXJuIGJbY11bMV07cmV0dXJuIG51bGx9XG5nZXRBbGwoYSxiKXt4KCdnZXRBbGwnLGFyZ3VtZW50cywxKTtiPVtdO2ErPScnO3RoaXMuI2QuZm9yRWFjaChjPT5jWzBdPT09YSYmYi5wdXNoKGNbMV0pKTtyZXR1cm4gYn1cbmhhcyhhKXt4KCdoYXMnLGFyZ3VtZW50cywxKTthKz0nJztyZXR1cm4gdGhpcy4jZC5zb21lKGI9PmJbMF09PT1hKX1cbmZvckVhY2goYSxiKXt4KCdmb3JFYWNoJyxhcmd1bWVudHMsMSk7Zm9yKHZhciBbYyxkXW9mIHRoaXMpYS5jYWxsKGIsZCxjLHRoaXMpO31cbnNldCguLi5hKXt4KCdzZXQnLGFyZ3VtZW50cywyKTt2YXIgYj1bXSxjPSEwO2E9ZiguLi5hKTt0aGlzLiNkLmZvckVhY2goZD0+e2RbMF09PT1hWzBdP2MmJihjPSFiLnB1c2goYSkpOmIucHVzaChkKTt9KTtjJiZiLnB1c2goYSk7dGhpcy4jZD1iO31cbiplbnRyaWVzKCl7eWllbGQqdGhpcy4jZDt9XG4qa2V5cygpe2Zvcih2YXJbYV1vZiB0aGlzKXlpZWxkIGE7fVxuKnZhbHVlcygpe2Zvcih2YXJbLGFdb2YgdGhpcyl5aWVsZCBhO319O1xuXG4vKiogQHBhcmFtIHtGb3JtRGF0YX0gRiAqL1xuZnVuY3Rpb24gZm9ybURhdGFUb0Jsb2IgKEYsQj1fQmxvYiQxKXtcbnZhciBiPWAke3IoKX0ke3IoKX1gLnJlcGxhY2UoL1xcLi9nLCAnJykuc2xpY2UoLTI4KS5wYWRTdGFydCgzMiwgJy0nKSxjPVtdLHA9YC0tJHtifVxcclxcbkNvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cImA7XG5GLmZvckVhY2goKHYsbik9PnR5cGVvZiB2PT0nc3RyaW5nJ1xuP2MucHVzaChwK2UobikrYFwiXFxyXFxuXFxyXFxuJHt2LnJlcGxhY2UoL1xccig/IVxcbil8KD88IVxccilcXG4vZywgJ1xcclxcbicpfVxcclxcbmApXG46Yy5wdXNoKHArZShuKStgXCI7IGZpbGVuYW1lPVwiJHtlKHYubmFtZSwgMSl9XCJcXHJcXG5Db250ZW50LVR5cGU6ICR7di50eXBlfHxcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifVxcclxcblxcclxcbmAsIHYsICdcXHJcXG4nKSk7XG5jLnB1c2goYC0tJHtifS0tYCk7XG5yZXR1cm4gbmV3IEIoYyx7dHlwZTpcIm11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PVwiK2J9KX1cblxuY2xhc3MgRmV0Y2hCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHR5cGUpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHQvLyBIaWRlIGN1c3RvbSBlcnJvciBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIGZyb20gZW5kLXVzZXJzXG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG5cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHR9XG5cblx0Z2V0IG5hbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0fVxuXG5cdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXHR9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge3sgYWRkcmVzcz86IHN0cmluZywgY29kZTogc3RyaW5nLCBkZXN0Pzogc3RyaW5nLCBlcnJubzogbnVtYmVyLCBpbmZvPzogb2JqZWN0LCBtZXNzYWdlOiBzdHJpbmcsIHBhdGg/OiBzdHJpbmcsIHBvcnQ/OiBudW1iZXIsIHN5c2NhbGw6IHN0cmluZ319IFN5c3RlbUVycm9yXG4qL1xuXG4vKipcbiAqIEZldGNoRXJyb3IgaW50ZXJmYWNlIGZvciBvcGVyYXRpb25hbCBlcnJvcnNcbiAqL1xuY2xhc3MgRmV0Y2hFcnJvciBleHRlbmRzIEZldGNoQmFzZUVycm9yIHtcblx0LyoqXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gbWVzc2FnZSAtICAgICAgRXJyb3IgbWVzc2FnZSBmb3IgaHVtYW5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBbdHlwZV0gLSAgICAgICAgRXJyb3IgdHlwZSBmb3IgbWFjaGluZVxuXHQgKiBAcGFyYW0gIHtTeXN0ZW1FcnJvcn0gW3N5c3RlbUVycm9yXSAtIEZvciBOb2RlLmpzIHN5c3RlbSBlcnJvclxuXHQgKi9cblx0Y29uc3RydWN0b3IobWVzc2FnZSwgdHlwZSwgc3lzdGVtRXJyb3IpIHtcblx0XHRzdXBlcihtZXNzYWdlLCB0eXBlKTtcblx0XHQvLyBXaGVuIGVyci50eXBlIGlzIGBzeXN0ZW1gLCBlcnIuZXJyb3JlZFN5c0NhbGwgY29udGFpbnMgc3lzdGVtIGVycm9yIGFuZCBlcnIuY29kZSBjb250YWlucyBzeXN0ZW0gZXJyb3IgY29kZVxuXHRcdGlmIChzeXN0ZW1FcnJvcikge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuXHRcdFx0dGhpcy5jb2RlID0gdGhpcy5lcnJubyA9IHN5c3RlbUVycm9yLmNvZGU7XG5cdFx0XHR0aGlzLmVycm9yZWRTeXNDYWxsID0gc3lzdGVtRXJyb3Iuc3lzY2FsbDtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBJcy5qc1xuICpcbiAqIE9iamVjdCB0eXBlIGNoZWNrcy5cbiAqL1xuXG5jb25zdCBOQU1FID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICogcmVmOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8yOTYjaXNzdWVjb21tZW50LTMwNzU5ODE0M1xuICogQHBhcmFtIHsqfSBvYmplY3QgLSBPYmplY3QgdG8gY2hlY2sgZm9yXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBpc1VSTFNlYXJjaFBhcmFtZXRlcnMgPSBvYmplY3QgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIG9iamVjdC5hcHBlbmQgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmRlbGV0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBvYmplY3QuZ2V0ID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5nZXRBbGwgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmhhcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBvYmplY3Quc2V0ID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5zb3J0ID09PSAnZnVuY3Rpb24nICYmXG5cdFx0b2JqZWN0W05BTUVdID09PSAnVVJMU2VhcmNoUGFyYW1zJ1xuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqZWN0YCBpcyBhIFczQyBgQmxvYmAgb2JqZWN0ICh3aGljaCBgRmlsZWAgaW5oZXJpdHMgZnJvbSlcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrIGZvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNCbG9iID0gb2JqZWN0ID0+IHtcblx0cmV0dXJuIChcblx0XHRvYmplY3QgJiZcblx0XHR0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnR5cGUgPT09ICdzdHJpbmcnICYmXG5cdFx0dHlwZW9mIG9iamVjdC5zdHJlYW0gPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmXG5cdFx0L14oQmxvYnxGaWxlKSQvLnRlc3Qob2JqZWN0W05BTUVdKVxuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBpbnN0YW5jZSBvZiBBYm9ydFNpZ25hbC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrIGZvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNBYm9ydFNpZ25hbCA9IG9iamVjdCA9PiB7XG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgKFxuXHRcdFx0b2JqZWN0W05BTUVdID09PSAnQWJvcnRTaWduYWwnIHx8XG5cdFx0XHRvYmplY3RbTkFNRV0gPT09ICdFdmVudFRhcmdldCdcblx0XHQpXG5cdCk7XG59O1xuXG4vKipcbiAqIGlzRG9tYWluT3JTdWJkb21haW4gcmVwb3J0cyB3aGV0aGVyIHN1YiBpcyBhIHN1YmRvbWFpbiAob3IgZXhhY3QgbWF0Y2gpIG9mXG4gKiB0aGUgcGFyZW50IGRvbWFpbi5cbiAqXG4gKiBCb3RoIGRvbWFpbnMgbXVzdCBhbHJlYWR5IGJlIGluIGNhbm9uaWNhbCBmb3JtLlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSBvcmlnaW5hbFxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSBkZXN0aW5hdGlvblxuICovXG5jb25zdCBpc0RvbWFpbk9yU3ViZG9tYWluID0gKGRlc3RpbmF0aW9uLCBvcmlnaW5hbCkgPT4ge1xuXHRjb25zdCBvcmlnID0gbmV3IFVSTChvcmlnaW5hbCkuaG9zdG5hbWU7XG5cdGNvbnN0IGRlc3QgPSBuZXcgVVJMKGRlc3RpbmF0aW9uKS5ob3N0bmFtZTtcblxuXHRyZXR1cm4gb3JpZyA9PT0gZGVzdCB8fCBvcmlnLmVuZHNXaXRoKGAuJHtkZXN0fWApO1xufTtcblxuLyoqXG4gKiBpc1NhbWVQcm90b2NvbCByZXBvcnRzIHdoZXRoZXIgdGhlIHR3byBwcm92aWRlZCBVUkxzIHVzZSB0aGUgc2FtZSBwcm90b2NvbC5cbiAqXG4gKiBCb3RoIGRvbWFpbnMgbXVzdCBhbHJlYWR5IGJlIGluIGNhbm9uaWNhbCBmb3JtLlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSBvcmlnaW5hbFxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSBkZXN0aW5hdGlvblxuICovXG5jb25zdCBpc1NhbWVQcm90b2NvbCA9IChkZXN0aW5hdGlvbiwgb3JpZ2luYWwpID0+IHtcblx0Y29uc3Qgb3JpZyA9IG5ldyBVUkwob3JpZ2luYWwpLnByb3RvY29sO1xuXHRjb25zdCBkZXN0ID0gbmV3IFVSTChkZXN0aW5hdGlvbikucHJvdG9jb2w7XG5cblx0cmV0dXJuIG9yaWcgPT09IGRlc3Q7XG59O1xuXG5jb25zdCBwaXBlbGluZSA9IG5vZGVfdXRpbC5wcm9taXNpZnkoU3RyZWFtLnBpcGVsaW5lKTtcbmNvbnN0IElOVEVSTkFMUyQyID0gU3ltYm9sKCdCb2R5IGludGVybmFscycpO1xuXG4vKipcbiAqIEJvZHkgbWl4aW5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5XG4gKlxuICogQHBhcmFtICAgU3RyZWFtICBib2R5ICBSZWFkYWJsZSBzdHJlYW1cbiAqIEBwYXJhbSAgIE9iamVjdCAgb3B0cyAgUmVzcG9uc2Ugb3B0aW9uc1xuICogQHJldHVybiAgVm9pZFxuICovXG5jbGFzcyBCb2R5IHtcblx0Y29uc3RydWN0b3IoYm9keSwge1xuXHRcdHNpemUgPSAwXG5cdH0gPSB7fSkge1xuXHRcdGxldCBib3VuZGFyeSA9IG51bGw7XG5cblx0XHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gQm9keSBpcyB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdFx0Ym9keSA9IG51bGw7XG5cdFx0fSBlbHNlIGlmIChpc1VSTFNlYXJjaFBhcmFtZXRlcnMoYm9keSkpIHtcblx0XHRcdC8vIEJvZHkgaXMgYSBVUkxTZWFyY2hQYXJhbXNcblx0XHRcdGJvZHkgPSBub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShib2R5LnRvU3RyaW5nKCkpO1xuXHRcdH0gZWxzZSBpZiAoaXNCbG9iKGJvZHkpKSA7IGVsc2UgaWYgKG5vZGVfYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihib2R5KSkgOyBlbHNlIGlmIChub2RlX3V0aWwudHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBBcnJheUJ1ZmZlclxuXHRcdFx0Ym9keSA9IG5vZGVfYnVmZmVyLkJ1ZmZlci5mcm9tKGJvZHkpO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG5cdFx0XHQvLyBCb2R5IGlzIEFycmF5QnVmZmVyVmlld1xuXHRcdFx0Ym9keSA9IG5vZGVfYnVmZmVyLkJ1ZmZlci5mcm9tKGJvZHkuYnVmZmVyLCBib2R5LmJ5dGVPZmZzZXQsIGJvZHkuYnl0ZUxlbmd0aCk7XG5cdFx0fSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSA7IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0Ly8gQm9keSBpcyBGb3JtRGF0YVxuXHRcdFx0Ym9keSA9IGZvcm1EYXRhVG9CbG9iKGJvZHkpO1xuXHRcdFx0Ym91bmRhcnkgPSBib2R5LnR5cGUuc3BsaXQoJz0nKVsxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gTm9uZSBvZiB0aGUgYWJvdmVcblx0XHRcdC8vIGNvZXJjZSB0byBzdHJpbmcgdGhlbiBidWZmZXJcblx0XHRcdGJvZHkgPSBub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShTdHJpbmcoYm9keSkpO1xuXHRcdH1cblxuXHRcdGxldCBzdHJlYW0gPSBib2R5O1xuXG5cdFx0aWYgKG5vZGVfYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuXHRcdFx0c3RyZWFtID0gU3RyZWFtLlJlYWRhYmxlLmZyb20oYm9keSk7XG5cdFx0fSBlbHNlIGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHRcdHN0cmVhbSA9IFN0cmVhbS5SZWFkYWJsZS5mcm9tKGJvZHkuc3RyZWFtKCkpO1xuXHRcdH1cblxuXHRcdHRoaXNbSU5URVJOQUxTJDJdID0ge1xuXHRcdFx0Ym9keSxcblx0XHRcdHN0cmVhbSxcblx0XHRcdGJvdW5kYXJ5LFxuXHRcdFx0ZGlzdHVyYmVkOiBmYWxzZSxcblx0XHRcdGVycm9yOiBudWxsXG5cdFx0fTtcblx0XHR0aGlzLnNpemUgPSBzaXplO1xuXG5cdFx0aWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcblx0XHRcdGJvZHkub24oJ2Vycm9yJywgZXJyb3JfID0+IHtcblx0XHRcdFx0Y29uc3QgZXJyb3IgPSBlcnJvcl8gaW5zdGFuY2VvZiBGZXRjaEJhc2VFcnJvciA/XG5cdFx0XHRcdFx0ZXJyb3JfIDpcblx0XHRcdFx0XHRuZXcgRmV0Y2hFcnJvcihgSW52YWxpZCByZXNwb25zZSBib2R5IHdoaWxlIHRyeWluZyB0byBmZXRjaCAke3RoaXMudXJsfTogJHtlcnJvcl8ubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyb3JfKTtcblx0XHRcdFx0dGhpc1tJTlRFUk5BTFMkMl0uZXJyb3IgPSBlcnJvcjtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGdldCBib2R5KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQyXS5zdHJlYW07XG5cdH1cblxuXHRnZXQgYm9keVVzZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDJdLmRpc3R1cmJlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGUgcmVzcG9uc2UgYXMgQXJyYXlCdWZmZXJcblx0ICpcblx0ICogQHJldHVybiAgUHJvbWlzZVxuXHQgKi9cblx0YXN5bmMgYXJyYXlCdWZmZXIoKSB7XG5cdFx0Y29uc3Qge2J1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aH0gPSBhd2FpdCBjb25zdW1lQm9keSh0aGlzKTtcblx0XHRyZXR1cm4gYnVmZmVyLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcblx0fVxuXG5cdGFzeW5jIGZvcm1EYXRhKCkge1xuXHRcdGNvbnN0IGN0ID0gdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG5cblx0XHRpZiAoY3Quc3RhcnRzV2l0aCgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykpIHtcblx0XHRcdGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0XHRjb25zdCBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhhd2FpdCB0aGlzLnRleHQoKSk7XG5cblx0XHRcdGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBwYXJhbWV0ZXJzKSB7XG5cdFx0XHRcdGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmb3JtRGF0YTtcblx0XHR9XG5cblx0XHRjb25zdCB7dG9Gb3JtRGF0YX0gPSBhd2FpdCBpbXBvcnQoJy4uL2NodW5rcy9tdWx0aXBhcnQtcGFyc2VyLmNqcycpO1xuXHRcdHJldHVybiB0b0Zvcm1EYXRhKHRoaXMuYm9keSwgY3QpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiByYXcgcmVzcG9uc2UgYXMgQmxvYlxuXHQgKlxuXHQgKiBAcmV0dXJuIFByb21pc2Vcblx0ICovXG5cdGFzeW5jIGJsb2IoKSB7XG5cdFx0Y29uc3QgY3QgPSAodGhpcy5oZWFkZXJzICYmIHRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB8fCAodGhpc1tJTlRFUk5BTFMkMl0uYm9keSAmJiB0aGlzW0lOVEVSTkFMUyQyXS5ib2R5LnR5cGUpIHx8ICcnO1xuXHRcdGNvbnN0IGJ1ZiA9IGF3YWl0IHRoaXMuYXJyYXlCdWZmZXIoKTtcblxuXHRcdHJldHVybiBuZXcgX0Jsb2IkMShbYnVmXSwge1xuXHRcdFx0dHlwZTogY3Rcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGUgcmVzcG9uc2UgYXMganNvblxuXHQgKlxuXHQgKiBAcmV0dXJuICBQcm9taXNlXG5cdCAqL1xuXHRhc3luYyBqc29uKCkge1xuXHRcdGNvbnN0IHRleHQgPSBhd2FpdCB0aGlzLnRleHQoKTtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGUgcmVzcG9uc2UgYXMgdGV4dFxuXHQgKlxuXHQgKiBAcmV0dXJuICBQcm9taXNlXG5cdCAqL1xuXHRhc3luYyB0ZXh0KCkge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNvbnN1bWVCb2R5KHRoaXMpO1xuXHRcdHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmZmVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGUgcmVzcG9uc2UgYXMgYnVmZmVyIChub24tc3BlYyBhcGkpXG5cdCAqXG5cdCAqIEByZXR1cm4gIFByb21pc2Vcblx0ICovXG5cdGJ1ZmZlcigpIHtcblx0XHRyZXR1cm4gY29uc3VtZUJvZHkodGhpcyk7XG5cdH1cbn1cblxuQm9keS5wcm90b3R5cGUuYnVmZmVyID0gbm9kZV91dGlsLmRlcHJlY2F0ZShCb2R5LnByb3RvdHlwZS5idWZmZXIsICdQbGVhc2UgdXNlIFxcJ3Jlc3BvbnNlLmFycmF5QnVmZmVyKClcXCcgaW5zdGVhZCBvZiBcXCdyZXNwb25zZS5idWZmZXIoKVxcJycsICdub2RlLWZldGNoI2J1ZmZlcicpO1xuXG4vLyBJbiBicm93c2VycywgYWxsIHByb3BlcnRpZXMgYXJlIGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCb2R5LnByb3RvdHlwZSwge1xuXHRib2R5OiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGJvZHlVc2VkOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGFycmF5QnVmZmVyOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGJsb2I6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0anNvbjoge2VudW1lcmFibGU6IHRydWV9LFxuXHR0ZXh0OiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGRhdGE6IHtnZXQ6IG5vZGVfdXRpbC5kZXByZWNhdGUoKCkgPT4ge30sXG5cdFx0J2RhdGEgZG9lc25cXCd0IGV4aXN0LCB1c2UganNvbigpLCB0ZXh0KCksIGFycmF5QnVmZmVyKCksIG9yIGJvZHkgaW5zdGVhZCcsXG5cdFx0J2h0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzEwMDAgKHJlc3BvbnNlKScpfVxufSk7XG5cbi8qKlxuICogQ29uc3VtZSBhbmQgY29udmVydCBhbiBlbnRpcmUgQm9keSB0byBhIEJ1ZmZlci5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY29uc3VtZS1ib2R5XG4gKlxuICogQHJldHVybiBQcm9taXNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVCb2R5KGRhdGEpIHtcblx0aWYgKGRhdGFbSU5URVJOQUxTJDJdLmRpc3R1cmJlZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYGJvZHkgdXNlZCBhbHJlYWR5IGZvcjogJHtkYXRhLnVybH1gKTtcblx0fVxuXG5cdGRhdGFbSU5URVJOQUxTJDJdLmRpc3R1cmJlZCA9IHRydWU7XG5cblx0aWYgKGRhdGFbSU5URVJOQUxTJDJdLmVycm9yKSB7XG5cdFx0dGhyb3cgZGF0YVtJTlRFUk5BTFMkMl0uZXJyb3I7XG5cdH1cblxuXHRjb25zdCB7Ym9keX0gPSBkYXRhO1xuXG5cdC8vIEJvZHkgaXMgbnVsbFxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBub2RlX2J1ZmZlci5CdWZmZXIuYWxsb2MoMCk7XG5cdH1cblxuXHQvKiBjOCBpZ25vcmUgbmV4dCAzICovXG5cdGlmICghKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pKSB7XG5cdFx0cmV0dXJuIG5vZGVfYnVmZmVyLkJ1ZmZlci5hbGxvYygwKTtcblx0fVxuXG5cdC8vIEJvZHkgaXMgc3RyZWFtXG5cdC8vIGdldCByZWFkeSB0byBhY3R1YWxseSBjb25zdW1lIHRoZSBib2R5XG5cdGNvbnN0IGFjY3VtID0gW107XG5cdGxldCBhY2N1bUJ5dGVzID0gMDtcblxuXHR0cnkge1xuXHRcdGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuXHRcdFx0aWYgKGRhdGEuc2l6ZSA+IDAgJiYgYWNjdW1CeXRlcyArIGNodW5rLmxlbmd0aCA+IGRhdGEuc2l6ZSkge1xuXHRcdFx0XHRjb25zdCBlcnJvciA9IG5ldyBGZXRjaEVycm9yKGBjb250ZW50IHNpemUgYXQgJHtkYXRhLnVybH0gb3ZlciBsaW1pdDogJHtkYXRhLnNpemV9YCwgJ21heC1zaXplJyk7XG5cdFx0XHRcdGJvZHkuZGVzdHJveShlcnJvcik7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXG5cdFx0XHRhY2N1bUJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblx0XHRcdGFjY3VtLnB1c2goY2h1bmspO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRjb25zdCBlcnJvcl8gPSBlcnJvciBpbnN0YW5jZW9mIEZldGNoQmFzZUVycm9yID8gZXJyb3IgOiBuZXcgRmV0Y2hFcnJvcihgSW52YWxpZCByZXNwb25zZSBib2R5IHdoaWxlIHRyeWluZyB0byBmZXRjaCAke2RhdGEudXJsfTogJHtlcnJvci5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlcnJvcik7XG5cdFx0dGhyb3cgZXJyb3JfO1xuXHR9XG5cblx0aWYgKGJvZHkucmVhZGFibGVFbmRlZCA9PT0gdHJ1ZSB8fCBib2R5Ll9yZWFkYWJsZVN0YXRlLmVuZGVkID09PSB0cnVlKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChhY2N1bS5ldmVyeShjID0+IHR5cGVvZiBjID09PSAnc3RyaW5nJykpIHtcblx0XHRcdFx0cmV0dXJuIG5vZGVfYnVmZmVyLkJ1ZmZlci5mcm9tKGFjY3VtLmpvaW4oJycpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5vZGVfYnVmZmVyLkJ1ZmZlci5jb25jYXQoYWNjdW0sIGFjY3VtQnl0ZXMpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBuZXcgRmV0Y2hFcnJvcihgQ291bGQgbm90IGNyZWF0ZSBCdWZmZXIgZnJvbSByZXNwb25zZSBib2R5IGZvciAke2RhdGEudXJsfTogJHtlcnJvci5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlcnJvcik7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBGZXRjaEVycm9yKGBQcmVtYXR1cmUgY2xvc2Ugb2Ygc2VydmVyIHJlc3BvbnNlIHdoaWxlIHRyeWluZyB0byBmZXRjaCAke2RhdGEudXJsfWApO1xuXHR9XG59XG5cbi8qKlxuICogQ2xvbmUgYm9keSBnaXZlbiBSZXMvUmVxIGluc3RhbmNlXG4gKlxuICogQHBhcmFtICAgTWl4ZWQgICBpbnN0YW5jZSAgICAgICBSZXNwb25zZSBvciBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcGFyYW0gICBTdHJpbmcgIGhpZ2hXYXRlck1hcmsgIGhpZ2hXYXRlck1hcmsgZm9yIGJvdGggUGFzc1Rocm91Z2ggYm9keSBzdHJlYW1zXG4gKiBAcmV0dXJuICBNaXhlZFxuICovXG5jb25zdCBjbG9uZSA9IChpbnN0YW5jZSwgaGlnaFdhdGVyTWFyaykgPT4ge1xuXHRsZXQgcDE7XG5cdGxldCBwMjtcblx0bGV0IHtib2R5fSA9IGluc3RhbmNlW0lOVEVSTkFMUyQyXTtcblxuXHQvLyBEb24ndCBhbGxvdyBjbG9uaW5nIGEgdXNlZCBib2R5XG5cdGlmIChpbnN0YW5jZS5ib2R5VXNlZCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignY2Fubm90IGNsb25lIGJvZHkgYWZ0ZXIgaXQgaXMgdXNlZCcpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgdGhhdCBib2R5IGlzIGEgc3RyZWFtIGFuZCBub3QgZm9ybS1kYXRhIG9iamVjdFxuXHQvLyBub3RlOiB3ZSBjYW4ndCBjbG9uZSB0aGUgZm9ybS1kYXRhIG9iamVjdCB3aXRob3V0IGhhdmluZyBpdCBhcyBhIGRlcGVuZGVuY3lcblx0aWYgKChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSAmJiAodHlwZW9mIGJvZHkuZ2V0Qm91bmRhcnkgIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0Ly8gVGVlIGluc3RhbmNlIGJvZHlcblx0XHRwMSA9IG5ldyBTdHJlYW0uUGFzc1Rocm91Z2goe2hpZ2hXYXRlck1hcmt9KTtcblx0XHRwMiA9IG5ldyBTdHJlYW0uUGFzc1Rocm91Z2goe2hpZ2hXYXRlck1hcmt9KTtcblx0XHRib2R5LnBpcGUocDEpO1xuXHRcdGJvZHkucGlwZShwMik7XG5cdFx0Ly8gU2V0IGluc3RhbmNlIGJvZHkgdG8gdGVlZCBib2R5IGFuZCByZXR1cm4gdGhlIG90aGVyIHRlZWQgYm9keVxuXHRcdGluc3RhbmNlW0lOVEVSTkFMUyQyXS5zdHJlYW0gPSBwMTtcblx0XHRib2R5ID0gcDI7XG5cdH1cblxuXHRyZXR1cm4gYm9keTtcbn07XG5cbmNvbnN0IGdldE5vblNwZWNGb3JtRGF0YUJvdW5kYXJ5ID0gbm9kZV91dGlsLmRlcHJlY2F0ZShcblx0Ym9keSA9PiBib2R5LmdldEJvdW5kYXJ5KCksXG5cdCdmb3JtLWRhdGEgZG9lc25cXCd0IGZvbGxvdyB0aGUgc3BlYyBhbmQgcmVxdWlyZXMgc3BlY2lhbCB0cmVhdG1lbnQuIFVzZSBhbHRlcm5hdGl2ZSBwYWNrYWdlJyxcblx0J2h0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzExNjcnXG4pO1xuXG4vKipcbiAqIFBlcmZvcm1zIHRoZSBvcGVyYXRpb24gXCJleHRyYWN0IGEgYENvbnRlbnQtVHlwZWAgdmFsdWUgZnJvbSB8b2JqZWN0fFwiIGFzXG4gKiBzcGVjaWZpZWQgaW4gdGhlIHNwZWNpZmljYXRpb246XG4gKiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5aW5pdC1leHRyYWN0XG4gKlxuICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgaW5zdGFuY2UuYm9keSBpcyBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7YW55fSBib2R5IEFueSBvcHRpb25zLmJvZHkgaW5wdXRcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICovXG5jb25zdCBleHRyYWN0Q29udGVudFR5cGUgPSAoYm9keSwgcmVxdWVzdCkgPT4ge1xuXHQvLyBCb2R5IGlzIG51bGwgb3IgdW5kZWZpbmVkXG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBCb2R5IGlzIHN0cmluZ1xuXHRpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBhIFVSTFNlYXJjaFBhcmFtc1xuXHRpZiAoaXNVUkxTZWFyY2hQYXJhbWV0ZXJzKGJvZHkpKSB7XG5cdFx0cmV0dXJuICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCc7XG5cdH1cblxuXHQvLyBCb2R5IGlzIGJsb2Jcblx0aWYgKGlzQmxvYihib2R5KSkge1xuXHRcdHJldHVybiBib2R5LnR5cGUgfHwgbnVsbDtcblx0fVxuXG5cdC8vIEJvZHkgaXMgYSBCdWZmZXIgKEJ1ZmZlciwgQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KVxuXHRpZiAobm9kZV9idWZmZXIuQnVmZmVyLmlzQnVmZmVyKGJvZHkpIHx8IG5vZGVfdXRpbC50eXBlcy5pc0FueUFycmF5QnVmZmVyKGJvZHkpIHx8IEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0aWYgKGJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdHJldHVybiBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JHtyZXF1ZXN0W0lOVEVSTkFMUyQyXS5ib3VuZGFyeX1gO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IGZvcm0gZGF0YSBpbnB1dCBmcm9tIGZvcm0tZGF0YSBtb2R1bGVcblx0aWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkuZ2V0Qm91bmRhcnkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gYG11bHRpcGFydC9mb3JtLWRhdGE7Ym91bmRhcnk9JHtnZXROb25TcGVjRm9ybURhdGFCb3VuZGFyeShib2R5KX1gO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBzdHJlYW0gLSBjYW4ndCByZWFsbHkgZG8gbXVjaCBhYm91dCB0aGlzXG5cdGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBCb2R5IGNvbnN0cnVjdG9yIGRlZmF1bHRzIG90aGVyIHRoaW5ncyB0byBzdHJpbmdcblx0cmV0dXJuICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xufTtcblxuLyoqXG4gKiBUaGUgRmV0Y2ggU3RhbmRhcmQgdHJlYXRzIHRoaXMgYXMgaWYgXCJ0b3RhbCBieXRlc1wiIGlzIGEgcHJvcGVydHkgb24gdGhlIGJvZHkuXG4gKiBGb3IgdXMsIHdlIGhhdmUgdG8gZXhwbGljaXRseSBnZXQgaXQgd2l0aCBhIGZ1bmN0aW9uLlxuICpcbiAqIHJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS10b3RhbC1ieXRlc1xuICpcbiAqIEBwYXJhbSB7YW55fSBvYmouYm9keSBCb2R5IG9iamVjdCBmcm9tIHRoZSBCb2R5IGluc3RhbmNlLlxuICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gKi9cbmNvbnN0IGdldFRvdGFsQnl0ZXMgPSByZXF1ZXN0ID0+IHtcblx0Y29uc3Qge2JvZHl9ID0gcmVxdWVzdFtJTlRFUk5BTFMkMl07XG5cblx0Ly8gQm9keSBpcyBudWxsIG9yIHVuZGVmaW5lZFxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBCbG9iXG5cdGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHRyZXR1cm4gYm9keS5zaXplO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBCdWZmZXJcblx0aWYgKG5vZGVfYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuXHRcdHJldHVybiBib2R5Lmxlbmd0aDtcblx0fVxuXG5cdC8vIERldGVjdCBmb3JtIGRhdGEgaW5wdXQgZnJvbSBmb3JtLWRhdGEgbW9kdWxlXG5cdGlmIChib2R5ICYmIHR5cGVvZiBib2R5LmdldExlbmd0aFN5bmMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gYm9keS5oYXNLbm93bkxlbmd0aCAmJiBib2R5Lmhhc0tub3duTGVuZ3RoKCkgPyBib2R5LmdldExlbmd0aFN5bmMoKSA6IG51bGw7XG5cdH1cblxuXHQvLyBCb2R5IGlzIHN0cmVhbVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogV3JpdGUgYSBCb2R5IHRvIGEgTm9kZS5qcyBXcml0YWJsZVN0cmVhbSAoZS5nLiBodHRwLlJlcXVlc3QpIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmVhbS5Xcml0YWJsZX0gZGVzdCBUaGUgc3RyZWFtIHRvIHdyaXRlIHRvLlxuICogQHBhcmFtIG9iai5ib2R5IEJvZHkgb2JqZWN0IGZyb20gdGhlIEJvZHkgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuY29uc3Qgd3JpdGVUb1N0cmVhbSA9IGFzeW5jIChkZXN0LCB7Ym9keX0pID0+IHtcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHQvLyBCb2R5IGlzIG51bGxcblx0XHRkZXN0LmVuZCgpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJvZHkgaXMgc3RyZWFtXG5cdFx0YXdhaXQgcGlwZWxpbmUoYm9keSwgZGVzdCk7XG5cdH1cbn07XG5cbi8qKlxuICogSGVhZGVycy5qc1xuICpcbiAqIEhlYWRlcnMgY2xhc3Mgb2ZmZXJzIGNvbnZlbmllbnQgaGVscGVyc1xuICovXG5cbi8qIGM4IGlnbm9yZSBuZXh0IDkgKi9cbmNvbnN0IHZhbGlkYXRlSGVhZGVyTmFtZSA9IHR5cGVvZiBodHRwLnZhbGlkYXRlSGVhZGVyTmFtZSA9PT0gJ2Z1bmN0aW9uJyA/XG5cdGh0dHAudmFsaWRhdGVIZWFkZXJOYW1lIDpcblx0bmFtZSA9PiB7XG5cdFx0aWYgKCEvXltcXF5gXFwtXFx3ISMkJSYnKisufH5dKyQvLnRlc3QobmFtZSkpIHtcblx0XHRcdGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcihgSGVhZGVyIG5hbWUgbXVzdCBiZSBhIHZhbGlkIEhUVFAgdG9rZW4gWyR7bmFtZX1dYCk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsICdjb2RlJywge3ZhbHVlOiAnRVJSX0lOVkFMSURfSFRUUF9UT0tFTid9KTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fTtcblxuLyogYzggaWdub3JlIG5leHQgOSAqL1xuY29uc3QgdmFsaWRhdGVIZWFkZXJWYWx1ZSA9IHR5cGVvZiBodHRwLnZhbGlkYXRlSGVhZGVyVmFsdWUgPT09ICdmdW5jdGlvbicgP1xuXHRodHRwLnZhbGlkYXRlSGVhZGVyVmFsdWUgOlxuXHQobmFtZSwgdmFsdWUpID0+IHtcblx0XHRpZiAoL1teXFx0XFx1MDAyMC1cXHUwMDdFXFx1MDA4MC1cXHUwMEZGXS8udGVzdCh2YWx1ZSkpIHtcblx0XHRcdGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGNvbnRlbnQgW1wiJHtuYW1lfVwiXWApO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yLCAnY29kZScsIHt2YWx1ZTogJ0VSUl9JTlZBTElEX0NIQVInfSk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH07XG5cbi8qKlxuICogQHR5cGVkZWYge0hlYWRlcnMgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgSXRlcmFibGU8cmVhZG9ubHkgW3N0cmluZywgc3RyaW5nXT4gfCBJdGVyYWJsZTxJdGVyYWJsZTxzdHJpbmc+Pn0gSGVhZGVyc0luaXRcbiAqL1xuXG4vKipcbiAqIFRoaXMgRmV0Y2ggQVBJIGludGVyZmFjZSBhbGxvd3MgeW91IHRvIHBlcmZvcm0gdmFyaW91cyBhY3Rpb25zIG9uIEhUVFAgcmVxdWVzdCBhbmQgcmVzcG9uc2UgaGVhZGVycy5cbiAqIFRoZXNlIGFjdGlvbnMgaW5jbHVkZSByZXRyaWV2aW5nLCBzZXR0aW5nLCBhZGRpbmcgdG8sIGFuZCByZW1vdmluZy5cbiAqIEEgSGVhZGVycyBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgaGVhZGVyIGxpc3QsIHdoaWNoIGlzIGluaXRpYWxseSBlbXB0eSBhbmQgY29uc2lzdHMgb2YgemVybyBvciBtb3JlIG5hbWUgYW5kIHZhbHVlIHBhaXJzLlxuICogWW91IGNhbiBhZGQgdG8gdGhpcyB1c2luZyBtZXRob2RzIGxpa2UgYXBwZW5kKCkgKHNlZSBFeGFtcGxlcy4pXG4gKiBJbiBhbGwgbWV0aG9kcyBvZiB0aGlzIGludGVyZmFjZSwgaGVhZGVyIG5hbWVzIGFyZSBtYXRjaGVkIGJ5IGNhc2UtaW5zZW5zaXRpdmUgYnl0ZSBzZXF1ZW5jZS5cbiAqXG4gKi9cbmNsYXNzIEhlYWRlcnMgZXh0ZW5kcyBVUkxTZWFyY2hQYXJhbXMge1xuXHQvKipcblx0ICogSGVhZGVycyBjbGFzc1xuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIZWFkZXJzSW5pdH0gW2luaXRdIC0gUmVzcG9uc2UgaGVhZGVyc1xuXHQgKi9cblx0Y29uc3RydWN0b3IoaW5pdCkge1xuXHRcdC8vIFZhbGlkYXRlIGFuZCBub3JtYWxpemUgaW5pdCBvYmplY3QgaW4gW25hbWUsIHZhbHVlKHMpXVtdXG5cdFx0LyoqIEB0eXBlIHtzdHJpbmdbXVtdfSAqL1xuXHRcdGxldCByZXN1bHQgPSBbXTtcblx0XHRpZiAoaW5pdCBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcblx0XHRcdGNvbnN0IHJhdyA9IGluaXQucmF3KCk7XG5cdFx0XHRmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZXNdIG9mIE9iamVjdC5lbnRyaWVzKHJhdykpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goLi4udmFsdWVzLm1hcCh2YWx1ZSA9PiBbbmFtZSwgdmFsdWVdKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChpbml0ID09IG51bGwpIDsgZWxzZSBpZiAodHlwZW9mIGluaXQgPT09ICdvYmplY3QnICYmICFub2RlX3V0aWwudHlwZXMuaXNCb3hlZFByaW1pdGl2ZShpbml0KSkge1xuXHRcdFx0Y29uc3QgbWV0aG9kID0gaW5pdFtTeW1ib2wuaXRlcmF0b3JdO1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdFx0aWYgKG1ldGhvZCA9PSBudWxsKSB7XG5cdFx0XHRcdC8vIFJlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPlxuXHRcdFx0XHRyZXN1bHQucHVzaCguLi5PYmplY3QuZW50cmllcyhpbml0KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlciBwYWlycyBtdXN0IGJlIGl0ZXJhYmxlJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj5cblx0XHRcdFx0Ly8gTm90ZTogcGVyIHNwZWMgd2UgaGF2ZSB0byBmaXJzdCBleGhhdXN0IHRoZSBsaXN0cyB0aGVuIHByb2Nlc3MgdGhlbVxuXHRcdFx0XHRyZXN1bHQgPSBbLi4uaW5pdF1cblx0XHRcdFx0XHQubWFwKHBhaXIgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHR0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcgfHwgbm9kZV91dGlsLnR5cGVzLmlzQm94ZWRQcmltaXRpdmUocGFpcilcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYW4gaXRlcmFibGUgb2JqZWN0Jyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBbLi4ucGFpcl07XG5cdFx0XHRcdFx0fSkubWFwKHBhaXIgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHBhaXIubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0VhY2ggaGVhZGVyIHBhaXIgbXVzdCBiZSBhIG5hbWUvdmFsdWUgdHVwbGUnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIFsuLi5wYWlyXTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGNvbnN0cnVjdCBcXCdIZWFkZXJzXFwnOiBUaGUgcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9mIHR5cGUgXFwnKHNlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PiBvciByZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4pJyk7XG5cdFx0fVxuXG5cdFx0Ly8gVmFsaWRhdGUgYW5kIGxvd2VyY2FzZVxuXHRcdHJlc3VsdCA9XG5cdFx0XHRyZXN1bHQubGVuZ3RoID4gMCA/XG5cdFx0XHRcdHJlc3VsdC5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IHtcblx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG5cdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJWYWx1ZShuYW1lLCBTdHJpbmcodmFsdWUpKTtcblx0XHRcdFx0XHRyZXR1cm4gW1N0cmluZyhuYW1lKS50b0xvd2VyQ2FzZSgpLCBTdHJpbmcodmFsdWUpXTtcblx0XHRcdFx0fSkgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cblx0XHRzdXBlcihyZXN1bHQpO1xuXG5cdFx0Ly8gUmV0dXJuaW5nIGEgUHJveHkgdGhhdCB3aWxsIGxvd2VyY2FzZSBrZXkgbmFtZXMsIHZhbGlkYXRlIHBhcmFtZXRlcnMgYW5kIHNvcnQga2V5c1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cblx0XHRyZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcblx0XHRcdGdldCh0YXJnZXQsIHAsIHJlY2VpdmVyKSB7XG5cdFx0XHRcdHN3aXRjaCAocCkge1xuXHRcdFx0XHRcdGNhc2UgJ2FwcGVuZCc6XG5cdFx0XHRcdFx0Y2FzZSAnc2V0Jzpcblx0XHRcdFx0XHRcdHJldHVybiAobmFtZSwgdmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuXHRcdFx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlclZhbHVlKG5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZVtwXS5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldCxcblx0XHRcdFx0XHRcdFx0XHRTdHJpbmcobmFtZSkudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdFx0XHRTdHJpbmcodmFsdWUpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Y2FzZSAnZGVsZXRlJzpcblx0XHRcdFx0XHRjYXNlICdoYXMnOlxuXHRcdFx0XHRcdGNhc2UgJ2dldEFsbCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmFtZSA9PiB7XG5cdFx0XHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbcF0uY2FsbChcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXQsXG5cdFx0XHRcdFx0XHRcdFx0U3RyaW5nKG5hbWUpLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRjYXNlICdrZXlzJzpcblx0XHRcdFx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldC5zb3J0KCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgU2V0KFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUua2V5cy5jYWxsKHRhcmdldCkpLmtleXMoKTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcCwgcmVjZWl2ZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0LyogYzggaWdub3JlIG5leHQgKi9cblx0fVxuXG5cdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKTtcblx0fVxuXG5cdGdldChuYW1lKSB7XG5cdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5nZXRBbGwobmFtZSk7XG5cdFx0aWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGxldCB2YWx1ZSA9IHZhbHVlcy5qb2luKCcsICcpO1xuXHRcdGlmICgvXmNvbnRlbnQtZW5jb2RpbmckL2kudGVzdChuYW1lKSkge1xuXHRcdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcgPSB1bmRlZmluZWQpIHtcblx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5rZXlzKCkpIHtcblx0XHRcdFJlZmxlY3QuYXBwbHkoY2FsbGJhY2ssIHRoaXNBcmcsIFt0aGlzLmdldChuYW1lKSwgbmFtZSwgdGhpc10pO1xuXHRcdH1cblx0fVxuXG5cdCogdmFsdWVzKCkge1xuXHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuXHRcdFx0eWllbGQgdGhpcy5nZXQobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHsoKSA9PiBJdGVyYWJsZUl0ZXJhdG9yPFtzdHJpbmcsIHN0cmluZ10+fVxuXHQgKi9cblx0KiBlbnRyaWVzKCkge1xuXHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuXHRcdFx0eWllbGQgW25hbWUsIHRoaXMuZ2V0KG5hbWUpXTtcblx0XHR9XG5cdH1cblxuXHRbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHRyZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG5cdH1cblxuXHQvKipcblx0ICogTm9kZS1mZXRjaCBub24tc3BlYyBtZXRob2Rcblx0ICogcmV0dXJuaW5nIGFsbCBoZWFkZXJzIGFuZCB0aGVpciB2YWx1ZXMgYXMgYXJyYXlcblx0ICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZ1tdPn1cblx0ICovXG5cdHJhdygpIHtcblx0XHRyZXR1cm4gWy4uLnRoaXMua2V5cygpXS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG5cdFx0XHRyZXN1bHRba2V5XSA9IHRoaXMuZ2V0QWxsKGtleSk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sIHt9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3IgYmV0dGVyIGNvbnNvbGUubG9nKGhlYWRlcnMpIGFuZCBhbHNvIHRvIGNvbnZlcnQgSGVhZGVycyBpbnRvIE5vZGUuanMgUmVxdWVzdCBjb21wYXRpYmxlIGZvcm1hdFxuXHQgKi9cblx0W1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuXHRcdHJldHVybiBbLi4udGhpcy5rZXlzKCldLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcblx0XHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMuZ2V0QWxsKGtleSk7XG5cdFx0XHQvLyBIdHRwLnJlcXVlc3QoKSBvbmx5IHN1cHBvcnRzIHN0cmluZyBhcyBIb3N0IGhlYWRlci5cblx0XHRcdC8vIFRoaXMgaGFjayBtYWtlcyBzcGVjaWZ5aW5nIGN1c3RvbSBIb3N0IGhlYWRlciBwb3NzaWJsZS5cblx0XHRcdGlmIChrZXkgPT09ICdob3N0Jykge1xuXHRcdFx0XHRyZXN1bHRba2V5XSA9IHZhbHVlc1swXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWVzLmxlbmd0aCA+IDEgPyB2YWx1ZXMgOiB2YWx1ZXNbMF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSwge30pO1xuXHR9XG59XG5cbi8qKlxuICogUmUtc2hhcGluZyBvYmplY3QgZm9yIFdlYiBJREwgdGVzdHNcbiAqIE9ubHkgbmVlZCB0byBkbyBpdCBmb3Igb3ZlcnJpZGRlbiBtZXRob2RzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuXHRIZWFkZXJzLnByb3RvdHlwZSxcblx0WydnZXQnLCAnZW50cmllcycsICdmb3JFYWNoJywgJ3ZhbHVlcyddLnJlZHVjZSgocmVzdWx0LCBwcm9wZXJ0eSkgPT4ge1xuXHRcdHJlc3VsdFtwcm9wZXJ0eV0gPSB7ZW51bWVyYWJsZTogdHJ1ZX07XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSwge30pXG4pO1xuXG4vKipcbiAqIENyZWF0ZSBhIEhlYWRlcnMgb2JqZWN0IGZyb20gYW4gaHR0cC5JbmNvbWluZ01lc3NhZ2UucmF3SGVhZGVycywgaWdub3JpbmcgdGhvc2UgdGhhdCBkb1xuICogbm90IGNvbmZvcm0gdG8gSFRUUCBncmFtbWFyIHByb2R1Y3Rpb25zLlxuICogQHBhcmFtIHtpbXBvcnQoJ2h0dHAnKS5JbmNvbWluZ01lc3NhZ2VbJ3Jhd0hlYWRlcnMnXX0gaGVhZGVyc1xuICovXG5mdW5jdGlvbiBmcm9tUmF3SGVhZGVycyhoZWFkZXJzID0gW10pIHtcblx0cmV0dXJuIG5ldyBIZWFkZXJzKFxuXHRcdGhlYWRlcnNcblx0XHRcdC8vIFNwbGl0IGludG8gcGFpcnNcblx0XHRcdC5yZWR1Y2UoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCBhcnJheSkgPT4ge1xuXHRcdFx0XHRpZiAoaW5kZXggJSAyID09PSAwKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goYXJyYXkuc2xpY2UoaW5kZXgsIGluZGV4ICsgMikpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0sIFtdKVxuXHRcdFx0LmZpbHRlcigoW25hbWUsIHZhbHVlXSkgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcblx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlclZhbHVlKG5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IGNhdGNoIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cblx0KTtcbn1cblxuY29uc3QgcmVkaXJlY3RTdGF0dXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xuXG4vKipcbiAqIFJlZGlyZWN0IGNvZGUgbWF0Y2hpbmdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZSAtIFN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBpc1JlZGlyZWN0ID0gY29kZSA9PiB7XG5cdHJldHVybiByZWRpcmVjdFN0YXR1cy5oYXMoY29kZSk7XG59O1xuXG4vKipcbiAqIFJlc3BvbnNlLmpzXG4gKlxuICogUmVzcG9uc2UgY2xhc3MgcHJvdmlkZXMgY29udGVudCBkZWNvZGluZ1xuICovXG5cbmNvbnN0IElOVEVSTkFMUyQxID0gU3ltYm9sKCdSZXNwb25zZSBpbnRlcm5hbHMnKTtcblxuLyoqXG4gKiBSZXNwb25zZSBjbGFzc1xuICpcbiAqIFJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3Jlc3BvbnNlLWNsYXNzXG4gKlxuICogQHBhcmFtICAgU3RyZWFtICBib2R5ICBSZWFkYWJsZSBzdHJlYW1cbiAqIEBwYXJhbSAgIE9iamVjdCAgb3B0cyAgUmVzcG9uc2Ugb3B0aW9uc1xuICogQHJldHVybiAgVm9pZFxuICovXG5jbGFzcyBSZXNwb25zZSBleHRlbmRzIEJvZHkge1xuXHRjb25zdHJ1Y3Rvcihib2R5ID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIoYm9keSwgb3B0aW9ucyk7XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxLCBuby1uZWdhdGVkLWNvbmRpdGlvblxuXHRcdGNvbnN0IHN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzICE9IG51bGwgPyBvcHRpb25zLnN0YXR1cyA6IDIwMDtcblxuXHRcdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0aWYgKGJvZHkgIT09IG51bGwgJiYgIWhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKSkge1xuXHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSBleHRyYWN0Q29udGVudFR5cGUoYm9keSwgdGhpcyk7XG5cdFx0XHRpZiAoY29udGVudFR5cGUpIHtcblx0XHRcdFx0aGVhZGVycy5hcHBlbmQoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzW0lOVEVSTkFMUyQxXSA9IHtcblx0XHRcdHR5cGU6ICdkZWZhdWx0Jyxcblx0XHRcdHVybDogb3B0aW9ucy51cmwsXG5cdFx0XHRzdGF0dXMsXG5cdFx0XHRzdGF0dXNUZXh0OiBvcHRpb25zLnN0YXR1c1RleHQgfHwgJycsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0Y291bnRlcjogb3B0aW9ucy5jb3VudGVyLFxuXHRcdFx0aGlnaFdhdGVyTWFyazogb3B0aW9ucy5oaWdoV2F0ZXJNYXJrXG5cdFx0fTtcblx0fVxuXG5cdGdldCB0eXBlKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS50eXBlO1xuXHR9XG5cblx0Z2V0IHVybCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0udXJsIHx8ICcnO1xuXHR9XG5cblx0Z2V0IHN0YXR1cygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlbmllbmNlIHByb3BlcnR5IHJlcHJlc2VudGluZyBpZiB0aGUgcmVxdWVzdCBlbmRlZCBub3JtYWxseVxuXHQgKi9cblx0Z2V0IG9rKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5zdGF0dXMgPj0gMjAwICYmIHRoaXNbSU5URVJOQUxTJDFdLnN0YXR1cyA8IDMwMDtcblx0fVxuXG5cdGdldCByZWRpcmVjdGVkKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5jb3VudGVyID4gMDtcblx0fVxuXG5cdGdldCBzdGF0dXNUZXh0KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5zdGF0dXNUZXh0O1xuXHR9XG5cblx0Z2V0IGhlYWRlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLmhlYWRlcnM7XG5cdH1cblxuXHRnZXQgaGlnaFdhdGVyTWFyaygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uaGlnaFdhdGVyTWFyaztcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGlzIHJlc3BvbnNlXG5cdCAqXG5cdCAqIEByZXR1cm4gIFJlc3BvbnNlXG5cdCAqL1xuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKGNsb25lKHRoaXMsIHRoaXMuaGlnaFdhdGVyTWFyayksIHtcblx0XHRcdHR5cGU6IHRoaXMudHlwZSxcblx0XHRcdHVybDogdGhpcy51cmwsXG5cdFx0XHRzdGF0dXM6IHRoaXMuc3RhdHVzLFxuXHRcdFx0c3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0b2s6IHRoaXMub2ssXG5cdFx0XHRyZWRpcmVjdGVkOiB0aGlzLnJlZGlyZWN0ZWQsXG5cdFx0XHRzaXplOiB0aGlzLnNpemUsXG5cdFx0XHRoaWdoV2F0ZXJNYXJrOiB0aGlzLmhpZ2hXYXRlck1hcmtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsICAgIFRoZSBVUkwgdGhhdCB0aGUgbmV3IHJlc3BvbnNlIGlzIHRvIG9yaWdpbmF0ZSBmcm9tLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzIEFuIG9wdGlvbmFsIHN0YXR1cyBjb2RlIGZvciB0aGUgcmVzcG9uc2UgKGUuZy4sIDMwMi4pXG5cdCAqIEByZXR1cm5zIHtSZXNwb25zZX0gICAgQSBSZXNwb25zZSBvYmplY3QuXG5cdCAqL1xuXHRzdGF0aWMgcmVkaXJlY3QodXJsLCBzdGF0dXMgPSAzMDIpIHtcblx0XHRpZiAoIWlzUmVkaXJlY3Qoc3RhdHVzKSkge1xuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFwicmVkaXJlY3RcIiBvbiBcInJlc3BvbnNlXCI6IEludmFsaWQgc3RhdHVzIGNvZGUnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcblx0XHRcdGhlYWRlcnM6IHtcblx0XHRcdFx0bG9jYXRpb246IG5ldyBVUkwodXJsKS50b1N0cmluZygpXG5cdFx0XHR9LFxuXHRcdFx0c3RhdHVzXG5cdFx0fSk7XG5cdH1cblxuXHRzdGF0aWMgZXJyb3IoKSB7XG5cdFx0Y29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KTtcblx0XHRyZXNwb25zZVtJTlRFUk5BTFMkMV0udHlwZSA9ICdlcnJvcic7XG5cdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHR9XG5cblx0c3RhdGljIGpzb24oZGF0YSA9IHVuZGVmaW5lZCwgaW5pdCA9IHt9KSB7XG5cdFx0Y29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXG5cdFx0aWYgKGJvZHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBpcyBub3QgSlNPTiBzZXJpYWxpemFibGUnKTtcblx0XHR9XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdCAmJiBpbml0LmhlYWRlcnMpO1xuXG5cdFx0aWYgKCFoZWFkZXJzLmhhcygnY29udGVudC10eXBlJykpIHtcblx0XHRcdGhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwge1xuXHRcdFx0Li4uaW5pdCxcblx0XHRcdGhlYWRlcnNcblx0XHR9KTtcblx0fVxuXG5cdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcblx0XHRyZXR1cm4gJ1Jlc3BvbnNlJztcblx0fVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZS5wcm90b3R5cGUsIHtcblx0dHlwZToge2VudW1lcmFibGU6IHRydWV9LFxuXHR1cmw6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c3RhdHVzOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdG9rOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHJlZGlyZWN0ZWQ6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c3RhdHVzVGV4dDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRoZWFkZXJzOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGNsb25lOiB7ZW51bWVyYWJsZTogdHJ1ZX1cbn0pO1xuXG5jb25zdCBnZXRTZWFyY2ggPSBwYXJzZWRVUkwgPT4ge1xuXHRpZiAocGFyc2VkVVJMLnNlYXJjaCkge1xuXHRcdHJldHVybiBwYXJzZWRVUkwuc2VhcmNoO1xuXHR9XG5cblx0Y29uc3QgbGFzdE9mZnNldCA9IHBhcnNlZFVSTC5ocmVmLmxlbmd0aCAtIDE7XG5cdGNvbnN0IGhhc2ggPSBwYXJzZWRVUkwuaGFzaCB8fCAocGFyc2VkVVJMLmhyZWZbbGFzdE9mZnNldF0gPT09ICcjJyA/ICcjJyA6ICcnKTtcblx0cmV0dXJuIHBhcnNlZFVSTC5ocmVmW2xhc3RPZmZzZXQgLSBoYXNoLmxlbmd0aF0gPT09ICc/JyA/ICc/JyA6ICcnO1xufTtcblxuLyoqXG4gKiBAZXh0ZXJuYWwgVVJMXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJMfFVSTH1cbiAqL1xuXG4vKipcbiAqIEBtb2R1bGUgdXRpbHMvcmVmZXJyZXJcbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jc3RyaXAtdXJsfFJlZmVycmVyIFBvbGljeSDCpzguNC4gU3RyaXAgdXJsIGZvciB1c2UgYXMgYSByZWZlcnJlcn1cbiAqIEBwYXJhbSB7c3RyaW5nfSBVUkxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29yaWdpbk9ubHk9ZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0cmlwVVJMRm9yVXNlQXNBUmVmZXJyZXIodXJsLCBvcmlnaW5Pbmx5ID0gZmFsc2UpIHtcblx0Ly8gMS4gSWYgdXJsIGlzIG51bGwsIHJldHVybiBubyByZWZlcnJlci5cblx0aWYgKHVybCA9PSBudWxsKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG5cdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cdH1cblxuXHR1cmwgPSBuZXcgVVJMKHVybCk7XG5cblx0Ly8gMi4gSWYgdXJsJ3Mgc2NoZW1lIGlzIGEgbG9jYWwgc2NoZW1lLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cblx0aWYgKC9eKGFib3V0fGJsb2J8ZGF0YSk6JC8udGVzdCh1cmwucHJvdG9jb2wpKSB7XG5cdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cdH1cblxuXHQvLyAzLiBTZXQgdXJsJ3MgdXNlcm5hbWUgdG8gdGhlIGVtcHR5IHN0cmluZy5cblx0dXJsLnVzZXJuYW1lID0gJyc7XG5cblx0Ly8gNC4gU2V0IHVybCdzIHBhc3N3b3JkIHRvIG51bGwuXG5cdC8vIE5vdGU6IGBudWxsYCBhcHBlYXJzIHRvIGJlIGEgbWlzdGFrZSBhcyB0aGlzIGFjdHVhbGx5IHJlc3VsdHMgaW4gdGhlIHBhc3N3b3JkIGJlaW5nIGBcIm51bGxcImAuXG5cdHVybC5wYXNzd29yZCA9ICcnO1xuXG5cdC8vIDUuIFNldCB1cmwncyBmcmFnbWVudCB0byBudWxsLlxuXHQvLyBOb3RlOiBgbnVsbGAgYXBwZWFycyB0byBiZSBhIG1pc3Rha2UgYXMgdGhpcyBhY3R1YWxseSByZXN1bHRzIGluIHRoZSBmcmFnbWVudCBiZWluZyBgXCIjbnVsbFwiYC5cblx0dXJsLmhhc2ggPSAnJztcblxuXHQvLyA2LiBJZiB0aGUgb3JpZ2luLW9ubHkgZmxhZyBpcyB0cnVlLCB0aGVuOlxuXHRpZiAob3JpZ2luT25seSkge1xuXHRcdC8vIDYuMS4gU2V0IHVybCdzIHBhdGggdG8gbnVsbC5cblx0XHQvLyBOb3RlOiBgbnVsbGAgYXBwZWFycyB0byBiZSBhIG1pc3Rha2UgYXMgdGhpcyBhY3R1YWxseSByZXN1bHRzIGluIHRoZSBwYXRoIGJlaW5nIGBcIi9udWxsXCJgLlxuXHRcdHVybC5wYXRobmFtZSA9ICcnO1xuXG5cdFx0Ly8gNi4yLiBTZXQgdXJsJ3MgcXVlcnkgdG8gbnVsbC5cblx0XHQvLyBOb3RlOiBgbnVsbGAgYXBwZWFycyB0byBiZSBhIG1pc3Rha2UgYXMgdGhpcyBhY3R1YWxseSByZXN1bHRzIGluIHRoZSBxdWVyeSBiZWluZyBgXCI/bnVsbFwiYC5cblx0XHR1cmwuc2VhcmNoID0gJyc7XG5cdH1cblxuXHQvLyA3LiBSZXR1cm4gdXJsLlxuXHRyZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNlbnVtZGVmLXJlZmVycmVycG9saWN5fGVudW0gUmVmZXJyZXJQb2xpY3l9XG4gKi9cbmNvbnN0IFJlZmVycmVyUG9saWN5ID0gbmV3IFNldChbXG5cdCcnLFxuXHQnbm8tcmVmZXJyZXInLFxuXHQnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnLFxuXHQnc2FtZS1vcmlnaW4nLFxuXHQnb3JpZ2luJyxcblx0J3N0cmljdC1vcmlnaW4nLFxuXHQnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcblx0J3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nLFxuXHQndW5zYWZlLXVybCdcbl0pO1xuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNkZWZhdWx0LXJlZmVycmVyLXBvbGljeXxkZWZhdWx0IHJlZmVycmVyIHBvbGljeX1cbiAqL1xuY29uc3QgREVGQVVMVF9SRUZFUlJFUl9QT0xJQ1kgPSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic7XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3JlZmVycmVyLXBvbGljaWVzfFJlZmVycmVyIFBvbGljeSDCpzMuIFJlZmVycmVyIFBvbGljaWVzfVxuICogQHBhcmFtIHtzdHJpbmd9IHJlZmVycmVyUG9saWN5XG4gKiBAcmV0dXJucyB7c3RyaW5nfSByZWZlcnJlclBvbGljeVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJlZmVycmVyUG9saWN5KHJlZmVycmVyUG9saWN5KSB7XG5cdGlmICghUmVmZXJyZXJQb2xpY3kuaGFzKHJlZmVycmVyUG9saWN5KSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcmVmZXJyZXJQb2xpY3k6ICR7cmVmZXJyZXJQb2xpY3l9YCk7XG5cdH1cblxuXHRyZXR1cm4gcmVmZXJyZXJQb2xpY3k7XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zZWN1cmUtY29udGV4dHMvI2lzLW9yaWdpbi10cnVzdHdvcnRoeXxSZWZlcnJlciBQb2xpY3kgwqczLjIuIElzIG9yaWdpbiBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeT99XG4gKiBAcGFyYW0ge2V4dGVybmFsOlVSTH0gdXJsXG4gKiBAcmV0dXJucyBgdHJ1ZWA6IFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIiwgYGZhbHNlYDogXCJOb3QgVHJ1c3R3b3J0aHlcIlxuICovXG5mdW5jdGlvbiBpc09yaWdpblBvdGVudGlhbGx5VHJ1c3R3b3J0aHkodXJsKSB7XG5cdC8vIDEuIElmIG9yaWdpbiBpcyBhbiBvcGFxdWUgb3JpZ2luLCByZXR1cm4gXCJOb3QgVHJ1c3R3b3J0aHlcIi5cblx0Ly8gTm90IGFwcGxpY2FibGVcblxuXHQvLyAyLiBBc3NlcnQ6IG9yaWdpbiBpcyBhIHR1cGxlIG9yaWdpbi5cblx0Ly8gTm90IGZvciBpbXBsZW1lbnRhdGlvbnNcblxuXHQvLyAzLiBJZiBvcmlnaW4ncyBzY2hlbWUgaXMgZWl0aGVyIFwiaHR0cHNcIiBvciBcIndzc1wiLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAoL14oaHR0cHx3cylzOiQvLnRlc3QodXJsLnByb3RvY29sKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gNC4gSWYgb3JpZ2luJ3MgaG9zdCBjb21wb25lbnQgbWF0Y2hlcyBvbmUgb2YgdGhlIENJRFIgbm90YXRpb25zIDEyNy4wLjAuMC84IG9yIDo6MS8xMjggW1JGQzQ2MzJdLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRjb25zdCBob3N0SXAgPSB1cmwuaG9zdC5yZXBsYWNlKC8oXlxcWyl8KF0kKS9nLCAnJyk7XG5cdGNvbnN0IGhvc3RJUFZlcnNpb24gPSBub2RlX25ldC5pc0lQKGhvc3RJcCk7XG5cblx0aWYgKGhvc3RJUFZlcnNpb24gPT09IDQgJiYgL14xMjdcXC4vLnRlc3QoaG9zdElwKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKGhvc3RJUFZlcnNpb24gPT09IDYgJiYgL14oKCgwKzopezd9KXwoOjooMCs6KXswLDZ9KSkwKjEkLy50ZXN0KGhvc3RJcCkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDUuIElmIG9yaWdpbidzIGhvc3QgY29tcG9uZW50IGlzIFwibG9jYWxob3N0XCIgb3IgZmFsbHMgd2l0aGluIFwiLmxvY2FsaG9zdFwiLCBhbmQgdGhlIHVzZXIgYWdlbnQgY29uZm9ybXMgdG8gdGhlIG5hbWUgcmVzb2x1dGlvbiBydWxlcyBpbiBbbGV0LWxvY2FsaG9zdC1iZS1sb2NhbGhvc3RdLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHQvLyBXZSBhcmUgcmV0dXJuaW5nIEZBTFNFIGhlcmUgYmVjYXVzZSB3ZSBjYW5ub3QgZW5zdXJlIGNvbmZvcm1hbmNlIHRvXG5cdC8vIGxldC1sb2NhbGhvc3QtYmUtbG9hbGhvc3QgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC13ZXN0LWxldC1sb2NhbGhvc3QtYmUtbG9jYWxob3N0KVxuXHRpZiAodXJsLmhvc3QgPT09ICdsb2NhbGhvc3QnIHx8IHVybC5ob3N0LmVuZHNXaXRoKCcubG9jYWxob3N0JykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyA2LiBJZiBvcmlnaW4ncyBzY2hlbWUgY29tcG9uZW50IGlzIGZpbGUsIHJldHVybiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIuXG5cdGlmICh1cmwucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDcuIElmIG9yaWdpbidzIHNjaGVtZSBjb21wb25lbnQgaXMgb25lIHdoaWNoIHRoZSB1c2VyIGFnZW50IGNvbnNpZGVycyB0byBiZSBhdXRoZW50aWNhdGVkLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHQvLyBOb3Qgc3VwcG9ydGVkXG5cblx0Ly8gOC4gSWYgb3JpZ2luIGhhcyBiZWVuIGNvbmZpZ3VyZWQgYXMgYSB0cnVzdHdvcnRoeSBvcmlnaW4sIHJldHVybiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIuXG5cdC8vIE5vdCBzdXBwb3J0ZWRcblxuXHQvLyA5LiBSZXR1cm4gXCJOb3QgVHJ1c3R3b3J0aHlcIi5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc2VjdXJlLWNvbnRleHRzLyNpcy11cmwtdHJ1c3R3b3J0aHl8UmVmZXJyZXIgUG9saWN5IMKnMy4zLiBJcyB1cmwgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHk/fVxuICogQHBhcmFtIHtleHRlcm5hbDpVUkx9IHVybFxuICogQHJldHVybnMgYHRydWVgOiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIsIGBmYWxzZWA6IFwiTm90IFRydXN0d29ydGh5XCJcbiAqL1xuZnVuY3Rpb24gaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5KHVybCkge1xuXHQvLyAxLiBJZiB1cmwgaXMgXCJhYm91dDpibGFua1wiIG9yIFwiYWJvdXQ6c3JjZG9jXCIsIHJldHVybiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIuXG5cdGlmICgvXmFib3V0OihibGFua3xzcmNkb2MpJC8udGVzdCh1cmwpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyAyLiBJZiB1cmwncyBzY2hlbWUgaXMgXCJkYXRhXCIsIHJldHVybiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIuXG5cdGlmICh1cmwucHJvdG9jb2wgPT09ICdkYXRhOicpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIE5vdGU6IFRoZSBvcmlnaW4gb2YgYmxvYjogYW5kIGZpbGVzeXN0ZW06IFVSTHMgaXMgdGhlIG9yaWdpbiBvZiB0aGUgY29udGV4dCBpbiB3aGljaCB0aGV5IHdlcmVcblx0Ly8gY3JlYXRlZC4gVGhlcmVmb3JlLCBibG9icyBjcmVhdGVkIGluIGEgdHJ1c3R3b3J0aHkgb3JpZ2luIHdpbGwgdGhlbXNlbHZlcyBiZSBwb3RlbnRpYWxseVxuXHQvLyB0cnVzdHdvcnRoeS5cblx0aWYgKC9eKGJsb2J8ZmlsZXN5c3RlbSk6JC8udGVzdCh1cmwucHJvdG9jb2wpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyAzLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgwqczLjIgSXMgb3JpZ2luIHBvdGVudGlhbGx5IHRydXN0d29ydGh5PyBvbiB1cmwncyBvcmlnaW4uXG5cdHJldHVybiBpc09yaWdpblBvdGVudGlhbGx5VHJ1c3R3b3J0aHkodXJsKTtcbn1cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcmVmZXJyZXJVUkwgdG8gZW5mb3JjZSBhbnkgZXh0cmEgc2VjdXJpdHkgcG9saWN5IGNvbnNpZGVyYXRpb25zLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI2RldGVybWluZS1yZXF1ZXN0cy1yZWZlcnJlcnxSZWZlcnJlciBQb2xpY3kgwqc4LjMuIERldGVybWluZSByZXF1ZXN0J3MgUmVmZXJyZXJ9LCBzdGVwIDdcbiAqIEBjYWxsYmFjayBtb2R1bGU6dXRpbHMvcmVmZXJyZXJ+cmVmZXJyZXJVUkxDYWxsYmFja1xuICogQHBhcmFtIHtleHRlcm5hbDpVUkx9IHJlZmVycmVyVVJMXG4gKiBAcmV0dXJucyB7ZXh0ZXJuYWw6VVJMfSBtb2RpZmllZCByZWZlcnJlclVSTFxuICovXG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHJlZmVycmVyT3JpZ2luIHRvIGVuZm9yY2UgYW55IGV4dHJhIHNlY3VyaXR5IHBvbGljeSBjb25zaWRlcmF0aW9ucy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNkZXRlcm1pbmUtcmVxdWVzdHMtcmVmZXJyZXJ8UmVmZXJyZXIgUG9saWN5IMKnOC4zLiBEZXRlcm1pbmUgcmVxdWVzdCdzIFJlZmVycmVyfSwgc3RlcCA3XG4gKiBAY2FsbGJhY2sgbW9kdWxlOnV0aWxzL3JlZmVycmVyfnJlZmVycmVyT3JpZ2luQ2FsbGJhY2tcbiAqIEBwYXJhbSB7ZXh0ZXJuYWw6VVJMfSByZWZlcnJlck9yaWdpblxuICogQHJldHVybnMge2V4dGVybmFsOlVSTH0gbW9kaWZpZWQgcmVmZXJyZXJPcmlnaW5cbiAqL1xuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNkZXRlcm1pbmUtcmVxdWVzdHMtcmVmZXJyZXJ8UmVmZXJyZXIgUG9saWN5IMKnOC4zLiBEZXRlcm1pbmUgcmVxdWVzdCdzIFJlZmVycmVyfVxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcGFyYW0ge29iamVjdH0gb1xuICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcmVmZXJyZXJ+cmVmZXJyZXJVUkxDYWxsYmFja30gby5yZWZlcnJlclVSTENhbGxiYWNrXG4gKiBAcGFyYW0ge21vZHVsZTp1dGlscy9yZWZlcnJlcn5yZWZlcnJlck9yaWdpbkNhbGxiYWNrfSBvLnJlZmVycmVyT3JpZ2luQ2FsbGJhY2tcbiAqIEByZXR1cm5zIHtleHRlcm5hbDpVUkx9IFJlcXVlc3QncyByZWZlcnJlclxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyKHJlcXVlc3QsIHtyZWZlcnJlclVSTENhbGxiYWNrLCByZWZlcnJlck9yaWdpbkNhbGxiYWNrfSA9IHt9KSB7XG5cdC8vIFRoZXJlIGFyZSAyIG5vdGVzIGluIHRoZSBzcGVjaWZpY2F0aW9uIGFib3V0IGludmFsaWQgcHJlLWNvbmRpdGlvbnMuICBXZSByZXR1cm4gbnVsbCwgaGVyZSwgZm9yXG5cdC8vIHRoZXNlIGNhc2VzOlxuXHQvLyA+IE5vdGU6IElmIHJlcXVlc3QncyByZWZlcnJlciBpcyBcIm5vLXJlZmVycmVyXCIsIEZldGNoIHdpbGwgbm90IGNhbGwgaW50byB0aGlzIGFsZ29yaXRobS5cblx0Ly8gPiBOb3RlOiBJZiByZXF1ZXN0J3MgcmVmZXJyZXIgcG9saWN5IGlzIHRoZSBlbXB0eSBzdHJpbmcsIEZldGNoIHdpbGwgbm90IGNhbGwgaW50byB0aGlzXG5cdC8vID4gYWxnb3JpdGhtLlxuXHRpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gJ25vLXJlZmVycmVyJyB8fCByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID09PSAnJykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gMS4gTGV0IHBvbGljeSBiZSByZXF1ZXN0J3MgYXNzb2NpYXRlZCByZWZlcnJlciBwb2xpY3kuXG5cdGNvbnN0IHBvbGljeSA9IHJlcXVlc3QucmVmZXJyZXJQb2xpY3k7XG5cblx0Ly8gMi4gTGV0IGVudmlyb25tZW50IGJlIHJlcXVlc3QncyBjbGllbnQuXG5cdC8vIG5vdCBhcHBsaWNhYmxlIHRvIG5vZGUuanNcblxuXHQvLyAzLiBTd2l0Y2ggb24gcmVxdWVzdCdzIHJlZmVycmVyOlxuXHRpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gJ2Fib3V0OmNsaWVudCcpIHtcblx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0fVxuXG5cdC8vIFwiYSBVUkxcIjogTGV0IHJlZmVycmVyU291cmNlIGJlIHJlcXVlc3QncyByZWZlcnJlci5cblx0Y29uc3QgcmVmZXJyZXJTb3VyY2UgPSByZXF1ZXN0LnJlZmVycmVyO1xuXG5cdC8vIDQuIExldCByZXF1ZXN0J3MgcmVmZXJyZXJVUkwgYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yIHVzZSBhcyBhIHJlZmVycmVyLlxuXHRsZXQgcmVmZXJyZXJVUkwgPSBzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyKHJlZmVycmVyU291cmNlKTtcblxuXHQvLyA1LiBMZXQgcmVmZXJyZXJPcmlnaW4gYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yIHVzZSBhcyBhIHJlZmVycmVyLCB3aXRoIHRoZVxuXHQvLyAgICBvcmlnaW4tb25seSBmbGFnIHNldCB0byB0cnVlLlxuXHRsZXQgcmVmZXJyZXJPcmlnaW4gPSBzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyKHJlZmVycmVyU291cmNlLCB0cnVlKTtcblxuXHQvLyA2LiBJZiB0aGUgcmVzdWx0IG9mIHNlcmlhbGl6aW5nIHJlZmVycmVyVVJMIGlzIGEgc3RyaW5nIHdob3NlIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gNDA5Niwgc2V0XG5cdC8vICAgIHJlZmVycmVyVVJMIHRvIHJlZmVycmVyT3JpZ2luLlxuXHRpZiAocmVmZXJyZXJVUkwudG9TdHJpbmcoKS5sZW5ndGggPiA0MDk2KSB7XG5cdFx0cmVmZXJyZXJVUkwgPSByZWZlcnJlck9yaWdpbjtcblx0fVxuXG5cdC8vIDcuIFRoZSB1c2VyIGFnZW50IE1BWSBhbHRlciByZWZlcnJlclVSTCBvciByZWZlcnJlck9yaWdpbiBhdCB0aGlzIHBvaW50IHRvIGVuZm9yY2UgYXJiaXRyYXJ5XG5cdC8vICAgIHBvbGljeSBjb25zaWRlcmF0aW9ucyBpbiB0aGUgaW50ZXJlc3RzIG9mIG1pbmltaXppbmcgZGF0YSBsZWFrYWdlLiBGb3IgZXhhbXBsZSwgdGhlIHVzZXJcblx0Ly8gICAgYWdlbnQgY291bGQgc3RyaXAgdGhlIFVSTCBkb3duIHRvIGFuIG9yaWdpbiwgbW9kaWZ5IGl0cyBob3N0LCByZXBsYWNlIGl0IHdpdGggYW4gZW1wdHlcblx0Ly8gICAgc3RyaW5nLCBldGMuXG5cdGlmIChyZWZlcnJlclVSTENhbGxiYWNrKSB7XG5cdFx0cmVmZXJyZXJVUkwgPSByZWZlcnJlclVSTENhbGxiYWNrKHJlZmVycmVyVVJMKTtcblx0fVxuXG5cdGlmIChyZWZlcnJlck9yaWdpbkNhbGxiYWNrKSB7XG5cdFx0cmVmZXJyZXJPcmlnaW4gPSByZWZlcnJlck9yaWdpbkNhbGxiYWNrKHJlZmVycmVyT3JpZ2luKTtcblx0fVxuXG5cdC8vIDguRXhlY3V0ZSB0aGUgc3RhdGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSB2YWx1ZSBvZiBwb2xpY3k6XG5cdGNvbnN0IGN1cnJlbnRVUkwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcblxuXHRzd2l0Y2ggKHBvbGljeSkge1xuXHRcdGNhc2UgJ25vLXJlZmVycmVyJzpcblx0XHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXG5cdFx0Y2FzZSAnb3JpZ2luJzpcblx0XHRcdHJldHVybiByZWZlcnJlck9yaWdpbjtcblxuXHRcdGNhc2UgJ3Vuc2FmZS11cmwnOlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXG5cdFx0Y2FzZSAnc3RyaWN0LW9yaWdpbic6XG5cdFx0XHQvLyAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGlzIG5vdCBhXG5cdFx0XHQvLyAgICBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRcdFx0aWYgKGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuXHRcdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0XHRcdH1cblxuXHRcdFx0Ly8gMi4gUmV0dXJuIHJlZmVycmVyT3JpZ2luLlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyT3JpZ2luLnRvU3RyaW5nKCk7XG5cblx0XHRjYXNlICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcblx0XHRcdC8vIDEuIElmIHRoZSBvcmlnaW4gb2YgcmVmZXJyZXJVUkwgYW5kIHRoZSBvcmlnaW4gb2YgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGFyZSB0aGUgc2FtZSwgdGhlblxuXHRcdFx0Ly8gICAgcmV0dXJuIHJlZmVycmVyVVJMLlxuXHRcdFx0aWYgKHJlZmVycmVyVVJMLm9yaWdpbiA9PT0gY3VycmVudFVSTC5vcmlnaW4pIHtcblx0XHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAyLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGlzIG5vdCBhXG5cdFx0XHQvLyAgICBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRcdFx0aWYgKGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuXHRcdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0XHRcdH1cblxuXHRcdFx0Ly8gMy4gUmV0dXJuIHJlZmVycmVyT3JpZ2luLlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyT3JpZ2luO1xuXG5cdFx0Y2FzZSAnc2FtZS1vcmlnaW4nOlxuXHRcdFx0Ly8gMS4gSWYgdGhlIG9yaWdpbiBvZiByZWZlcnJlclVSTCBhbmQgdGhlIG9yaWdpbiBvZiByZXF1ZXN0J3MgY3VycmVudCBVUkwgYXJlIHRoZSBzYW1lLCB0aGVuXG5cdFx0XHQvLyAgICByZXR1cm4gcmVmZXJyZXJVUkwuXG5cdFx0XHRpZiAocmVmZXJyZXJVUkwub3JpZ2luID09PSBjdXJyZW50VVJMLm9yaWdpbikge1xuXHRcdFx0XHRyZXR1cm4gcmVmZXJyZXJVUkw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDIuIFJldHVybiBubyByZWZlcnJlci5cblx0XHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXG5cdFx0Y2FzZSAnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcblx0XHRcdC8vIDEuIElmIHRoZSBvcmlnaW4gb2YgcmVmZXJyZXJVUkwgYW5kIHRoZSBvcmlnaW4gb2YgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGFyZSB0aGUgc2FtZSwgdGhlblxuXHRcdFx0Ly8gICAgcmV0dXJuIHJlZmVycmVyVVJMLlxuXHRcdFx0aWYgKHJlZmVycmVyVVJMLm9yaWdpbiA9PT0gY3VycmVudFVSTC5vcmlnaW4pIHtcblx0XHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gcmVmZXJyZXJPcmlnaW4uXG5cdFx0XHRyZXR1cm4gcmVmZXJyZXJPcmlnaW47XG5cblx0XHRjYXNlICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZSc6XG5cdFx0XHQvLyAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGlzIG5vdCBhXG5cdFx0XHQvLyAgICBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuXHRcdFx0aWYgKGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuXHRcdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblx0XHRcdH1cblxuXHRcdFx0Ly8gMi4gUmV0dXJuIHJlZmVycmVyVVJMLlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcmVmZXJyZXJQb2xpY3k6ICR7cG9saWN5fWApO1xuXHR9XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3BhcnNlLXJlZmVycmVyLXBvbGljeS1mcm9tLWhlYWRlcnxSZWZlcnJlciBQb2xpY3kgwqc4LjEuIFBhcnNlIGEgcmVmZXJyZXIgcG9saWN5IGZyb20gYSBSZWZlcnJlci1Qb2xpY3kgaGVhZGVyfVxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzIFJlc3BvbnNlIGhlYWRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHBvbGljeVxuICovXG5mdW5jdGlvbiBwYXJzZVJlZmVycmVyUG9saWN5RnJvbUhlYWRlcihoZWFkZXJzKSB7XG5cdC8vIDEuIExldCBwb2xpY3ktdG9rZW5zIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXMgZ2l2ZW4gYFJlZmVycmVyLVBvbGljeWBcblx0Ly8gICAgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cblx0Y29uc3QgcG9saWN5VG9rZW5zID0gKGhlYWRlcnMuZ2V0KCdyZWZlcnJlci1wb2xpY3knKSB8fCAnJykuc3BsaXQoL1ssXFxzXSsvKTtcblxuXHQvLyAyLiBMZXQgcG9saWN5IGJlIHRoZSBlbXB0eSBzdHJpbmcuXG5cdGxldCBwb2xpY3kgPSAnJztcblxuXHQvLyAzLiBGb3IgZWFjaCB0b2tlbiBpbiBwb2xpY3ktdG9rZW5zLCBpZiB0b2tlbiBpcyBhIHJlZmVycmVyIHBvbGljeSBhbmQgdG9rZW4gaXMgbm90IHRoZSBlbXB0eVxuXHQvLyAgICBzdHJpbmcsIHRoZW4gc2V0IHBvbGljeSB0byB0b2tlbi5cblx0Ly8gTm90ZTogVGhpcyBhbGdvcml0aG0gbG9vcHMgb3ZlciBtdWx0aXBsZSBwb2xpY3kgdmFsdWVzIHRvIGFsbG93IGRlcGxveW1lbnQgb2YgbmV3IHBvbGljeVxuXHQvLyB2YWx1ZXMgd2l0aCBmYWxsYmFja3MgZm9yIG9sZGVyIHVzZXIgYWdlbnRzLCBhcyBkZXNjcmliZWQgaW4gwqcgMTEuMSBVbmtub3duIFBvbGljeSBWYWx1ZXMuXG5cdGZvciAoY29uc3QgdG9rZW4gb2YgcG9saWN5VG9rZW5zKSB7XG5cdFx0aWYgKHRva2VuICYmIFJlZmVycmVyUG9saWN5Lmhhcyh0b2tlbikpIHtcblx0XHRcdHBvbGljeSA9IHRva2VuO1xuXHRcdH1cblx0fVxuXG5cdC8vIDQuIFJldHVybiBwb2xpY3kuXG5cdHJldHVybiBwb2xpY3k7XG59XG5cbi8qKlxuICogUmVxdWVzdC5qc1xuICpcbiAqIFJlcXVlc3QgY2xhc3MgY29udGFpbnMgc2VydmVyIG9ubHkgb3B0aW9uc1xuICpcbiAqIEFsbCBzcGVjIGFsZ29yaXRobSBzdGVwIG51bWJlcnMgYXJlIGJhc2VkIG9uIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnL2NvbW1pdC1zbmFwc2hvdHMvYWU3MTY4MjJjYjNhNjE4NDMyMjZjZDA5MGVlZmM2NTg5NDQ2YzFkMi8uXG4gKi9cblxuY29uc3QgSU5URVJOQUxTID0gU3ltYm9sKCdSZXF1ZXN0IGludGVybmFscycpO1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIGluc3RhbmNlIG9mIFJlcXVlc3QuXG4gKlxuICogQHBhcmFtICB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBpc1JlcXVlc3QgPSBvYmplY3QgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIG9iamVjdFtJTlRFUk5BTFNdID09PSAnb2JqZWN0J1xuXHQpO1xufTtcblxuY29uc3QgZG9CYWREYXRhV2FybiA9IG5vZGVfdXRpbC5kZXByZWNhdGUoKCkgPT4ge30sXG5cdCcuZGF0YSBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0SW5pdCBwcm9wZXJ0eSwgdXNlIC5ib2R5IGluc3RlYWQnLFxuXHQnaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvMTAwMCAocmVxdWVzdCknKTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNsYXNzXG4gKlxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdC1jbGFzc1xuICpcbiAqIEBwYXJhbSAgIE1peGVkICAgaW5wdXQgIFVybCBvciBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcGFyYW0gICBPYmplY3QgIGluaXQgICBDdXN0b20gb3B0aW9uc1xuICogQHJldHVybiAgVm9pZFxuICovXG5jbGFzcyBSZXF1ZXN0IGV4dGVuZHMgQm9keSB7XG5cdGNvbnN0cnVjdG9yKGlucHV0LCBpbml0ID0ge30pIHtcblx0XHRsZXQgcGFyc2VkVVJMO1xuXG5cdFx0Ly8gTm9ybWFsaXplIGlucHV0IGFuZCBmb3JjZSBVUkwgdG8gYmUgZW5jb2RlZCBhcyBVVEYtOCAoaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvMjQ1KVxuXHRcdGlmIChpc1JlcXVlc3QoaW5wdXQpKSB7XG5cdFx0XHRwYXJzZWRVUkwgPSBuZXcgVVJMKGlucHV0LnVybCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcnNlZFVSTCA9IG5ldyBVUkwoaW5wdXQpO1xuXHRcdFx0aW5wdXQgPSB7fTtcblx0XHR9XG5cblx0XHRpZiAocGFyc2VkVVJMLnVzZXJuYW1lICE9PSAnJyB8fCBwYXJzZWRVUkwucGFzc3dvcmQgIT09ICcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGAke3BhcnNlZFVSTH0gaXMgYW4gdXJsIHdpdGggZW1iZWRkZWQgY3JlZGVudGlhbHMuYCk7XG5cdFx0fVxuXG5cdFx0bGV0IG1ldGhvZCA9IGluaXQubWV0aG9kIHx8IGlucHV0Lm1ldGhvZCB8fCAnR0VUJztcblx0XHRpZiAoL14oZGVsZXRlfGdldHxoZWFkfG9wdGlvbnN8cG9zdHxwdXQpJC9pLnRlc3QobWV0aG9kKSkge1xuXHRcdFx0bWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc1JlcXVlc3QoaW5pdCkgJiYgJ2RhdGEnIGluIGluaXQpIHtcblx0XHRcdGRvQmFkRGF0YVdhcm4oKTtcblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG5cdFx0aWYgKChpbml0LmJvZHkgIT0gbnVsbCB8fCAoaXNSZXF1ZXN0KGlucHV0KSAmJiBpbnB1dC5ib2R5ICE9PSBudWxsKSkgJiZcblx0XHRcdChtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdCB3aXRoIEdFVC9IRUFEIG1ldGhvZCBjYW5ub3QgaGF2ZSBib2R5Jyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5wdXRCb2R5ID0gaW5pdC5ib2R5ID9cblx0XHRcdGluaXQuYm9keSA6XG5cdFx0XHQoaXNSZXF1ZXN0KGlucHV0KSAmJiBpbnB1dC5ib2R5ICE9PSBudWxsID9cblx0XHRcdFx0Y2xvbmUoaW5wdXQpIDpcblx0XHRcdFx0bnVsbCk7XG5cblx0XHRzdXBlcihpbnB1dEJvZHksIHtcblx0XHRcdHNpemU6IGluaXQuc2l6ZSB8fCBpbnB1dC5zaXplIHx8IDBcblx0XHR9KTtcblxuXHRcdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMgfHwgaW5wdXQuaGVhZGVycyB8fCB7fSk7XG5cblx0XHRpZiAoaW5wdXRCb2R5ICE9PSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKGlucHV0Qm9keSwgdGhpcyk7XG5cdFx0XHRpZiAoY29udGVudFR5cGUpIHtcblx0XHRcdFx0aGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgc2lnbmFsID0gaXNSZXF1ZXN0KGlucHV0KSA/XG5cdFx0XHRpbnB1dC5zaWduYWwgOlxuXHRcdFx0bnVsbDtcblx0XHRpZiAoJ3NpZ25hbCcgaW4gaW5pdCkge1xuXHRcdFx0c2lnbmFsID0gaW5pdC5zaWduYWw7XG5cdFx0fVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdGlmIChzaWduYWwgIT0gbnVsbCAmJiAhaXNBYm9ydFNpZ25hbChzaWduYWwpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBzaWduYWwgdG8gYmUgYW4gaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCBvciBFdmVudFRhcmdldCcpO1xuXHRcdH1cblxuXHRcdC8vIMKnNS40LCBSZXF1ZXN0IGNvbnN0cnVjdG9yIHN0ZXBzLCBzdGVwIDE1LjFcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG5cdFx0bGV0IHJlZmVycmVyID0gaW5pdC5yZWZlcnJlciA9PSBudWxsID8gaW5wdXQucmVmZXJyZXIgOiBpbml0LnJlZmVycmVyO1xuXHRcdGlmIChyZWZlcnJlciA9PT0gJycpIHtcblx0XHRcdC8vIMKnNS40LCBSZXF1ZXN0IGNvbnN0cnVjdG9yIHN0ZXBzLCBzdGVwIDE1LjJcblx0XHRcdHJlZmVycmVyID0gJ25vLXJlZmVycmVyJztcblx0XHR9IGVsc2UgaWYgKHJlZmVycmVyKSB7XG5cdFx0XHQvLyDCpzUuNCwgUmVxdWVzdCBjb25zdHJ1Y3RvciBzdGVwcywgc3RlcCAxNS4zLjEsIDE1LjMuMlxuXHRcdFx0Y29uc3QgcGFyc2VkUmVmZXJyZXIgPSBuZXcgVVJMKHJlZmVycmVyKTtcblx0XHRcdC8vIMKnNS40LCBSZXF1ZXN0IGNvbnN0cnVjdG9yIHN0ZXBzLCBzdGVwIDE1LjMuMywgMTUuMy40XG5cdFx0XHRyZWZlcnJlciA9IC9eYWJvdXQ6KFxcL1xcLyk/Y2xpZW50JC8udGVzdChwYXJzZWRSZWZlcnJlcikgPyAnY2xpZW50JyA6IHBhcnNlZFJlZmVycmVyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZWZlcnJlciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHR0aGlzW0lOVEVSTkFMU10gPSB7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHRyZWRpcmVjdDogaW5pdC5yZWRpcmVjdCB8fCBpbnB1dC5yZWRpcmVjdCB8fCAnZm9sbG93Jyxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRwYXJzZWRVUkwsXG5cdFx0XHRzaWduYWwsXG5cdFx0XHRyZWZlcnJlclxuXHRcdH07XG5cblx0XHQvLyBOb2RlLWZldGNoLW9ubHkgb3B0aW9uc1xuXHRcdHRoaXMuZm9sbG93ID0gaW5pdC5mb2xsb3cgPT09IHVuZGVmaW5lZCA/IChpbnB1dC5mb2xsb3cgPT09IHVuZGVmaW5lZCA/IDIwIDogaW5wdXQuZm9sbG93KSA6IGluaXQuZm9sbG93O1xuXHRcdHRoaXMuY29tcHJlc3MgPSBpbml0LmNvbXByZXNzID09PSB1bmRlZmluZWQgPyAoaW5wdXQuY29tcHJlc3MgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpbnB1dC5jb21wcmVzcykgOiBpbml0LmNvbXByZXNzO1xuXHRcdHRoaXMuY291bnRlciA9IGluaXQuY291bnRlciB8fCBpbnB1dC5jb3VudGVyIHx8IDA7XG5cdFx0dGhpcy5hZ2VudCA9IGluaXQuYWdlbnQgfHwgaW5wdXQuYWdlbnQ7XG5cdFx0dGhpcy5oaWdoV2F0ZXJNYXJrID0gaW5pdC5oaWdoV2F0ZXJNYXJrIHx8IGlucHV0LmhpZ2hXYXRlck1hcmsgfHwgMTYzODQ7XG5cdFx0dGhpcy5pbnNlY3VyZUhUVFBQYXJzZXIgPSBpbml0Lmluc2VjdXJlSFRUUFBhcnNlciB8fCBpbnB1dC5pbnNlY3VyZUhUVFBQYXJzZXIgfHwgZmFsc2U7XG5cblx0XHQvLyDCpzUuNCwgUmVxdWVzdCBjb25zdHJ1Y3RvciBzdGVwcywgc3RlcCAxNi5cblx0XHQvLyBEZWZhdWx0IGlzIGVtcHR5IHN0cmluZyBwZXIgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVxdWVzdC1yZWZlcnJlci1wb2xpY3lcblx0XHR0aGlzLnJlZmVycmVyUG9saWN5ID0gaW5pdC5yZWZlcnJlclBvbGljeSB8fCBpbnB1dC5yZWZlcnJlclBvbGljeSB8fCAnJztcblx0fVxuXG5cdC8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuXHRnZXQgbWV0aG9kKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10ubWV0aG9kO1xuXHR9XG5cblx0LyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXG5cdGdldCB1cmwoKSB7XG5cdFx0cmV0dXJuIG5vZGVfdXJsLmZvcm1hdCh0aGlzW0lOVEVSTkFMU10ucGFyc2VkVVJMKTtcblx0fVxuXG5cdC8qKiBAcmV0dXJucyB7SGVhZGVyc30gKi9cblx0Z2V0IGhlYWRlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5oZWFkZXJzO1xuXHR9XG5cblx0Z2V0IHJlZGlyZWN0KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10ucmVkaXJlY3Q7XG5cdH1cblxuXHQvKiogQHJldHVybnMge0Fib3J0U2lnbmFsfSAqL1xuXHRnZXQgc2lnbmFsKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uc2lnbmFsO1xuXHR9XG5cblx0Ly8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0LXJlZmVycmVyXG5cdGdldCByZWZlcnJlcigpIHtcblx0XHRpZiAodGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyID09PSAnbm8tcmVmZXJyZXInKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlciA9PT0gJ2NsaWVudCcpIHtcblx0XHRcdHJldHVybiAnYWJvdXQ6Y2xpZW50Jztcblx0XHR9XG5cblx0XHRpZiAodGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyLnRvU3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdGdldCByZWZlcnJlclBvbGljeSgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyUG9saWN5O1xuXHR9XG5cblx0c2V0IHJlZmVycmVyUG9saWN5KHJlZmVycmVyUG9saWN5KSB7XG5cdFx0dGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyUG9saWN5ID0gdmFsaWRhdGVSZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xvbmUgdGhpcyByZXF1ZXN0XG5cdCAqXG5cdCAqIEByZXR1cm4gIFJlcXVlc3Rcblx0ICovXG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKTtcblx0fVxuXG5cdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcblx0XHRyZXR1cm4gJ1JlcXVlc3QnO1xuXHR9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlcXVlc3QucHJvdG90eXBlLCB7XG5cdG1ldGhvZDoge2VudW1lcmFibGU6IHRydWV9LFxuXHR1cmw6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0aGVhZGVyczoge2VudW1lcmFibGU6IHRydWV9LFxuXHRyZWRpcmVjdDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRjbG9uZToge2VudW1lcmFibGU6IHRydWV9LFxuXHRzaWduYWw6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0cmVmZXJyZXI6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0cmVmZXJyZXJQb2xpY3k6IHtlbnVtZXJhYmxlOiB0cnVlfVxufSk7XG5cbi8qKlxuICogQ29udmVydCBhIFJlcXVlc3QgdG8gTm9kZS5qcyBodHRwIHJlcXVlc3Qgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3QgLSBBIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEByZXR1cm4gVGhlIG9wdGlvbnMgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byBodHRwLnJlcXVlc3RcbiAqL1xuY29uc3QgZ2V0Tm9kZVJlcXVlc3RPcHRpb25zID0gcmVxdWVzdCA9PiB7XG5cdGNvbnN0IHtwYXJzZWRVUkx9ID0gcmVxdWVzdFtJTlRFUk5BTFNdO1xuXHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVxdWVzdFtJTlRFUk5BTFNdLmhlYWRlcnMpO1xuXG5cdC8vIEZldGNoIHN0ZXAgMS4zXG5cdGlmICghaGVhZGVycy5oYXMoJ0FjY2VwdCcpKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0FjY2VwdCcsICcqLyonKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwcyAyLjQtMi43XG5cdGxldCBjb250ZW50TGVuZ3RoVmFsdWUgPSBudWxsO1xuXHRpZiAocmVxdWVzdC5ib2R5ID09PSBudWxsICYmIC9eKHBvc3R8cHV0KSQvaS50ZXN0KHJlcXVlc3QubWV0aG9kKSkge1xuXHRcdGNvbnRlbnRMZW5ndGhWYWx1ZSA9ICcwJztcblx0fVxuXG5cdGlmIChyZXF1ZXN0LmJvZHkgIT09IG51bGwpIHtcblx0XHRjb25zdCB0b3RhbEJ5dGVzID0gZ2V0VG90YWxCeXRlcyhyZXF1ZXN0KTtcblx0XHQvLyBTZXQgQ29udGVudC1MZW5ndGggaWYgdG90YWxCeXRlcyBpcyBhIG51bWJlciAodGhhdCBpcyBub3QgTmFOKVxuXHRcdGlmICh0eXBlb2YgdG90YWxCeXRlcyA9PT0gJ251bWJlcicgJiYgIU51bWJlci5pc05hTih0b3RhbEJ5dGVzKSkge1xuXHRcdFx0Y29udGVudExlbmd0aFZhbHVlID0gU3RyaW5nKHRvdGFsQnl0ZXMpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChjb250ZW50TGVuZ3RoVmFsdWUpIHtcblx0XHRoZWFkZXJzLnNldCgnQ29udGVudC1MZW5ndGgnLCBjb250ZW50TGVuZ3RoVmFsdWUpO1xuXHR9XG5cblx0Ly8gNC4xLiBNYWluIGZldGNoLCBzdGVwIDIuNlxuXHQvLyA+IElmIHJlcXVlc3QncyByZWZlcnJlciBwb2xpY3kgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdCdzIHJlZmVycmVyIHBvbGljeSB0byB0aGVcblx0Ly8gPiBkZWZhdWx0IHJlZmVycmVyIHBvbGljeS5cblx0aWYgKHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPT09ICcnKSB7XG5cdFx0cmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IERFRkFVTFRfUkVGRVJSRVJfUE9MSUNZO1xuXHR9XG5cblx0Ly8gNC4xLiBNYWluIGZldGNoLCBzdGVwIDIuN1xuXHQvLyA+IElmIHJlcXVlc3QncyByZWZlcnJlciBpcyBub3QgXCJuby1yZWZlcnJlclwiLCBzZXQgcmVxdWVzdCdzIHJlZmVycmVyIHRvIHRoZSByZXN1bHQgb2YgaW52b2tpbmdcblx0Ly8gPiBkZXRlcm1pbmUgcmVxdWVzdCdzIHJlZmVycmVyLlxuXHRpZiAocmVxdWVzdC5yZWZlcnJlciAmJiByZXF1ZXN0LnJlZmVycmVyICE9PSAnbm8tcmVmZXJyZXInKSB7XG5cdFx0cmVxdWVzdFtJTlRFUk5BTFNdLnJlZmVycmVyID0gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihyZXF1ZXN0KTtcblx0fSBlbHNlIHtcblx0XHRyZXF1ZXN0W0lOVEVSTkFMU10ucmVmZXJyZXIgPSAnbm8tcmVmZXJyZXInO1xuXHR9XG5cblx0Ly8gNC41LiBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2gsIHN0ZXAgNi45XG5cdC8vID4gSWYgaHR0cFJlcXVlc3QncyByZWZlcnJlciBpcyBhIFVSTCwgdGhlbiBhcHBlbmQgYFJlZmVyZXJgL2h0dHBSZXF1ZXN0J3MgcmVmZXJyZXIsIHNlcmlhbGl6ZWRcblx0Ly8gPiAgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCwgdG8gaHR0cFJlcXVlc3QncyBoZWFkZXIgbGlzdC5cblx0aWYgKHJlcXVlc3RbSU5URVJOQUxTXS5yZWZlcnJlciBpbnN0YW5jZW9mIFVSTCkge1xuXHRcdGhlYWRlcnMuc2V0KCdSZWZlcmVyJywgcmVxdWVzdC5yZWZlcnJlcik7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcCAyLjExXG5cdGlmICghaGVhZGVycy5oYXMoJ1VzZXItQWdlbnQnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdVc2VyLUFnZW50JywgJ25vZGUtZmV0Y2gnKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwIDIuMTVcblx0aWYgKHJlcXVlc3QuY29tcHJlc3MgJiYgIWhlYWRlcnMuaGFzKCdBY2NlcHQtRW5jb2RpbmcnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdBY2NlcHQtRW5jb2RpbmcnLCAnZ3ppcCwgZGVmbGF0ZSwgYnInKTtcblx0fVxuXG5cdGxldCB7YWdlbnR9ID0gcmVxdWVzdDtcblx0aWYgKHR5cGVvZiBhZ2VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGFnZW50ID0gYWdlbnQocGFyc2VkVVJMKTtcblx0fVxuXG5cdGlmICghaGVhZGVycy5oYXMoJ0Nvbm5lY3Rpb24nKSAmJiAhYWdlbnQpIHtcblx0XHRoZWFkZXJzLnNldCgnQ29ubmVjdGlvbicsICdjbG9zZScpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgNC4yXG5cdC8vIGNodW5rZWQgZW5jb2RpbmcgaXMgaGFuZGxlZCBieSBOb2RlLmpzXG5cblx0Y29uc3Qgc2VhcmNoID0gZ2V0U2VhcmNoKHBhcnNlZFVSTCk7XG5cblx0Ly8gUGFzcyB0aGUgZnVsbCBVUkwgZGlyZWN0bHkgdG8gcmVxdWVzdCgpLCBidXQgb3ZlcndyaXRlIHRoZSBmb2xsb3dpbmdcblx0Ly8gb3B0aW9uczpcblx0Y29uc3Qgb3B0aW9ucyA9IHtcblx0XHQvLyBPdmVyd3JpdGUgc2VhcmNoIHRvIHJldGFpbiB0cmFpbGluZyA/IChpc3N1ZSAjNzc2KVxuXHRcdHBhdGg6IHBhcnNlZFVSTC5wYXRobmFtZSArIHNlYXJjaCxcblx0XHQvLyBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIG5vdCBleHByZXNzZWQgaW4gdGhlIFVSTFxuXHRcdG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG5cdFx0aGVhZGVyczogaGVhZGVyc1tTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpLFxuXHRcdGluc2VjdXJlSFRUUFBhcnNlcjogcmVxdWVzdC5pbnNlY3VyZUhUVFBQYXJzZXIsXG5cdFx0YWdlbnRcblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdC8qKiBAdHlwZSB7VVJMfSAqL1xuXHRcdHBhcnNlZFVSTCxcblx0XHRvcHRpb25zXG5cdH07XG59O1xuXG4vKipcbiAqIEFib3J0RXJyb3IgaW50ZXJmYWNlIGZvciBjYW5jZWxsZWQgcmVxdWVzdHNcbiAqL1xuY2xhc3MgQWJvcnRFcnJvciBleHRlbmRzIEZldGNoQmFzZUVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgdHlwZSA9ICdhYm9ydGVkJykge1xuXHRcdHN1cGVyKG1lc3NhZ2UsIHR5cGUpO1xuXHR9XG59XG5cbi8qISBub2RlLWRvbWV4Y2VwdGlvbi4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cblxuaWYgKCFnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbikge1xuICB0cnkge1xuICAgIGNvbnN0IHsgTWVzc2FnZUNoYW5uZWwgfSA9IHJlcXVpcmUoJ3dvcmtlcl90aHJlYWRzJyksXG4gICAgcG9ydCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLFxuICAgIGFiID0gbmV3IEFycmF5QnVmZmVyKCk7XG4gICAgcG9ydC5wb3N0TWVzc2FnZShhYiwgW2FiLCBhYl0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY29uc3RydWN0b3IubmFtZSA9PT0gJ0RPTUV4Y2VwdGlvbicgJiYgKFxuICAgICAgZ2xvYmFsVGhpcy5ET01FeGNlcHRpb24gPSBlcnIuY29uc3RydWN0b3JcbiAgICApO1xuICB9XG59XG5cbnZhciBub2RlRG9tZXhjZXB0aW9uID0gZ2xvYmFsVGhpcy5ET01FeGNlcHRpb247XG5cbi8qKlxuICogSW5kZXguanNcbiAqXG4gKiBhIHJlcXVlc3QgQVBJIGNvbXBhdGlibGUgd2l0aCB3aW5kb3cuZmV0Y2hcbiAqXG4gKiBBbGwgc3BlYyBhbGdvcml0aG0gc3RlcCBudW1iZXJzIGFyZSBiYXNlZCBvbiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy9jb21taXQtc25hcHNob3RzL2FlNzE2ODIyY2IzYTYxODQzMjI2Y2QwOTBlZWZjNjU4OTQ0NmMxZDIvLlxuICovXG5cbmNvbnN0IHN1cHBvcnRlZFNjaGVtYXMgPSBuZXcgU2V0KFsnZGF0YTonLCAnaHR0cDonLCAnaHR0cHM6J10pO1xuXG4vKipcbiAqIEZldGNoIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtICAge3N0cmluZyB8IFVSTCB8IGltcG9ydCgnLi9yZXF1ZXN0JykuZGVmYXVsdH0gdXJsIC0gQWJzb2x1dGUgdXJsIG9yIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEBwYXJhbSAgIHsqfSBbb3B0aW9uc19dIC0gRmV0Y2ggb3B0aW9uc1xuICogQHJldHVybiAge1Byb21pc2U8aW1wb3J0KCcuL3Jlc3BvbnNlJykuZGVmYXVsdD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoKHVybCwgb3B0aW9uc18pIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQvLyBCdWlsZCByZXF1ZXN0IG9iamVjdFxuXHRcdGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIG9wdGlvbnNfKTtcblx0XHRjb25zdCB7cGFyc2VkVVJMLCBvcHRpb25zfSA9IGdldE5vZGVSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0KTtcblx0XHRpZiAoIXN1cHBvcnRlZFNjaGVtYXMuaGFzKHBhcnNlZFVSTC5wcm90b2NvbCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYG5vZGUtZmV0Y2ggY2Fubm90IGxvYWQgJHt1cmx9LiBVUkwgc2NoZW1lIFwiJHtwYXJzZWRVUkwucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJyl9XCIgaXMgbm90IHN1cHBvcnRlZC5gKTtcblx0XHR9XG5cblx0XHRpZiAocGFyc2VkVVJMLnByb3RvY29sID09PSAnZGF0YTonKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gZGF0YVVyaVRvQnVmZmVyKHJlcXVlc3QudXJsKTtcblx0XHRcdGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGRhdGEsIHtoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6IGRhdGEudHlwZUZ1bGx9fSk7XG5cdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXcmFwIGh0dHAucmVxdWVzdCBpbnRvIGZldGNoXG5cdFx0Y29uc3Qgc2VuZCA9IChwYXJzZWRVUkwucHJvdG9jb2wgPT09ICdodHRwczonID8gaHR0cHMgOiBodHRwKS5yZXF1ZXN0O1xuXHRcdGNvbnN0IHtzaWduYWx9ID0gcmVxdWVzdDtcblx0XHRsZXQgcmVzcG9uc2UgPSBudWxsO1xuXG5cdFx0Y29uc3QgYWJvcnQgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBlcnJvciA9IG5ldyBBYm9ydEVycm9yKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicpO1xuXHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdGlmIChyZXF1ZXN0LmJvZHkgJiYgcmVxdWVzdC5ib2R5IGluc3RhbmNlb2YgU3RyZWFtLlJlYWRhYmxlKSB7XG5cdFx0XHRcdHJlcXVlc3QuYm9keS5kZXN0cm95KGVycm9yKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UuYm9keSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlLmJvZHkuZW1pdCgnZXJyb3InLCBlcnJvcik7XG5cdFx0fTtcblxuXHRcdGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcblx0XHRcdGFib3J0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgYWJvcnRBbmRGaW5hbGl6ZSA9ICgpID0+IHtcblx0XHRcdGFib3J0KCk7XG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH07XG5cblx0XHQvLyBTZW5kIHJlcXVlc3Rcblx0XHRjb25zdCByZXF1ZXN0XyA9IHNlbmQocGFyc2VkVVJMLnRvU3RyaW5nKCksIG9wdGlvbnMpO1xuXG5cdFx0aWYgKHNpZ25hbCkge1xuXHRcdFx0c2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZmluYWxpemUgPSAoKSA9PiB7XG5cdFx0XHRyZXF1ZXN0Xy5hYm9ydCgpO1xuXHRcdFx0aWYgKHNpZ25hbCkge1xuXHRcdFx0XHRzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFuZEZpbmFsaXplKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmVxdWVzdF8ub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuXHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGByZXF1ZXN0IHRvICR7cmVxdWVzdC51cmx9IGZhaWxlZCwgcmVhc29uOiAke2Vycm9yLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycm9yKSk7XG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH0pO1xuXG5cdFx0Zml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcocmVxdWVzdF8sIGVycm9yID0+IHtcblx0XHRcdGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5ib2R5KSB7XG5cdFx0XHRcdHJlc3BvbnNlLmJvZHkuZGVzdHJveShlcnJvcik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKiBjOCBpZ25vcmUgbmV4dCAxOCAqL1xuXHRcdGlmIChwcm9jZXNzLnZlcnNpb24gPCAndjE0Jykge1xuXHRcdFx0Ly8gQmVmb3JlIE5vZGUuanMgMTQsIHBpcGVsaW5lKCkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCBhc3luYyBpdGVyYXRvcnMgYW5kIGRvZXMgbm90IGFsd2F5c1xuXHRcdFx0Ly8gcHJvcGVybHkgaGFuZGxlIHdoZW4gdGhlIHNvY2tldCBjbG9zZS9lbmQgZXZlbnRzIGFyZSBvdXQgb2Ygb3JkZXIuXG5cdFx0XHRyZXF1ZXN0Xy5vbignc29ja2V0JywgcyA9PiB7XG5cdFx0XHRcdGxldCBlbmRlZFdpdGhFdmVudHNDb3VudDtcblx0XHRcdFx0cy5wcmVwZW5kTGlzdGVuZXIoJ2VuZCcsICgpID0+IHtcblx0XHRcdFx0XHRlbmRlZFdpdGhFdmVudHNDb3VudCA9IHMuX2V2ZW50c0NvdW50O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cy5wcmVwZW5kTGlzdGVuZXIoJ2Nsb3NlJywgaGFkRXJyb3IgPT4ge1xuXHRcdFx0XHRcdC8vIGlmIGVuZCBoYXBwZW5lZCBiZWZvcmUgY2xvc2UgYnV0IHRoZSBzb2NrZXQgZGlkbid0IGVtaXQgYW4gZXJyb3IsIGRvIGl0IG5vd1xuXHRcdFx0XHRcdGlmIChyZXNwb25zZSAmJiBlbmRlZFdpdGhFdmVudHNDb3VudCA8IHMuX2V2ZW50c0NvdW50ICYmICFoYWRFcnJvcikge1xuXHRcdFx0XHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1ByZW1hdHVyZSBjbG9zZScpO1xuXHRcdFx0XHRcdFx0ZXJyb3IuY29kZSA9ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSc7XG5cdFx0XHRcdFx0XHRyZXNwb25zZS5ib2R5LmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXF1ZXN0Xy5vbigncmVzcG9uc2UnLCByZXNwb25zZV8gPT4ge1xuXHRcdFx0cmVxdWVzdF8uc2V0VGltZW91dCgwKTtcblx0XHRcdGNvbnN0IGhlYWRlcnMgPSBmcm9tUmF3SGVhZGVycyhyZXNwb25zZV8ucmF3SGVhZGVycyk7XG5cblx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1XG5cdFx0XHRpZiAoaXNSZWRpcmVjdChyZXNwb25zZV8uc3RhdHVzQ29kZSkpIHtcblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuMlxuXHRcdFx0XHRjb25zdCBsb2NhdGlvbiA9IGhlYWRlcnMuZ2V0KCdMb2NhdGlvbicpO1xuXG5cdFx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1LjNcblx0XHRcdFx0bGV0IGxvY2F0aW9uVVJMID0gbnVsbDtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRsb2NhdGlvblVSTCA9IGxvY2F0aW9uID09PSBudWxsID8gbnVsbCA6IG5ldyBVUkwobG9jYXRpb24sIHJlcXVlc3QudXJsKTtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0Ly8gZXJyb3IgaGVyZSBjYW4gb25seSBiZSBpbnZhbGlkIFVSTCBpbiBMb2NhdGlvbjogaGVhZGVyXG5cdFx0XHRcdFx0Ly8gZG8gbm90IHRocm93IHdoZW4gb3B0aW9ucy5yZWRpcmVjdCA9PSBtYW51YWxcblx0XHRcdFx0XHQvLyBsZXQgdGhlIHVzZXIgZXh0cmFjdCB0aGUgZXJyb3JuZW91cyByZWRpcmVjdCBVUkxcblx0XHRcdFx0XHRpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ21hbnVhbCcpIHtcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGFuIGludmFsaWQgcmVkaXJlY3QgVVJMOiAke2xvY2F0aW9ufWAsICdpbnZhbGlkLXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS41XG5cdFx0XHRcdHN3aXRjaCAocmVxdWVzdC5yZWRpcmVjdCkge1xuXHRcdFx0XHRcdGNhc2UgJ2Vycm9yJzpcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGEgcmVkaXJlY3QsIHJlZGlyZWN0IG1vZGUgaXMgc2V0IHRvIGVycm9yOiAke3JlcXVlc3QudXJsfWAsICduby1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Y2FzZSAnbWFudWFsJzpcblx0XHRcdFx0XHRcdC8vIE5vdGhpbmcgdG8gZG9cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2ZvbGxvdyc6IHtcblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAyXG5cdFx0XHRcdFx0XHRpZiAobG9jYXRpb25VUkwgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCA1XG5cdFx0XHRcdFx0XHRpZiAocmVxdWVzdC5jb3VudGVyID49IHJlcXVlc3QuZm9sbG93KSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgbWF4aW11bSByZWRpcmVjdCByZWFjaGVkIGF0OiAke3JlcXVlc3QudXJsfWAsICdtYXgtcmVkaXJlY3QnKSk7XG5cdFx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDYgKGNvdW50ZXIgaW5jcmVtZW50KVxuXHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgbmV3IFJlcXVlc3Qgb2JqZWN0LlxuXHRcdFx0XHRcdFx0Y29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0XHRcdGhlYWRlcnM6IG5ldyBIZWFkZXJzKHJlcXVlc3QuaGVhZGVycyksXG5cdFx0XHRcdFx0XHRcdGZvbGxvdzogcmVxdWVzdC5mb2xsb3csXG5cdFx0XHRcdFx0XHRcdGNvdW50ZXI6IHJlcXVlc3QuY291bnRlciArIDEsXG5cdFx0XHRcdFx0XHRcdGFnZW50OiByZXF1ZXN0LmFnZW50LFxuXHRcdFx0XHRcdFx0XHRjb21wcmVzczogcmVxdWVzdC5jb21wcmVzcyxcblx0XHRcdFx0XHRcdFx0bWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcblx0XHRcdFx0XHRcdFx0Ym9keTogY2xvbmUocmVxdWVzdCksXG5cdFx0XHRcdFx0XHRcdHNpZ25hbDogcmVxdWVzdC5zaWduYWwsXG5cdFx0XHRcdFx0XHRcdHNpemU6IHJlcXVlc3Quc2l6ZSxcblx0XHRcdFx0XHRcdFx0cmVmZXJyZXI6IHJlcXVlc3QucmVmZXJyZXIsXG5cdFx0XHRcdFx0XHRcdHJlZmVycmVyUG9saWN5OiByZXF1ZXN0LnJlZmVycmVyUG9saWN5XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHQvLyB3aGVuIGZvcndhcmRpbmcgc2Vuc2l0aXZlIGhlYWRlcnMgbGlrZSBcIkF1dGhvcml6YXRpb25cIixcblx0XHRcdFx0XHRcdC8vIFwiV1dXLUF1dGhlbnRpY2F0ZVwiLCBhbmQgXCJDb29raWVcIiB0byB1bnRydXN0ZWQgdGFyZ2V0cyxcblx0XHRcdFx0XHRcdC8vIGhlYWRlcnMgd2lsbCBiZSBpZ25vcmVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBkb21haW5cblx0XHRcdFx0XHRcdC8vIHRoYXQgaXMgbm90IGEgc3ViZG9tYWluIG1hdGNoIG9yIGV4YWN0IG1hdGNoIG9mIHRoZSBpbml0aWFsIGRvbWFpbi5cblx0XHRcdFx0XHRcdC8vIEZvciBleGFtcGxlLCBhIHJlZGlyZWN0IGZyb20gXCJmb28uY29tXCIgdG8gZWl0aGVyIFwiZm9vLmNvbVwiIG9yIFwic3ViLmZvby5jb21cIlxuXHRcdFx0XHRcdFx0Ly8gd2lsbCBmb3J3YXJkIHRoZSBzZW5zaXRpdmUgaGVhZGVycywgYnV0IGEgcmVkaXJlY3QgdG8gXCJiYXIuY29tXCIgd2lsbCBub3QuXG5cdFx0XHRcdFx0XHQvLyBoZWFkZXJzIHdpbGwgYWxzbyBiZSBpZ25vcmVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBkb21haW4gdXNpbmdcblx0XHRcdFx0XHRcdC8vIGEgZGlmZmVyZW50IHByb3RvY29sLiBGb3IgZXhhbXBsZSwgYSByZWRpcmVjdCBmcm9tIFwiaHR0cHM6Ly9mb28uY29tXCIgdG8gXCJodHRwOi8vZm9vLmNvbVwiXG5cdFx0XHRcdFx0XHQvLyB3aWxsIG5vdCBmb3J3YXJkIHRoZSBzZW5zaXRpdmUgaGVhZGVyc1xuXHRcdFx0XHRcdFx0aWYgKCFpc0RvbWFpbk9yU3ViZG9tYWluKHJlcXVlc3QudXJsLCBsb2NhdGlvblVSTCkgfHwgIWlzU2FtZVByb3RvY29sKHJlcXVlc3QudXJsLCBsb2NhdGlvblVSTCkpIHtcblx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCBuYW1lIG9mIFsnYXV0aG9yaXphdGlvbicsICd3d3ctYXV0aGVudGljYXRlJywgJ2Nvb2tpZScsICdjb29raWUyJ10pIHtcblx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLmRlbGV0ZShuYW1lKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgOVxuXHRcdFx0XHRcdFx0aWYgKHJlc3BvbnNlXy5zdGF0dXNDb2RlICE9PSAzMDMgJiYgcmVxdWVzdC5ib2R5ICYmIG9wdGlvbnNfLmJvZHkgaW5zdGFuY2VvZiBTdHJlYW0uUmVhZGFibGUpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKCdDYW5ub3QgZm9sbG93IHJlZGlyZWN0IHdpdGggYm9keSBiZWluZyBhIHJlYWRhYmxlIHN0cmVhbScsICd1bnN1cHBvcnRlZC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMTFcblx0XHRcdFx0XHRcdGlmIChyZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAzIHx8ICgocmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAyKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSkge1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0aW9ucy5tZXRob2QgPSAnR0VUJztcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuYm9keSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxNFxuXHRcdFx0XHRcdFx0Y29uc3QgcmVzcG9uc2VSZWZlcnJlclBvbGljeSA9IHBhcnNlUmVmZXJyZXJQb2xpY3lGcm9tSGVhZGVyKGhlYWRlcnMpO1xuXHRcdFx0XHRcdFx0aWYgKHJlc3BvbnNlUmVmZXJyZXJQb2xpY3kpIHtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMucmVmZXJyZXJQb2xpY3kgPSByZXNwb25zZVJlZmVycmVyUG9saWN5O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMTVcblx0XHRcdFx0XHRcdHJlc29sdmUoZmV0Y2gobmV3IFJlcXVlc3QobG9jYXRpb25VUkwsIHJlcXVlc3RPcHRpb25zKSkpO1xuXHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKGBSZWRpcmVjdCBvcHRpb24gJyR7cmVxdWVzdC5yZWRpcmVjdH0nIGlzIG5vdCBhIHZhbGlkIHZhbHVlIG9mIFJlcXVlc3RSZWRpcmVjdGApKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBQcmVwYXJlIHJlc3BvbnNlXG5cdFx0XHRpZiAoc2lnbmFsKSB7XG5cdFx0XHRcdHJlc3BvbnNlXy5vbmNlKCdlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdFx0c2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgYm9keSA9IFN0cmVhbS5waXBlbGluZShyZXNwb25zZV8sIG5ldyBTdHJlYW0uUGFzc1Rocm91Z2goKSwgZXJyb3IgPT4ge1xuXHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8yOTM3NlxuXHRcdFx0LyogYzggaWdub3JlIG5leHQgMyAqL1xuXHRcdFx0aWYgKHByb2Nlc3MudmVyc2lvbiA8ICd2MTIuMTAnKSB7XG5cdFx0XHRcdHJlc3BvbnNlXy5vbignYWJvcnRlZCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByZXNwb25zZU9wdGlvbnMgPSB7XG5cdFx0XHRcdHVybDogcmVxdWVzdC51cmwsXG5cdFx0XHRcdHN0YXR1czogcmVzcG9uc2VfLnN0YXR1c0NvZGUsXG5cdFx0XHRcdHN0YXR1c1RleHQ6IHJlc3BvbnNlXy5zdGF0dXNNZXNzYWdlLFxuXHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRzaXplOiByZXF1ZXN0LnNpemUsXG5cdFx0XHRcdGNvdW50ZXI6IHJlcXVlc3QuY291bnRlcixcblx0XHRcdFx0aGlnaFdhdGVyTWFyazogcmVxdWVzdC5oaWdoV2F0ZXJNYXJrXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCAxMi4xLjEuM1xuXHRcdFx0Y29uc3QgY29kaW5ncyA9IGhlYWRlcnMuZ2V0KCdDb250ZW50LUVuY29kaW5nJyk7XG5cblx0XHRcdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDEyLjEuMS40OiBoYW5kbGUgY29udGVudCBjb2RpbmdzXG5cblx0XHRcdC8vIGluIGZvbGxvd2luZyBzY2VuYXJpb3Mgd2UgaWdub3JlIGNvbXByZXNzaW9uIHN1cHBvcnRcblx0XHRcdC8vIDEuIGNvbXByZXNzaW9uIHN1cHBvcnQgaXMgZGlzYWJsZWRcblx0XHRcdC8vIDIuIEhFQUQgcmVxdWVzdFxuXHRcdFx0Ly8gMy4gbm8gQ29udGVudC1FbmNvZGluZyBoZWFkZXJcblx0XHRcdC8vIDQuIG5vIGNvbnRlbnQgcmVzcG9uc2UgKDIwNClcblx0XHRcdC8vIDUuIGNvbnRlbnQgbm90IG1vZGlmaWVkIHJlc3BvbnNlICgzMDQpXG5cdFx0XHRpZiAoIXJlcXVlc3QuY29tcHJlc3MgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJyB8fCBjb2RpbmdzID09PSBudWxsIHx8IHJlc3BvbnNlXy5zdGF0dXNDb2RlID09PSAyMDQgfHwgcmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDMwNCkge1xuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZU9wdGlvbnMpO1xuXHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgTm9kZSB2Nitcblx0XHRcdC8vIEJlIGxlc3Mgc3RyaWN0IHdoZW4gZGVjb2RpbmcgY29tcHJlc3NlZCByZXNwb25zZXMsIHNpbmNlIHNvbWV0aW1lc1xuXHRcdFx0Ly8gc2VydmVycyBzZW5kIHNsaWdodGx5IGludmFsaWQgcmVzcG9uc2VzIHRoYXQgYXJlIHN0aWxsIGFjY2VwdGVkXG5cdFx0XHQvLyBieSBjb21tb24gYnJvd3NlcnMuXG5cdFx0XHQvLyBBbHdheXMgdXNpbmcgWl9TWU5DX0ZMVVNIIGlzIHdoYXQgY1VSTCBkb2VzLlxuXHRcdFx0Y29uc3QgemxpYk9wdGlvbnMgPSB7XG5cdFx0XHRcdGZsdXNoOiB6bGliLlpfU1lOQ19GTFVTSCxcblx0XHRcdFx0ZmluaXNoRmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNIXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBGb3IgZ3ppcFxuXHRcdFx0aWYgKGNvZGluZ3MgPT09ICdnemlwJyB8fCBjb2RpbmdzID09PSAneC1nemlwJykge1xuXHRcdFx0XHRib2R5ID0gU3RyZWFtLnBpcGVsaW5lKGJvZHksIHpsaWIuY3JlYXRlR3VuemlwKHpsaWJPcHRpb25zKSwgZXJyb3IgPT4ge1xuXHRcdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZU9wdGlvbnMpO1xuXHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgZGVmbGF0ZVxuXHRcdFx0aWYgKGNvZGluZ3MgPT09ICdkZWZsYXRlJyB8fCBjb2RpbmdzID09PSAneC1kZWZsYXRlJykge1xuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGluZmFtb3VzIHJhdyBkZWZsYXRlIHJlc3BvbnNlIGZyb20gb2xkIHNlcnZlcnNcblx0XHRcdFx0Ly8gYSBoYWNrIGZvciBvbGQgSUlTIGFuZCBBcGFjaGUgc2VydmVyc1xuXHRcdFx0XHRjb25zdCByYXcgPSBTdHJlYW0ucGlwZWxpbmUocmVzcG9uc2VfLCBuZXcgU3RyZWFtLlBhc3NUaHJvdWdoKCksIGVycm9yID0+IHtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmF3Lm9uY2UoJ2RhdGEnLCBjaHVuayA9PiB7XG5cdFx0XHRcdFx0Ly8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzc1MTk4Mjhcblx0XHRcdFx0XHRpZiAoKGNodW5rWzBdICYgMHgwRikgPT09IDB4MDgpIHtcblx0XHRcdFx0XHRcdGJvZHkgPSBTdHJlYW0ucGlwZWxpbmUoYm9keSwgemxpYi5jcmVhdGVJbmZsYXRlKCksIGVycm9yID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJvZHkgPSBTdHJlYW0ucGlwZWxpbmUoYm9keSwgemxpYi5jcmVhdGVJbmZsYXRlUmF3KCksIGVycm9yID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJhdy5vbmNlKCdlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdFx0Ly8gU29tZSBvbGQgSUlTIHNlcnZlcnMgcmV0dXJuIHplcm8tbGVuZ3RoIE9LIGRlZmxhdGUgcmVzcG9uc2VzLCBzb1xuXHRcdFx0XHRcdC8vICdkYXRhJyBpcyBuZXZlciBlbWl0dGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9wdWxsLzkwM1xuXHRcdFx0XHRcdGlmICghcmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBiclxuXHRcdFx0aWYgKGNvZGluZ3MgPT09ICdicicpIHtcblx0XHRcdFx0Ym9keSA9IFN0cmVhbS5waXBlbGluZShib2R5LCB6bGliLmNyZWF0ZUJyb3RsaURlY29tcHJlc3MoKSwgZXJyb3IgPT4ge1xuXHRcdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZU9wdGlvbnMpO1xuXHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIHVzZSByZXNwb25zZSBhcy1pc1xuXHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLXRoZW5cblx0XHR3cml0ZVRvU3RyZWFtKHJlcXVlc3RfLCByZXF1ZXN0KS5jYXRjaChyZWplY3QpO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcocmVxdWVzdCwgZXJyb3JDYWxsYmFjaykge1xuXHRjb25zdCBMQVNUX0NIVU5LID0gbm9kZV9idWZmZXIuQnVmZmVyLmZyb20oJzBcXHJcXG5cXHJcXG4nKTtcblxuXHRsZXQgaXNDaHVua2VkVHJhbnNmZXIgPSBmYWxzZTtcblx0bGV0IHByb3Blckxhc3RDaHVua1JlY2VpdmVkID0gZmFsc2U7XG5cdGxldCBwcmV2aW91c0NodW5rO1xuXG5cdHJlcXVlc3Qub24oJ3Jlc3BvbnNlJywgcmVzcG9uc2UgPT4ge1xuXHRcdGNvbnN0IHtoZWFkZXJzfSA9IHJlc3BvbnNlO1xuXHRcdGlzQ2h1bmtlZFRyYW5zZmVyID0gaGVhZGVyc1sndHJhbnNmZXItZW5jb2RpbmcnXSA9PT0gJ2NodW5rZWQnICYmICFoZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xuXHR9KTtcblxuXHRyZXF1ZXN0Lm9uKCdzb2NrZXQnLCBzb2NrZXQgPT4ge1xuXHRcdGNvbnN0IG9uU29ja2V0Q2xvc2UgPSAoKSA9PiB7XG5cdFx0XHRpZiAoaXNDaHVua2VkVHJhbnNmZXIgJiYgIXByb3Blckxhc3RDaHVua1JlY2VpdmVkKSB7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdQcmVtYXR1cmUgY2xvc2UnKTtcblx0XHRcdFx0ZXJyb3IuY29kZSA9ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSc7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2soZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRjb25zdCBvbkRhdGEgPSBidWYgPT4ge1xuXHRcdFx0cHJvcGVyTGFzdENodW5rUmVjZWl2ZWQgPSBub2RlX2J1ZmZlci5CdWZmZXIuY29tcGFyZShidWYuc2xpY2UoLTUpLCBMQVNUX0NIVU5LKSA9PT0gMDtcblxuXHRcdFx0Ly8gU29tZXRpbWVzIGZpbmFsIDAtbGVuZ3RoIGNodW5rIGFuZCBlbmQgb2YgbWVzc2FnZSBjb2RlIGFyZSBpbiBzZXBhcmF0ZSBwYWNrZXRzXG5cdFx0XHRpZiAoIXByb3Blckxhc3RDaHVua1JlY2VpdmVkICYmIHByZXZpb3VzQ2h1bmspIHtcblx0XHRcdFx0cHJvcGVyTGFzdENodW5rUmVjZWl2ZWQgPSAoXG5cdFx0XHRcdFx0bm9kZV9idWZmZXIuQnVmZmVyLmNvbXBhcmUocHJldmlvdXNDaHVuay5zbGljZSgtMyksIExBU1RfQ0hVTksuc2xpY2UoMCwgMykpID09PSAwICYmXG5cdFx0XHRcdFx0bm9kZV9idWZmZXIuQnVmZmVyLmNvbXBhcmUoYnVmLnNsaWNlKC0yKSwgTEFTVF9DSFVOSy5zbGljZSgzKSkgPT09IDBcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0cHJldmlvdXNDaHVuayA9IGJ1Zjtcblx0XHR9O1xuXG5cdFx0c29ja2V0LnByZXBlbmRMaXN0ZW5lcignY2xvc2UnLCBvblNvY2tldENsb3NlKTtcblx0XHRzb2NrZXQub24oJ2RhdGEnLCBvbkRhdGEpO1xuXG5cdFx0cmVxdWVzdC5vbignY2xvc2UnLCAoKSA9PiB7XG5cdFx0XHRzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSk7XG5cdFx0XHRzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAYXV0aG9yIFRvcnUgTmFnYXNoaW1hIDxodHRwczovL2dpdGh1Yi5jb20vbXlzdGljYXRlYT5cbiAqIEBjb3B5cmlnaHQgMjAxNSBUb3J1IE5hZ2FzaGltYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFNlZSBMSUNFTlNFIGZpbGUgaW4gcm9vdCBkaXJlY3RvcnkgZm9yIGZ1bGwgbGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQcml2YXRlRGF0YVxuICogQHByb3BlcnR5IHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwcm9wZXJ0eSB7e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBldmVudFBoYXNlIFRoZSBjdXJyZW50IGV2ZW50IHBoYXNlLlxuICogQHByb3BlcnR5IHtFdmVudFRhcmdldHxudWxsfSBjdXJyZW50VGFyZ2V0IFRoZSBjdXJyZW50IGV2ZW50IHRhcmdldC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2FuY2VsZWQgVGhlIGZsYWcgdG8gcHJldmVudCBkZWZhdWx0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBzdG9wcGVkIFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGltbWVkaWF0ZVN0b3BwZWQgVGhlIGZsYWcgdG8gc3RvcCBwcm9wYWdhdGlvbiBpbW1lZGlhdGVseS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb258bnVsbH0gcGFzc2l2ZUxpc3RlbmVyIFRoZSBsaXN0ZW5lciBpZiB0aGUgY3VycmVudCBsaXN0ZW5lciBpcyBwYXNzaXZlLiBPdGhlcndpc2UgdGhpcyBpcyBudWxsLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVTdGFtcCBUaGUgdW5peCB0aW1lLlxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIFByaXZhdGUgZGF0YSBmb3IgZXZlbnQgd3JhcHBlcnMuXG4gKiBAdHlwZSB7V2Vha01hcDxFdmVudCwgUHJpdmF0ZURhdGE+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgcHJpdmF0ZURhdGEgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIENhY2hlIGZvciB3cmFwcGVyIGNsYXNzZXMuXG4gKiBAdHlwZSB7V2Vha01hcDxPYmplY3QsIEZ1bmN0aW9uPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHdyYXBwZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBHZXQgcHJpdmF0ZSBkYXRhLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCB0byBnZXQgcHJpdmF0ZSBkYXRhLlxuICogQHJldHVybnMge1ByaXZhdGVEYXRhfSBUaGUgcHJpdmF0ZSBkYXRhIG9mIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBkKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0diA9IHByaXZhdGVEYXRhLmdldChldmVudCk7XG4gICAgY29uc29sZS5hc3NlcnQoXG4gICAgICAgIHJldHYgIT0gbnVsbCxcbiAgICAgICAgXCIndGhpcycgaXMgZXhwZWN0ZWQgYW4gRXZlbnQgb2JqZWN0LCBidXQgZ290XCIsXG4gICAgICAgIGV2ZW50XG4gICAgKTtcbiAgICByZXR1cm4gcmV0dlxufVxuXG4vKipcbiAqIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jc2V0LXRoZS1jYW5jZWxlZC1mbGFnXG4gKiBAcGFyYW0gZGF0YSB7UHJpdmF0ZURhdGF9IHByaXZhdGUgZGF0YS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FuY2VsRmxhZyhkYXRhKSB7XG4gICAgaWYgKGRhdGEucGFzc2l2ZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5hYmxlIHRvIHByZXZlbnREZWZhdWx0IGluc2lkZSBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyIGludm9jYXRpb24uXCIsXG4gICAgICAgICAgICAgICAgZGF0YS5wYXNzaXZlTGlzdGVuZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghZGF0YS5ldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGRhdGEuY2FuY2VsZWQgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5wcmV2ZW50RGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGRhdGEuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1ldmVudFxuICogQHByaXZhdGVcbiAqL1xuLyoqXG4gKiBUaGUgZXZlbnQgd3JhcHBlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCBvZiB0aGlzIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtFdmVudHx7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgb3JpZ2luYWwgZXZlbnQgdG8gd3JhcC5cbiAqL1xuZnVuY3Rpb24gRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgcHJpdmF0ZURhdGEuc2V0KHRoaXMsIHtcbiAgICAgICAgZXZlbnRUYXJnZXQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBldmVudFBoYXNlOiAyLFxuICAgICAgICBjdXJyZW50VGFyZ2V0OiBldmVudFRhcmdldCxcbiAgICAgICAgY2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgICBzdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgaW1tZWRpYXRlU3RvcHBlZDogZmFsc2UsXG4gICAgICAgIHBhc3NpdmVMaXN0ZW5lcjogbnVsbCxcbiAgICAgICAgdGltZVN0YW1wOiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKSxcbiAgICB9KTtcblxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI1VuZm9yZ2VhYmxlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNUcnVzdGVkXCIsIHsgdmFsdWU6IGZhbHNlLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4gICAgLy8gRGVmaW5lIGFjY2Vzc29yc1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhldmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBTaG91bGQgYmUgZW51bWVyYWJsZSwgYnV0IGNsYXNzIG1ldGhvZHMgYXJlIG5vdCBlbnVtZXJhYmxlLlxuRXZlbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50LnR5cGVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKi9cbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudFRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmN1cnJlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0V2ZW50VGFyZ2V0W119IFRoZSBjb21wb3NlZCBwYXRoIG9mIHRoaXMgZXZlbnQuXG4gICAgICovXG4gICAgY29tcG9zZWRQYXRoKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gcGQodGhpcykuY3VycmVudFRhcmdldDtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjdXJyZW50VGFyZ2V0XVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBOT05FLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IE5PTkUoKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIENBUFRVUklOR19QSEFTRS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBDQVBUVVJJTkdfUEhBU0UoKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIEFUX1RBUkdFVC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBBVF9UQVJHRVQoKSB7XG4gICAgICAgIHJldHVybiAyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIEJVQkJMSU5HX1BIQVNFLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IEJVQkJMSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gM1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRQaGFzZSgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50UGhhc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKTtcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuc3RvcFByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKTtcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhLmltbWVkaWF0ZVN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gYmUgYnViYmxpbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGJ1YmJsZXMoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmJ1YmJsZXMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGNhbmNlbGFibGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmNhbmNlbGFibGUpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbmNlbCB0aGlzIGV2ZW50LlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICBzZXRDYW5jZWxGbGFnKHBkKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gaW5kaWNhdGUgY2FuY2VsbGF0aW9uIHN0YXRlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBkZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuY2FuY2VsZWRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gYmUgY29tcG9zZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNvbXBvc2VkKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5jb21wb3NlZClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHVuaXggdGltZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHRpbWVTdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLnRpbWVTdGFtcFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZ2V0IHNyY0VsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBzdG9wIGV2ZW50IGJ1YmJsaW5nLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZ2V0IGNhbmNlbEJ1YmJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLnN0b3BwZWRcbiAgICB9LFxuICAgIHNldCBjYW5jZWxCdWJibGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHBkKHRoaXMpO1xuXG4gICAgICAgIGRhdGEuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5jYW5jZWxCdWJibGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gaW5kaWNhdGUgY2FuY2VsbGF0aW9uIHN0YXRlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZ2V0IHJldHVyblZhbHVlKCkge1xuICAgICAgICByZXR1cm4gIXBkKHRoaXMpLmNhbmNlbGVkXG4gICAgfSxcbiAgICBzZXQgcmV0dXJuVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgc2V0Q2FuY2VsRmxhZyhwZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGlzIGV2ZW50IG9iamVjdC4gQnV0IGRvIG5vdGhpbmcgdW5kZXIgZXZlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYnViYmxlcz1mYWxzZV0gVGhlIGZsYWcgdG8gYmUgcG9zc2libGUgdG8gYnViYmxlIHVwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhbmNlbGFibGU9ZmFsc2VdIFRoZSBmbGFnIHRvIGJlIHBvc3NpYmxlIHRvIGNhbmNlbC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGluaXRFdmVudCgpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9LFxufTtcblxuLy8gYGNvbnN0cnVjdG9yYCBpcyBub3QgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwge1xuICAgIHZhbHVlOiBFdmVudCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG59KTtcblxuLy8gRW5zdXJlIGBldmVudCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudGAgaXMgYHRydWVgLlxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5FdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudC5wcm90b3R5cGUsIHdpbmRvdy5FdmVudC5wcm90b3R5cGUpO1xuXG4gICAgLy8gTWFrZSBhc3NvY2lhdGlvbiBmb3Igd3JhcHBlcnMuXG4gICAgd3JhcHBlcnMuc2V0KHdpbmRvdy5FdmVudC5wcm90b3R5cGUsIEV2ZW50KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcmVkaXJlY3QgYSBnaXZlbiBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZSB0byBkZWZpbmUgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIHJlZGlyZWN0IHRoZSBwcm9wZXJ0eS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRba2V5XVxuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHBkKHRoaXMpLmV2ZW50W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gY2FsbCBhIGdpdmVuIG1ldGhvZCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZSB0byBkZWZpbmUgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGNhbGwgdGhlIG1ldGhvZCBwcm9wZXJ0eS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUNhbGxEZXNjcmlwdG9yKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlKCkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBwZCh0aGlzKS5ldmVudDtcbiAgICAgICAgICAgIHJldHVybiBldmVudFtrZXldLmFwcGx5KGV2ZW50LCBhcmd1bWVudHMpXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogRGVmaW5lIG5ldyB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQmFzZUV2ZW50IFRoZSBiYXNlIHdyYXBwZXIgY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIHByb3RvdHlwZSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBkZWZpbmVkIHdyYXBwZXIgY2xhc3MuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVXcmFwcGVyKEJhc2VFdmVudCwgcHJvdG8pIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvdG8pO1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQmFzZUV2ZW50XG4gICAgfVxuXG4gICAgLyoqIEN1c3RvbUV2ZW50ICovXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgICAgIEJhc2VFdmVudC5jYWxsKHRoaXMsIGV2ZW50VGFyZ2V0LCBldmVudCk7XG4gICAgfVxuXG4gICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlRXZlbnQucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBDdXN0b21FdmVudCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgIH0pO1xuXG4gICAgLy8gRGVmaW5lIGFjY2Vzc29ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCEoa2V5IGluIEJhc2VFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywga2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGlzRnVuYyA9IHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBpc0Z1bmNcbiAgICAgICAgICAgICAgICAgICAgPyBkZWZpbmVDYWxsRGVzY3JpcHRvcihrZXkpXG4gICAgICAgICAgICAgICAgICAgIDogZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ3VzdG9tRXZlbnRcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdyYXBwZXIgY2xhc3Mgb2YgYSBnaXZlbiBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIHByb3RvdHlwZSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gZ2V0IGl0cyB3cmFwcGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgd3JhcHBlciBjbGFzcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFdyYXBwZXIocHJvdG8pIHtcbiAgICBpZiAocHJvdG8gPT0gbnVsbCB8fCBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICByZXR1cm4gRXZlbnRcbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlciA9IHdyYXBwZXJzLmdldChwcm90byk7XG4gICAgaWYgKHdyYXBwZXIgPT0gbnVsbCkge1xuICAgICAgICB3cmFwcGVyID0gZGVmaW5lV3JhcHBlcihnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpLCBwcm90byk7XG4gICAgICAgIHdyYXBwZXJzLnNldChwcm90bywgd3JhcHBlcik7XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVyXG59XG5cbi8qKlxuICogV3JhcCBhIGdpdmVuIGV2ZW50IHRvIG1hbmFnZW1lbnQgYSBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2YgdGhpcyBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgZXZlbnQgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtFdmVudH0gVGhlIHdyYXBwZXIgaW5zdGFuY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB3cmFwRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgY29uc3QgV3JhcHBlciA9IGdldFdyYXBwZXIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSk7XG4gICAgcmV0dXJuIG5ldyBXcmFwcGVyKGV2ZW50VGFyZ2V0LCBldmVudClcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGltbWVkaWF0ZVN0b3BwZWQgZmxhZyBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGdldC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uIGltbWVkaWF0ZWx5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTdG9wcGVkKGV2ZW50KSB7XG4gICAgcmV0dXJuIHBkKGV2ZW50KS5pbW1lZGlhdGVTdG9wcGVkXG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IGV2ZW50IHBoYXNlIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50UGhhc2UgTmV3IGV2ZW50IHBoYXNlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRFdmVudFBoYXNlKGV2ZW50LCBldmVudFBoYXNlKSB7XG4gICAgcGQoZXZlbnQpLmV2ZW50UGhhc2UgPSBldmVudFBoYXNlO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCB0YXJnZXQgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBzZXQgY3VycmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fG51bGx9IGN1cnJlbnRUYXJnZXQgTmV3IGN1cnJlbnQgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRDdXJyZW50VGFyZ2V0KGV2ZW50LCBjdXJyZW50VGFyZ2V0KSB7XG4gICAgcGQoZXZlbnQpLmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xufVxuXG4vKipcbiAqIFNldCBhIHBhc3NpdmUgbGlzdGVuZXIgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBzZXQgY3VycmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx9IHBhc3NpdmVMaXN0ZW5lciBOZXcgcGFzc2l2ZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0UGFzc2l2ZUxpc3RlbmVyKGV2ZW50LCBwYXNzaXZlTGlzdGVuZXIpIHtcbiAgICBwZChldmVudCkucGFzc2l2ZUxpc3RlbmVyID0gcGFzc2l2ZUxpc3RlbmVyO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IExpc3RlbmVyTm9kZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqIEBwcm9wZXJ0eSB7MXwyfDN9IGxpc3RlbmVyVHlwZVxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXNzaXZlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9uY2VcbiAqIEBwcm9wZXJ0eSB7TGlzdGVuZXJOb2RlfG51bGx9IG5leHRcbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7V2Vha01hcDxvYmplY3QsIE1hcDxzdHJpbmcsIExpc3RlbmVyTm9kZT4+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgbGlzdGVuZXJzTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gTGlzdGVuZXIgdHlwZXNcbmNvbnN0IENBUFRVUkUgPSAxO1xuY29uc3QgQlVCQkxFID0gMjtcbmNvbnN0IEFUVFJJQlVURSA9IDM7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdCBvciBub3QuXG4gKiBAcGFyYW0ge2FueX0geCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbn1cblxuLyoqXG4gKiBHZXQgbGlzdGVuZXJzLlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCB0byBnZXQuXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgTGlzdGVuZXJOb2RlPn0gVGhlIGxpc3RlbmVycy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldExpc3RlbmVycyhldmVudFRhcmdldCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IGxpc3RlbmVyc01hcC5nZXQoZXZlbnRUYXJnZXQpO1xuICAgIGlmIChsaXN0ZW5lcnMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgXCIndGhpcycgaXMgZXhwZWN0ZWQgYW4gRXZlbnRUYXJnZXQgb2JqZWN0LCBidXQgZ290IGFub3RoZXIgdmFsdWUuXCJcbiAgICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gbGlzdGVuZXJzXG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciB0aGUgZXZlbnQgYXR0cmlidXRlIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGdldCBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXJUeXBlID09PSBBVFRSSUJVVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubGlzdGVuZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0KGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIgJiYgIWlzT2JqZWN0KGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSB0byB0aGUgdGFpbCB3aGlsZSByZW1vdmluZyBvbGQgdmFsdWUuXG4gICAgICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0ZW5lclR5cGUgPT09IEFUVFJJQlVURSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgbmV3IHZhbHVlLlxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyVHlwZTogQVRUUklCVVRFLFxuICAgICAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb25jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogRGVmaW5lIGFuIGV2ZW50IGF0dHJpYnV0ZSAoZS5nLiBgZXZlbnRUYXJnZXQub25jbGlja2ApLlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50VGFyZ2V0UHJvdG90eXBlIFRoZSBldmVudCB0YXJnZXQgcHJvdG90eXBlIHRvIGRlZmluZSBhbiBldmVudCBhdHRyYml0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gZGVmaW5lLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRlZmluZUV2ZW50QXR0cmlidXRlKGV2ZW50VGFyZ2V0UHJvdG90eXBlLCBldmVudE5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIGV2ZW50VGFyZ2V0UHJvdG90eXBlLFxuICAgICAgICBgb24ke2V2ZW50TmFtZX1gLFxuICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IoZXZlbnROYW1lKVxuICAgICk7XG59XG5cbi8qKlxuICogRGVmaW5lIGEgY3VzdG9tIEV2ZW50VGFyZ2V0IHdpdGggZXZlbnQgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50TmFtZXMgRXZlbnQgbmFtZXMgZm9yIGV2ZW50IGF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJucyB7RXZlbnRUYXJnZXR9IFRoZSBjdXN0b20gRXZlbnRUYXJnZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FdmVudFRhcmdldChldmVudE5hbWVzKSB7XG4gICAgLyoqIEN1c3RvbUV2ZW50VGFyZ2V0ICovXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ3VzdG9tRXZlbnRUYXJnZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudFRhcmdldC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBDdXN0b21FdmVudFRhcmdldCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGRlZmluZUV2ZW50QXR0cmlidXRlKEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgZXZlbnROYW1lc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50VGFyZ2V0XG59XG5cbi8qKlxuICogRXZlbnRUYXJnZXQuXG4gKlxuICogLSBUaGlzIGlzIGNvbnN0cnVjdG9yIGlmIG5vIGFyZ3VtZW50cy5cbiAqIC0gVGhpcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBDdXN0b21FdmVudFRhcmdldCBjb25zdHJ1Y3RvciBpZiB0aGVyZSBhcmUgYXJndW1lbnRzLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBjbGFzcyBBIGV4dGVuZHMgRXZlbnRUYXJnZXQge31cbiAqICAgICBjbGFzcyBCIGV4dGVuZHMgRXZlbnRUYXJnZXQoXCJtZXNzYWdlXCIpIHt9XG4gKiAgICAgY2xhc3MgQyBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiLCBcImVycm9yXCIpIHt9XG4gKiAgICAgY2xhc3MgRCBleHRlbmRzIEV2ZW50VGFyZ2V0KFtcIm1lc3NhZ2VcIiwgXCJlcnJvclwiXSkge31cbiAqL1xuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgbGlzdGVuZXJzTWFwLnNldCh0aGlzLCBuZXcgTWFwKCkpO1xuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVDdXN0b21FdmVudFRhcmdldChhcmd1bWVudHNbMF0pXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0eXBlcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHR5cGVzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbmVDdXN0b21FdmVudFRhcmdldCh0eXBlcylcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKVxuICAgIC8qZXNsaW50LWVuYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xufVxuXG4vLyBTaG91bGQgYmUgZW51bWVyYWJsZSwgYnV0IGNsYXNzIG1ldGhvZHMgYXJlIG5vdCBlbnVtZXJhYmxlLlxuRXZlbnRUYXJnZXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEFkZCBhIGdpdmVuIGxpc3RlbmVyIHRvIHRoaXMgZXZlbnQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBhZGQuXG4gICAgICogQHBhcmFtIHtib29sZWFufHtjYXB0dXJlPzpib29sZWFuLHBhc3NpdmU/OmJvb2xlYW4sb25jZT86Ym9vbGVhbn19IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhpcyBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIiAmJiAhaXNPYmplY3QobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2xpc3RlbmVyJyBzaG91bGQgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QuXCIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNJc09iaiA9IGlzT2JqZWN0KG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYXB0dXJlID0gb3B0aW9uc0lzT2JqXG4gICAgICAgICAgICA/IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKVxuICAgICAgICAgICAgOiBCb29sZWFuKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lclR5cGUgPSBjYXB0dXJlID8gQ0FQVFVSRSA6IEJVQkJMRTtcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgbGlzdGVuZXJUeXBlLFxuICAgICAgICAgICAgcGFzc2l2ZTogb3B0aW9uc0lzT2JqICYmIEJvb2xlYW4ob3B0aW9ucy5wYXNzaXZlKSxcbiAgICAgICAgICAgIG9uY2U6IG9wdGlvbnNJc09iaiAmJiBCb29sZWFuKG9wdGlvbnMub25jZSksXG4gICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBpdCBhcyB0aGUgZmlyc3Qgbm9kZSBpZiB0aGUgZmlyc3Qgbm9kZSBpcyBudWxsLlxuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ld05vZGUpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmF2ZXJzZSB0byB0aGUgdGFpbCB3aGlsZSBjaGVja2luZyBkdXBsaWNhdGlvbi4uXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lclR5cGUgPT09IGxpc3RlbmVyVHlwZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGlnbm9yZSBkdXBsaWNhdGlvbi5cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBpdC5cbiAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZ2l2ZW4gbGlzdGVuZXIgZnJvbSB0aGlzIGV2ZW50IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx7Y2FwdHVyZT86Ym9vbGVhbixwYXNzaXZlPzpib29sZWFuLG9uY2U/OmJvb2xlYW59fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoaXMgbGlzdGVuZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGlzT2JqZWN0KG9wdGlvbnMpXG4gICAgICAgICAgICA/IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKVxuICAgICAgICAgICAgOiBCb29sZWFuKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lclR5cGUgPSBjYXB0dXJlID8gQ0FQVFVSRSA6IEJVQkJMRTtcblxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyVHlwZSA9PT0gbGlzdGVuZXJUeXBlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGEgZ2l2ZW4gZXZlbnQuXG4gICAgICogQHBhcmFtIHtFdmVudHx7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGBmYWxzZWAgaWYgY2FuY2VsZWQuXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQgPT0gbnVsbCB8fCB0eXBlb2YgZXZlbnQudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJldmVudC50eXBlXCIgc2hvdWxkIGJlIGEgc3RyaW5nLicpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBsaXN0ZW5lcnMgYXJlbid0IHJlZ2lzdGVyZWQsIHRlcm1pbmF0ZS5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBldmVudC50eXBlO1xuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmNlIHdlIGNhbm5vdCByZXdyaXRlIHNldmVyYWwgcHJvcGVydGllcywgc28gd3JhcCBvYmplY3QuXG4gICAgICAgIGNvbnN0IHdyYXBwZWRFdmVudCA9IHdyYXBFdmVudCh0aGlzLCBldmVudCk7XG5cbiAgICAgICAgLy8gVGhpcyBkb2Vzbid0IHByb2Nlc3MgY2FwdHVyaW5nIHBoYXNlIGFuZCBidWJibGluZyBwaGFzZS5cbiAgICAgICAgLy8gVGhpcyBpc24ndCBwYXJ0aWNpcGF0aW5nIGluIGEgdHJlZS5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBsaXN0ZW5lciBpZiBpdCdzIG9uY2VcbiAgICAgICAgICAgIGlmIChub2RlLm9uY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhpcyBsaXN0ZW5lclxuICAgICAgICAgICAgc2V0UGFzc2l2ZUxpc3RlbmVyKFxuICAgICAgICAgICAgICAgIHdyYXBwZWRFdmVudCxcbiAgICAgICAgICAgICAgICBub2RlLnBhc3NpdmUgPyBub2RlLmxpc3RlbmVyIDogbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5saXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lci5jYWxsKHRoaXMsIHdyYXBwZWRFdmVudCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyVHlwZSAhPT0gQVRUUklCVVRFICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5vZGUubGlzdGVuZXIuaGFuZGxlRXZlbnQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCh3cmFwcGVkRXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCcmVhayBpZiBgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uYCB3YXMgY2FsbGVkLlxuICAgICAgICAgICAgaWYgKGlzU3RvcHBlZCh3cmFwcGVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBzZXRQYXNzaXZlTGlzdGVuZXIod3JhcHBlZEV2ZW50LCBudWxsKTtcbiAgICAgICAgc2V0RXZlbnRQaGFzZSh3cmFwcGVkRXZlbnQsIDApO1xuICAgICAgICBzZXRDdXJyZW50VGFyZ2V0KHdyYXBwZWRFdmVudCwgbnVsbCk7XG5cbiAgICAgICAgcmV0dXJuICF3cmFwcGVkRXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICAgIH0sXG59O1xuXG4vLyBgY29uc3RydWN0b3JgIGlzIG5vdCBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7XG4gICAgdmFsdWU6IEV2ZW50VGFyZ2V0LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbn0pO1xuXG4vLyBFbnN1cmUgYGV2ZW50VGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50VGFyZ2V0YCBpcyBgdHJ1ZWAuXG5pZiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiB3aW5kb3cuRXZlbnRUYXJnZXQgIT09IFwidW5kZWZpbmVkXCJcbikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudFRhcmdldC5wcm90b3R5cGUsIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUpO1xufVxuXG4vKipcbiAqIEBhdXRob3IgVG9ydSBOYWdhc2hpbWEgPGh0dHBzOi8vZ2l0aHViLmNvbS9teXN0aWNhdGVhPlxuICogU2VlIExJQ0VOU0UgZmlsZSBpbiByb290IGRpcmVjdG9yeSBmb3IgZnVsbCBsaWNlbnNlLlxuICovXG5cbi8qKlxuICogVGhlIHNpZ25hbCBjbGFzcy5cbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNhYm9ydHNpZ25hbFxuICovXG5jbGFzcyBBYm9ydFNpZ25hbCBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgICAvKipcbiAgICAgKiBBYm9ydFNpZ25hbCBjYW5ub3QgYmUgY29uc3RydWN0ZWQgZGlyZWN0bHkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBYm9ydFNpZ25hbCBjYW5ub3QgYmUgY29uc3RydWN0ZWQgZGlyZWN0bHlcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgYEFib3J0U2lnbmFsYCdzIGBBYm9ydENvbnRyb2xsZXJgIGhhcyBzaWduYWxlZCB0byBhYm9ydCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdldCBhYm9ydGVkKCkge1xuICAgICAgICBjb25zdCBhYm9ydGVkID0gYWJvcnRlZEZsYWdzLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhYm9ydGVkICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgJ3RoaXMnIHRvIGJlIGFuICdBYm9ydFNpZ25hbCcgb2JqZWN0LCBidXQgZ290ICR7dGhpcyA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHRoaXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFib3J0ZWQ7XG4gICAgfVxufVxuZGVmaW5lRXZlbnRBdHRyaWJ1dGUoQWJvcnRTaWduYWwucHJvdG90eXBlLCBcImFib3J0XCIpO1xuLyoqXG4gKiBDcmVhdGUgYW4gQWJvcnRTaWduYWwgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVBYm9ydFNpZ25hbCgpIHtcbiAgICBjb25zdCBzaWduYWwgPSBPYmplY3QuY3JlYXRlKEFib3J0U2lnbmFsLnByb3RvdHlwZSk7XG4gICAgRXZlbnRUYXJnZXQuY2FsbChzaWduYWwpO1xuICAgIGFib3J0ZWRGbGFncy5zZXQoc2lnbmFsLCBmYWxzZSk7XG4gICAgcmV0dXJuIHNpZ25hbDtcbn1cbi8qKlxuICogQWJvcnQgYSBnaXZlbiBzaWduYWwuXG4gKi9cbmZ1bmN0aW9uIGFib3J0U2lnbmFsKHNpZ25hbCkge1xuICAgIGlmIChhYm9ydGVkRmxhZ3MuZ2V0KHNpZ25hbCkgIT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWJvcnRlZEZsYWdzLnNldChzaWduYWwsIHRydWUpO1xuICAgIHNpZ25hbC5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJhYm9ydFwiIH0pO1xufVxuLyoqXG4gKiBBYm9ydGVkIGZsYWcgZm9yIGVhY2ggaW5zdGFuY2VzLlxuICovXG5jb25zdCBhYm9ydGVkRmxhZ3MgPSBuZXcgV2Vha01hcCgpO1xuLy8gUHJvcGVydGllcyBzaG91bGQgYmUgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFib3J0U2lnbmFsLnByb3RvdHlwZSwge1xuICAgIGFib3J0ZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxufSk7XG4vLyBgdG9TdHJpbmcoKWAgc2hvdWxkIHJldHVybiBgXCJbb2JqZWN0IEFib3J0U2lnbmFsXVwiYFxuaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSBcInN5bWJvbFwiKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFib3J0U2lnbmFsLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFwiQWJvcnRTaWduYWxcIixcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBUaGUgQWJvcnRDb250cm9sbGVyLlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2Fib3J0Y29udHJvbGxlclxuICovXG5jbGFzcyBBYm9ydENvbnRyb2xsZXIkMSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHNpZ25hbHMuc2V0KHRoaXMsIGNyZWF0ZUFib3J0U2lnbmFsKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgQWJvcnRTaWduYWxgIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgZ2V0IHNpZ25hbCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFNpZ25hbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWJvcnQgYW5kIHNpZ25hbCB0byBhbnkgb2JzZXJ2ZXJzIHRoYXQgdGhlIGFzc29jaWF0ZWQgYWN0aXZpdHkgaXMgdG8gYmUgYWJvcnRlZC5cbiAgICAgKi9cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgYWJvcnRTaWduYWwoZ2V0U2lnbmFsKHRoaXMpKTtcbiAgICB9XG59XG4vKipcbiAqIEFzc29jaWF0ZWQgc2lnbmFscy5cbiAqL1xuY29uc3Qgc2lnbmFscyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEdldCB0aGUgYXNzb2NpYXRlZCBzaWduYWwgb2YgYSBnaXZlbiBjb250cm9sbGVyLlxuICovXG5mdW5jdGlvbiBnZXRTaWduYWwoY29udHJvbGxlcikge1xuICAgIGNvbnN0IHNpZ25hbCA9IHNpZ25hbHMuZ2V0KGNvbnRyb2xsZXIpO1xuICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCAndGhpcycgdG8gYmUgYW4gJ0Fib3J0Q29udHJvbGxlcicgb2JqZWN0LCBidXQgZ290ICR7Y29udHJvbGxlciA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIGNvbnRyb2xsZXJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBzaWduYWw7XG59XG4vLyBQcm9wZXJ0aWVzIHNob3VsZCBiZSBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQWJvcnRDb250cm9sbGVyJDEucHJvdG90eXBlLCB7XG4gICAgc2lnbmFsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG59KTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gXCJzeW1ib2xcIikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYm9ydENvbnRyb2xsZXIkMS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBcIkFib3J0Q29udHJvbGxlclwiLFxuICAgIH0pO1xufVxuXG5leHBvcnRzLkFib3J0Q29udHJvbGxlciA9IEFib3J0Q29udHJvbGxlciQxO1xuZXhwb3J0cy5BYm9ydEVycm9yID0gQWJvcnRFcnJvcjtcbmV4cG9ydHMuRmV0Y2hFcnJvciA9IEZldGNoRXJyb3I7XG5leHBvcnRzLkZpbGUgPSBGaWxlJDE7XG5leHBvcnRzLkZvcm1EYXRhID0gRm9ybURhdGE7XG5leHBvcnRzLkhlYWRlcnMgPSBIZWFkZXJzO1xuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcbmV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbmV4cG9ydHMuX0Jsb2IgPSBfQmxvYiQxO1xuZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuZXhwb3J0cy5pc1JlZGlyZWN0ID0gaXNSZWRpcmVjdDtcbmV4cG9ydHMubm9kZURvbWV4Y2VwdGlvbiA9IG5vZGVEb21leGNlcHRpb247XG4iXSwibmFtZXMiOlsiaHR0cCIsInJlcXVpcmUiLCJodHRwcyIsInpsaWIiLCJTdHJlYW0iLCJub2RlX2J1ZmZlciIsIm5vZGVfdXRpbCIsIm5vZGVfdXJsIiwibm9kZV9uZXQiLCJkYXRhVXJpVG9CdWZmZXIiLCJ1cmkiLCJ0ZXN0IiwiVHlwZUVycm9yIiwicmVwbGFjZSIsImZpcnN0Q29tbWEiLCJpbmRleE9mIiwibWV0YSIsInN1YnN0cmluZyIsInNwbGl0IiwiY2hhcnNldCIsImJhc2U2NCIsInR5cGUiLCJ0eXBlRnVsbCIsImkiLCJsZW5ndGgiLCJlbmNvZGluZyIsImRhdGEiLCJ1bmVzY2FwZSIsImJ1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJjb21tb25qc0dsb2JhbCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwicG9ueWZpbGxfZXMyMDE4IiwiZXhwb3J0cyIsImhhc1JlcXVpcmVkUG9ueWZpbGxfZXMyMDE4IiwicmVxdWlyZVBvbnlmaWxsX2VzMjAxOCIsIm1vZHVsZSIsImZhY3RvcnkiLCJTeW1ib2xQb2x5ZmlsbCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZGVzY3JpcHRpb24iLCJub29wIiwidW5kZWZpbmVkIiwiZ2V0R2xvYmFscyIsImdsb2JhbHMiLCJ0eXBlSXNPYmplY3QiLCJ4IiwicmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uIiwib3JpZ2luYWxQcm9taXNlIiwiUHJvbWlzZSIsIm9yaWdpbmFsUHJvbWlzZVRoZW4iLCJwcm90b3R5cGUiLCJ0aGVuIiwib3JpZ2luYWxQcm9taXNlUmVzb2x2ZSIsInJlc29sdmUiLCJiaW5kIiwib3JpZ2luYWxQcm9taXNlUmVqZWN0IiwicmVqZWN0IiwibmV3UHJvbWlzZSIsImV4ZWN1dG9yIiwicHJvbWlzZVJlc29sdmVkV2l0aCIsInZhbHVlIiwicHJvbWlzZVJlamVjdGVkV2l0aCIsInJlYXNvbiIsIlBlcmZvcm1Qcm9taXNlVGhlbiIsInByb21pc2UiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJjYWxsIiwidXBvblByb21pc2UiLCJ1cG9uRnVsZmlsbG1lbnQiLCJ1cG9uUmVqZWN0aW9uIiwidHJhbnNmb3JtUHJvbWlzZVdpdGgiLCJmdWxmaWxsbWVudEhhbmRsZXIiLCJyZWplY3Rpb25IYW5kbGVyIiwic2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSIsInF1ZXVlTWljcm90YXNrIiwiZ2xvYmFsUXVldWVNaWNyb3Rhc2siLCJyZXNvbHZlZFByb21pc2UiLCJmbiIsInJlZmxlY3RDYWxsIiwiRiIsIlYiLCJhcmdzIiwiRnVuY3Rpb24iLCJhcHBseSIsInByb21pc2VDYWxsIiwiUVVFVUVfTUFYX0FSUkFZX1NJWkUiLCJTaW1wbGVRdWV1ZSIsImNvbnN0cnVjdG9yIiwiX2N1cnNvciIsIl9zaXplIiwiX2Zyb250IiwiX2VsZW1lbnRzIiwiX25leHQiLCJfYmFjayIsInB1c2giLCJlbGVtZW50Iiwib2xkQmFjayIsIm5ld0JhY2siLCJzaGlmdCIsIm9sZEZyb250IiwibmV3RnJvbnQiLCJvbGRDdXJzb3IiLCJuZXdDdXJzb3IiLCJlbGVtZW50cyIsImZvckVhY2giLCJjYWxsYmFjayIsIm5vZGUiLCJwZWVrIiwiZnJvbnQiLCJjdXJzb3IiLCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplIiwicmVhZGVyIiwic3RyZWFtIiwiX293bmVyUmVhZGFibGVTdHJlYW0iLCJfcmVhZGVyIiwiX3N0YXRlIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQiLCJfc3RvcmVkRXJyb3IiLCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwiLCJSZWFkYWJsZVN0cmVhbUNhbmNlbCIsIlJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdCIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkIiwicmVhZGVyTG9ja0V4Y2VwdGlvbiIsIm5hbWUiLCJfY2xvc2VkUHJvbWlzZSIsIl9jbG9zZWRQcm9taXNlX3Jlc29sdmUiLCJfY2xvc2VkUHJvbWlzZV9yZWplY3QiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUiLCJBYm9ydFN0ZXBzIiwiRXJyb3JTdGVwcyIsIkNhbmNlbFN0ZXBzIiwiUHVsbFN0ZXBzIiwiTnVtYmVySXNGaW5pdGUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk1hdGhUcnVuYyIsIk1hdGgiLCJ0cnVuYyIsInYiLCJjZWlsIiwiZmxvb3IiLCJpc0RpY3Rpb25hcnkiLCJhc3NlcnREaWN0aW9uYXJ5Iiwib2JqIiwiY29udGV4dCIsImFzc2VydEZ1bmN0aW9uIiwiaXNPYmplY3QiLCJhc3NlcnRPYmplY3QiLCJhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IiwicG9zaXRpb24iLCJhc3NlcnRSZXF1aXJlZEZpZWxkIiwiZmllbGQiLCJjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlIiwiY2Vuc29yTmVnYXRpdmVaZXJvIiwiaW50ZWdlclBhcnQiLCJjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UiLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJhc3NlcnRSZWFkYWJsZVN0cmVhbSIsIklzUmVhZGFibGVTdHJlYW0iLCJBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwiUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdCIsInJlYWRSZXF1ZXN0IiwiX3JlYWRSZXF1ZXN0cyIsIlJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0IiwiY2h1bmsiLCJkb25lIiwiX2Nsb3NlU3RlcHMiLCJfY2h1bmtTdGVwcyIsIlJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzIiwiUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyIiwiSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIiLCJJc1JlYWRhYmxlU3RyZWFtTG9ja2VkIiwiY2xvc2VkIiwiZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJjYW5jZWwiLCJyZWFkIiwicmVzb2x2ZVByb21pc2UiLCJyZWplY3RQcm9taXNlIiwiX2Vycm9yU3RlcHMiLCJlIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCIsInJlbGVhc2VMb2NrIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsImVudW1lcmFibGUiLCJ0b1N0cmluZ1RhZyIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiaGFzT3duUHJvcGVydHkiLCJfZGlzdHVyYmVkIiwiX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciIsIkFzeW5jSXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIlJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwiLCJwcmV2ZW50Q2FuY2VsIiwiX29uZ29pbmdQcm9taXNlIiwiX2lzRmluaXNoZWQiLCJfcHJldmVudENhbmNlbCIsIm5leHQiLCJuZXh0U3RlcHMiLCJfbmV4dFN0ZXBzIiwicmV0dXJuIiwicmV0dXJuU3RlcHMiLCJfcmV0dXJuU3RlcHMiLCJyZXN1bHQiLCJSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUiLCJJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciIsInN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uIiwiX2FzeW5jSXRlcmF0b3JJbXBsIiwic2V0UHJvdG90eXBlT2YiLCJBY3F1aXJlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yIiwiaW1wbCIsImNyZWF0ZSIsIl9hIiwiTnVtYmVySXNOYU4iLCJpc05hTiIsIkNyZWF0ZUFycmF5RnJvbUxpc3QiLCJzbGljZSIsIkNvcHlEYXRhQmxvY2tCeXRlcyIsImRlc3QiLCJkZXN0T2Zmc2V0Iiwic3JjIiwic3JjT2Zmc2V0IiwibiIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJUcmFuc2ZlckFycmF5QnVmZmVyIiwiTyIsIklzRGV0YWNoZWRCdWZmZXIiLCJBcnJheUJ1ZmZlclNsaWNlIiwiYmVnaW4iLCJlbmQiLCJBcnJheUJ1ZmZlciIsIklzTm9uTmVnYXRpdmVOdW1iZXIiLCJDbG9uZUFzVWludDhBcnJheSIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiRGVxdWV1ZVZhbHVlIiwiY29udGFpbmVyIiwicGFpciIsIl9xdWV1ZSIsIl9xdWV1ZVRvdGFsU2l6ZSIsInNpemUiLCJFbnF1ZXVlVmFsdWVXaXRoU2l6ZSIsIkluZmluaXR5IiwiUmFuZ2VFcnJvciIsIlBlZWtRdWV1ZVZhbHVlIiwiUmVzZXRRdWV1ZSIsIlJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QiLCJ2aWV3IiwiSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IiwiYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uIiwiX3ZpZXciLCJyZXNwb25kIiwiYnl0ZXNXcml0dGVuIiwiX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQiLCJyZXNwb25kV2l0aE5ld1ZpZXciLCJpc1ZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsImJ5b2JSZXF1ZXN0IiwiSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwiYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0IiwiZGVzaXJlZFNpemUiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUiLCJjbG9zZSIsIl9jbG9zZVJlcXVlc3RlZCIsInN0YXRlIiwiX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0iLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UiLCJlbnF1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUiLCJlcnJvciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MiLCJfY2FuY2VsQWxnb3JpdGhtIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsImVudHJ5IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4iLCJhdXRvQWxsb2NhdGVDaHVua1NpemUiLCJfYXV0b0FsbG9jYXRlQ2h1bmtTaXplIiwiYnVmZmVyRSIsInB1bGxJbnRvRGVzY3JpcHRvciIsImJ1ZmZlckJ5dGVMZW5ndGgiLCJieXRlc0ZpbGxlZCIsImVsZW1lbnRTaXplIiwidmlld0NvbnN0cnVjdG9yIiwicmVhZGVyVHlwZSIsIl9wZW5kaW5nUHVsbEludG9zIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQiLCJjb250cm9sbGVyIiwic2hvdWxkUHVsbCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaG91bGRDYWxsUHVsbCIsIl9wdWxsaW5nIiwiX3B1bGxBZ2FpbiIsInB1bGxQcm9taXNlIiwiX3B1bGxBbGdvcml0aG0iLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvciIsImZpbGxlZFZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvciIsIlJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRJbnRvUmVxdWVzdCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUiLCJjdXJyZW50QWxpZ25lZEJ5dGVzIiwibWF4Qnl0ZXNUb0NvcHkiLCJtaW4iLCJtYXhCeXRlc0ZpbGxlZCIsIm1heEFsaWduZWRCeXRlcyIsInRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmciLCJyZWFkeSIsInF1ZXVlIiwiaGVhZE9mUXVldWUiLCJieXRlc1RvQ29weSIsImRlc3RTdGFydCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvciIsIlJlYWRhYmxlU3RyZWFtQ2xvc2UiLCJfYnlvYlJlcXVlc3QiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvIiwicmVhZEludG9SZXF1ZXN0IiwiRGF0YVZpZXciLCJCWVRFU19QRVJfRUxFTUVOVCIsImN0b3IiLCJSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdCIsImVtcHR5VmlldyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZSIsImZpcnN0RGVzY3JpcHRvciIsIlJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlciIsIlJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlIiwicmVtYWluZGVyU2l6ZSIsInJlbWFpbmRlciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwiLCJkZXNjcmlwdG9yIiwiX3N0YXJ0ZWQiLCJmaXJzdFBlbmRpbmdQdWxsSW50byIsInRyYW5zZmVycmVkQnVmZmVyIiwidHJhbnNmZXJyZWRWaWV3IiwiUmVhZGFibGVTdHJlYW1FcnJvciIsIlNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsIl9zdHJhdGVneUhXTSIsInZpZXdCeXRlTGVuZ3RoIiwiU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwic3RhcnRBbGdvcml0aG0iLCJwdWxsQWxnb3JpdGhtIiwiY2FuY2VsQWxnb3JpdGhtIiwiaGlnaFdhdGVyTWFyayIsInN0YXJ0UmVzdWx0IiwiciIsIlNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlIiwidW5kZXJseWluZ0J5dGVTb3VyY2UiLCJzdGFydCIsInB1bGwiLCJyZXF1ZXN0IiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciIsIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciIsIl9yZWFkSW50b1JlcXVlc3RzIiwiSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCJieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQiLCJFeHRyYWN0SGlnaFdhdGVyTWFyayIsInN0cmF0ZWd5IiwiZGVmYXVsdEhXTSIsIkV4dHJhY3RTaXplQWxnb3JpdGhtIiwiY29udmVydFF1ZXVpbmdTdHJhdGVneSIsImluaXQiLCJjb252ZXJ0UXVldWluZ1N0cmF0ZWd5U2l6ZSIsImNvbnZlcnRVbmRlcmx5aW5nU2luayIsIm9yaWdpbmFsIiwiYWJvcnQiLCJ3cml0ZSIsImNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2siLCJhc3NlcnRXcml0YWJsZVN0cmVhbSIsIklzV3JpdGFibGVTdHJlYW0iLCJpc0Fib3J0U2lnbmFsIiwiYWJvcnRlZCIsInN1cHBvcnRzQWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiY3JlYXRlQWJvcnRDb250cm9sbGVyIiwiV3JpdGFibGVTdHJlYW0iLCJyYXdVbmRlcmx5aW5nU2luayIsInJhd1N0cmF0ZWd5IiwidW5kZXJseWluZ1NpbmsiLCJJbml0aWFsaXplV3JpdGFibGVTdHJlYW0iLCJzaXplQWxnb3JpdGhtIiwiU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rIiwibG9ja2VkIiwic3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyIiwiSXNXcml0YWJsZVN0cmVhbUxvY2tlZCIsIldyaXRhYmxlU3RyZWFtQWJvcnQiLCJXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodCIsIldyaXRhYmxlU3RyZWFtQ2xvc2UiLCJnZXRXcml0ZXIiLCJBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIiwiQ3JlYXRlV3JpdGFibGVTdHJlYW0iLCJ3cml0ZUFsZ29yaXRobSIsImNsb3NlQWxnb3JpdGhtIiwiYWJvcnRBbGdvcml0aG0iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiX3dyaXRlciIsIl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIiLCJfd3JpdGVSZXF1ZXN0cyIsIl9pbkZsaWdodFdyaXRlUmVxdWVzdCIsIl9jbG9zZVJlcXVlc3QiLCJfaW5GbGlnaHRDbG9zZVJlcXVlc3QiLCJfcGVuZGluZ0Fib3J0UmVxdWVzdCIsIl9iYWNrcHJlc3N1cmUiLCJfYWJvcnRSZWFzb24iLCJfYWJvcnRDb250cm9sbGVyIiwiX3Byb21pc2UiLCJ3YXNBbHJlYWR5RXJyb3JpbmciLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJfcmVhc29uIiwiX3dhc0FscmVhZHlFcnJvcmluZyIsIldyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyIsImNsb3NlUmVxdWVzdCIsIndyaXRlciIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlIiwiV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3QiLCJ3cml0ZVJlcXVlc3QiLCJXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uIiwiV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkIiwiV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodCIsInN0b3JlZEVycm9yIiwiV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZCIsImFib3J0UmVxdWVzdCIsIldyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZSIsIldyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvciIsIldyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZSIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSIsIldyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvciIsIldyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0IiwiV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0IiwiV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUiLCJiYWNrcHJlc3N1cmUiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXQiLCJfb3duZXJXcml0YWJsZVN0cmVhbSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQiLCJJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsImRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwiZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSIsIl9yZWFkeVByb21pc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbiIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCIsIl9jbG9zZWRQcm9taXNlU3RhdGUiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCIsIl9yZWFkeVByb21pc2VTdGF0ZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3QiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplIiwicmVsZWFzZWRFcnJvciIsImNodW5rU2l6ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyV3JpdGUiLCJjbG9zZVNlbnRpbmVsIiwiYWJvcnRSZWFzb24iLCJJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMiIsInNpZ25hbCIsIl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IiLCJfYWJvcnRBbGdvcml0aG0iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zIiwiX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSIsIl93cml0ZUFsZ29yaXRobSIsIl9jbG9zZUFsZ29yaXRobSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUiLCJzdGFydFByb21pc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQiLCJjaHVua1NpemVFIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQiLCJlbnF1ZXVlRSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlIiwic2lua0Nsb3NlUHJvbWlzZSIsInNpbmtXcml0ZVByb21pc2UiLCJfcmVhZHlQcm9taXNlX3Jlc29sdmUiLCJfcmVhZHlQcm9taXNlX3JlamVjdCIsIk5hdGl2ZURPTUV4Y2VwdGlvbiIsIkRPTUV4Y2VwdGlvbiIsImlzRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IiLCJjcmVhdGVET01FeGNlcHRpb25Qb2x5ZmlsbCIsIm1lc3NhZ2UiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwid3JpdGFibGUiLCJET01FeGNlcHRpb24kMSIsIlJlYWRhYmxlU3RyZWFtUGlwZVRvIiwic291cmNlIiwicHJldmVudENsb3NlIiwicHJldmVudEFib3J0Iiwic2h1dHRpbmdEb3duIiwiY3VycmVudFdyaXRlIiwiYWN0aW9ucyIsInNodXRkb3duV2l0aEFjdGlvbiIsImFsbCIsIm1hcCIsImFjdGlvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJwaXBlTG9vcCIsInJlc29sdmVMb29wIiwicmVqZWN0TG9vcCIsInBpcGVTdGVwIiwicmVzb2x2ZVJlYWQiLCJyZWplY3RSZWFkIiwiaXNPckJlY29tZXNFcnJvcmVkIiwic2h1dGRvd24iLCJpc09yQmVjb21lc0Nsb3NlZCIsImRlc3RDbG9zZWQiLCJ3YWl0Rm9yV3JpdGVzVG9GaW5pc2giLCJvbGRDdXJyZW50V3JpdGUiLCJvcmlnaW5hbElzRXJyb3IiLCJvcmlnaW5hbEVycm9yIiwiZG9UaGVSZXN0IiwiZmluYWxpemUiLCJuZXdFcnJvciIsImlzRXJyb3IiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIklzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsImRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zIiwiX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckhhc0JhY2twcmVzc3VyZSIsIlNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIlNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlIiwidW5kZXJseWluZ1NvdXJjZSIsIlJlYWRhYmxlU3RyZWFtVGVlIiwiY2xvbmVGb3JCcmFuY2gyIiwiUmVhZGFibGVCeXRlU3RyZWFtVGVlIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0VGVlIiwicmVhZGluZyIsInJlYWRBZ2FpbiIsImNhbmNlbGVkMSIsImNhbmNlbGVkMiIsInJlYXNvbjEiLCJyZWFzb24yIiwiYnJhbmNoMSIsImJyYW5jaDIiLCJyZXNvbHZlQ2FuY2VsUHJvbWlzZSIsImNhbmNlbFByb21pc2UiLCJjaHVuazEiLCJjaHVuazIiLCJjYW5jZWwxQWxnb3JpdGhtIiwiY29tcG9zaXRlUmVhc29uIiwiY2FuY2VsUmVzdWx0IiwiY2FuY2VsMkFsZ29yaXRobSIsIkNyZWF0ZVJlYWRhYmxlU3RyZWFtIiwicmVhZEFnYWluRm9yQnJhbmNoMSIsInJlYWRBZ2FpbkZvckJyYW5jaDIiLCJmb3J3YXJkUmVhZGVyRXJyb3IiLCJ0aGlzUmVhZGVyIiwicHVsbFdpdGhEZWZhdWx0UmVhZGVyIiwiY2xvbmVFIiwicHVsbDFBbGdvcml0aG0iLCJwdWxsMkFsZ29yaXRobSIsInB1bGxXaXRoQllPQlJlYWRlciIsImZvckJyYW5jaDIiLCJieW9iQnJhbmNoIiwib3RoZXJCcmFuY2giLCJieW9iQ2FuY2VsZWQiLCJvdGhlckNhbmNlbGVkIiwiY2xvbmVkQ2h1bmsiLCJDcmVhdGVSZWFkYWJsZUJ5dGVTdHJlYW0iLCJjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2UiLCJjb252ZXJ0VW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVN0YXJ0Q2FsbGJhY2siLCJjb252ZXJ0UmVhZGFibGVTdHJlYW1UeXBlIiwiY29udmVydFJlYWRlck9wdGlvbnMiLCJvcHRpb25zIiwibW9kZSIsImNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUiLCJjb252ZXJ0SXRlcmF0b3JPcHRpb25zIiwiQm9vbGVhbiIsImNvbnZlcnRQaXBlT3B0aW9ucyIsImFzc2VydEFib3J0U2lnbmFsIiwiY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyIiwicmVhZGFibGUiLCJSZWFkYWJsZVN0cmVhbSIsInJhd1VuZGVybHlpbmdTb3VyY2UiLCJJbml0aWFsaXplUmVhZGFibGVTdHJlYW0iLCJzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEiLCJnZXRSZWFkZXIiLCJyYXdPcHRpb25zIiwicGlwZVRocm91Z2giLCJyYXdUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJwaXBlVG8iLCJkZXN0aW5hdGlvbiIsInRlZSIsImJyYW5jaGVzIiwidmFsdWVzIiwiYXN5bmNJdGVyYXRvciIsInNvdXJjZUNhbmNlbFByb21pc2UiLCJjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdCIsImJ5dGVMZW5ndGhTaXplRnVuY3Rpb24iLCJCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IiwiX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrIiwiSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IiwiYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24iLCJjb3VudFNpemVGdW5jdGlvbiIsIkNvdW50UXVldWluZ1N0cmF0ZWd5IiwiX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayIsIklzQ291bnRRdWV1aW5nU3RyYXRlZ3kiLCJjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24iLCJjb252ZXJ0VHJhbnNmb3JtZXIiLCJmbHVzaCIsInJlYWRhYmxlVHlwZSIsIndyaXRhYmxlVHlwZSIsImNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2siLCJjb252ZXJ0VHJhbnNmb3JtZXJTdGFydENhbGxiYWNrIiwiY29udmVydFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2siLCJUcmFuc2Zvcm1TdHJlYW0iLCJyYXdUcmFuc2Zvcm1lciIsInJhd1dyaXRhYmxlU3RyYXRlZ3kiLCJyYXdSZWFkYWJsZVN0cmF0ZWd5Iiwid3JpdGFibGVTdHJhdGVneSIsInJlYWRhYmxlU3RyYXRlZ3kiLCJ0cmFuc2Zvcm1lciIsInJlYWRhYmxlSGlnaFdhdGVyTWFyayIsInJlYWRhYmxlU2l6ZUFsZ29yaXRobSIsIndyaXRhYmxlSGlnaFdhdGVyTWFyayIsIndyaXRhYmxlU2l6ZUFsZ29yaXRobSIsInN0YXJ0UHJvbWlzZV9yZXNvbHZlIiwiSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbSIsIlNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXIiLCJfdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciIsIklzVHJhbnNmb3JtU3RyZWFtIiwic3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiIsIl9yZWFkYWJsZSIsIl93cml0YWJsZSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rV3JpdGVBbGdvcml0aG0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Fib3J0QWxnb3JpdGhtIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtDbG9zZUFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtIiwiVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZSIsIl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlIiwiX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSIsIlRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZSIsIlRyYW5zZm9ybVN0cmVhbUVycm9yIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIklzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJyZWFkYWJsZUNvbnRyb2xsZXIiLCJfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IiLCJ0ZXJtaW5hdGUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclRlcm1pbmF0ZSIsIlNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJ0cmFuc2Zvcm1BbGdvcml0aG0iLCJmbHVzaEFsZ29yaXRobSIsIl90cmFuc2Zvcm1BbGdvcml0aG0iLCJfZmx1c2hBbGdvcml0aG0iLCJ0cmFuc2Zvcm1SZXN1bHRFIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtIiwidHJhbnNmb3JtUHJvbWlzZSIsImJhY2twcmVzc3VyZUNoYW5nZVByb21pc2UiLCJmbHVzaFByb21pc2UiLCJQT09MX1NJWkUkMSIsInByb2Nlc3MiLCJlbWl0V2FybmluZyIsImFzc2lnbiIsIkJsb2IiLCJwYXJhbXMiLCJibG9iIiwiY3RybCIsImFycmF5QnVmZmVyIiwiUE9PTF9TSVpFIiwidG9JdGVyYXRvciIsInBhcnRzIiwiY2xvbmUiLCJwYXJ0IiwiYiIsIl9CbG9iIiwiZW5kaW5ncyIsImJsb2JQYXJ0cyIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsIlN0cmluZyIsInRleHQiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJzdHIiLCJkZWNvZGUiLCJvZmZzZXQiLCJpdCIsInJlbGF0aXZlU3RhcnQiLCJtYXgiLCJyZWxhdGl2ZUVuZCIsInNwYW4iLCJhZGRlZCIsInN1YmFycmF5IiwidG9Mb3dlckNhc2UiLCJoYXNJbnN0YW5jZSIsIm9iamVjdCIsIl9CbG9iJDEiLCJfRmlsZSIsIkZpbGUiLCJsYXN0TW9kaWZpZWQiLCJmaWxlQml0cyIsImZpbGVOYW1lIiwiYXJndW1lbnRzIiwiRGF0ZSIsIm5vdyIsIkZpbGUkMSIsInQiLCJoIiwicmFuZG9tIiwibSIsImYiLCJhIiwiYyIsIkZvcm1EYXRhIiwiZCIsImVudHJpZXMiLCJvIiwic29tZSIsImFwcGVuZCIsImRlbGV0ZSIsImZpbHRlciIsImdldCIsImwiLCJnZXRBbGwiLCJoYXMiLCJrZXlzIiwiZm9ybURhdGFUb0Jsb2IiLCJCIiwicGFkU3RhcnQiLCJwIiwiRmV0Y2hCYXNlRXJyb3IiLCJGZXRjaEVycm9yIiwic3lzdGVtRXJyb3IiLCJjb2RlIiwiZXJybm8iLCJlcnJvcmVkU3lzQ2FsbCIsInN5c2NhbGwiLCJOQU1FIiwiaXNVUkxTZWFyY2hQYXJhbWV0ZXJzIiwic29ydCIsImlzQmxvYiIsImlzRG9tYWluT3JTdWJkb21haW4iLCJvcmlnIiwiVVJMIiwiaG9zdG5hbWUiLCJlbmRzV2l0aCIsImlzU2FtZVByb3RvY29sIiwicHJvdG9jb2wiLCJwaXBlbGluZSIsInByb21pc2lmeSIsIklOVEVSTkFMUyQyIiwiQm9keSIsImJvZHkiLCJib3VuZGFyeSIsInRvU3RyaW5nIiwiaXNCdWZmZXIiLCJ0eXBlcyIsImlzQW55QXJyYXlCdWZmZXIiLCJSZWFkYWJsZSIsImRpc3R1cmJlZCIsIm9uIiwiZXJyb3JfIiwidXJsIiwiYm9keVVzZWQiLCJjb25zdW1lQm9keSIsImZvcm1EYXRhIiwiY3QiLCJoZWFkZXJzIiwic3RhcnRzV2l0aCIsInBhcmFtZXRlcnMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b0Zvcm1EYXRhIiwiYnVmIiwianNvbiIsIkpTT04iLCJwYXJzZSIsImRlcHJlY2F0ZSIsImFsbG9jIiwiYWNjdW0iLCJhY2N1bUJ5dGVzIiwiZGVzdHJveSIsInJlYWRhYmxlRW5kZWQiLCJfcmVhZGFibGVTdGF0ZSIsImVuZGVkIiwiZXZlcnkiLCJqb2luIiwiY29uY2F0IiwiaW5zdGFuY2UiLCJwMSIsInAyIiwiZ2V0Qm91bmRhcnkiLCJQYXNzVGhyb3VnaCIsInBpcGUiLCJnZXROb25TcGVjRm9ybURhdGFCb3VuZGFyeSIsImV4dHJhY3RDb250ZW50VHlwZSIsImdldFRvdGFsQnl0ZXMiLCJnZXRMZW5ndGhTeW5jIiwiaGFzS25vd25MZW5ndGgiLCJ3cml0ZVRvU3RyZWFtIiwidmFsaWRhdGVIZWFkZXJOYW1lIiwidmFsaWRhdGVIZWFkZXJWYWx1ZSIsIkhlYWRlcnMiLCJyYXciLCJpc0JveGVkUHJpbWl0aXZlIiwibWV0aG9kIiwiUHJveHkiLCJ0YXJnZXQiLCJyZWNlaXZlciIsIlNldCIsIlJlZmxlY3QiLCJ0aGlzQXJnIiwicmVkdWNlIiwia2V5IiwiZm9yIiwicHJvcGVydHkiLCJmcm9tUmF3SGVhZGVycyIsImluZGV4IiwiYXJyYXkiLCJyZWRpcmVjdFN0YXR1cyIsImlzUmVkaXJlY3QiLCJJTlRFUk5BTFMkMSIsIlJlc3BvbnNlIiwic3RhdHVzIiwiY29udGVudFR5cGUiLCJzdGF0dXNUZXh0IiwiY291bnRlciIsIm9rIiwicmVkaXJlY3RlZCIsInJlZGlyZWN0IiwibG9jYXRpb24iLCJyZXNwb25zZSIsInN0cmluZ2lmeSIsImdldFNlYXJjaCIsInBhcnNlZFVSTCIsInNlYXJjaCIsImxhc3RPZmZzZXQiLCJocmVmIiwiaGFzaCIsInN0cmlwVVJMRm9yVXNlQXNBUmVmZXJyZXIiLCJvcmlnaW5Pbmx5IiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInBhdGhuYW1lIiwiUmVmZXJyZXJQb2xpY3kiLCJERUZBVUxUX1JFRkVSUkVSX1BPTElDWSIsInZhbGlkYXRlUmVmZXJyZXJQb2xpY3kiLCJyZWZlcnJlclBvbGljeSIsImlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSIsImhvc3RJcCIsImhvc3QiLCJob3N0SVBWZXJzaW9uIiwiaXNJUCIsImlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeSIsImRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIiLCJyZWZlcnJlclVSTENhbGxiYWNrIiwicmVmZXJyZXJPcmlnaW5DYWxsYmFjayIsInJlZmVycmVyIiwicG9saWN5IiwicmVmZXJyZXJTb3VyY2UiLCJyZWZlcnJlclVSTCIsInJlZmVycmVyT3JpZ2luIiwiY3VycmVudFVSTCIsIm9yaWdpbiIsInBhcnNlUmVmZXJyZXJQb2xpY3lGcm9tSGVhZGVyIiwicG9saWN5VG9rZW5zIiwidG9rZW4iLCJJTlRFUk5BTFMiLCJpc1JlcXVlc3QiLCJkb0JhZERhdGFXYXJuIiwiUmVxdWVzdCIsImlucHV0IiwidG9VcHBlckNhc2UiLCJpbnB1dEJvZHkiLCJwYXJzZWRSZWZlcnJlciIsImZvbGxvdyIsImNvbXByZXNzIiwiYWdlbnQiLCJpbnNlY3VyZUhUVFBQYXJzZXIiLCJmb3JtYXQiLCJnZXROb2RlUmVxdWVzdE9wdGlvbnMiLCJjb250ZW50TGVuZ3RoVmFsdWUiLCJ0b3RhbEJ5dGVzIiwicGF0aCIsIkFib3J0RXJyb3IiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQiLCJwb3J0MSIsImFiIiwicG9zdE1lc3NhZ2UiLCJlcnIiLCJub2RlRG9tZXhjZXB0aW9uIiwic3VwcG9ydGVkU2NoZW1hcyIsImZldGNoIiwib3B0aW9uc18iLCJzZW5kIiwiZW1pdCIsImFib3J0QW5kRmluYWxpemUiLCJyZXF1ZXN0XyIsImZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nIiwidmVyc2lvbiIsInMiLCJlbmRlZFdpdGhFdmVudHNDb3VudCIsInByZXBlbmRMaXN0ZW5lciIsIl9ldmVudHNDb3VudCIsImhhZEVycm9yIiwicmVzcG9uc2VfIiwic2V0VGltZW91dCIsInJhd0hlYWRlcnMiLCJzdGF0dXNDb2RlIiwibG9jYXRpb25VUkwiLCJyZXF1ZXN0T3B0aW9ucyIsInJlc3BvbnNlUmVmZXJyZXJQb2xpY3kiLCJvbmNlIiwicmVzcG9uc2VPcHRpb25zIiwic3RhdHVzTWVzc2FnZSIsImNvZGluZ3MiLCJ6bGliT3B0aW9ucyIsIlpfU1lOQ19GTFVTSCIsImZpbmlzaEZsdXNoIiwiY3JlYXRlR3VuemlwIiwiY3JlYXRlSW5mbGF0ZSIsImNyZWF0ZUluZmxhdGVSYXciLCJjcmVhdGVCcm90bGlEZWNvbXByZXNzIiwiY2F0Y2giLCJlcnJvckNhbGxiYWNrIiwiTEFTVF9DSFVOSyIsImlzQ2h1bmtlZFRyYW5zZmVyIiwicHJvcGVyTGFzdENodW5rUmVjZWl2ZWQiLCJwcmV2aW91c0NodW5rIiwic29ja2V0Iiwib25Tb2NrZXRDbG9zZSIsIm9uRGF0YSIsImNvbXBhcmUiLCJyZW1vdmVMaXN0ZW5lciIsInByaXZhdGVEYXRhIiwiV2Vha01hcCIsIndyYXBwZXJzIiwicGQiLCJldmVudCIsInJldHYiLCJjb25zb2xlIiwiYXNzZXJ0Iiwic2V0Q2FuY2VsRmxhZyIsInBhc3NpdmVMaXN0ZW5lciIsImNhbmNlbGFibGUiLCJjYW5jZWxlZCIsInByZXZlbnREZWZhdWx0IiwiRXZlbnQiLCJldmVudFRhcmdldCIsImV2ZW50UGhhc2UiLCJjdXJyZW50VGFyZ2V0Iiwic3RvcHBlZCIsImltbWVkaWF0ZVN0b3BwZWQiLCJ0aW1lU3RhbXAiLCJkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3IiLCJjb21wb3NlZFBhdGgiLCJOT05FIiwiQ0FQVFVSSU5HX1BIQVNFIiwiQVRfVEFSR0VUIiwiQlVCQkxJTkdfUEhBU0UiLCJzdG9wUHJvcGFnYXRpb24iLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJidWJibGVzIiwiZGVmYXVsdFByZXZlbnRlZCIsImNvbXBvc2VkIiwic3JjRWxlbWVudCIsImNhbmNlbEJ1YmJsZSIsInJldHVyblZhbHVlIiwiaW5pdEV2ZW50IiwiZGVmaW5lQ2FsbERlc2NyaXB0b3IiLCJkZWZpbmVXcmFwcGVyIiwiQmFzZUV2ZW50IiwicHJvdG8iLCJDdXN0b21FdmVudCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzRnVuYyIsImdldFdyYXBwZXIiLCJ3cmFwcGVyIiwid3JhcEV2ZW50IiwiV3JhcHBlciIsImlzU3RvcHBlZCIsInNldEV2ZW50UGhhc2UiLCJzZXRDdXJyZW50VGFyZ2V0Iiwic2V0UGFzc2l2ZUxpc3RlbmVyIiwibGlzdGVuZXJzTWFwIiwiQ0FQVFVSRSIsIkJVQkJMRSIsIkFUVFJJQlVURSIsImdldExpc3RlbmVycyIsImxpc3RlbmVycyIsImRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvciIsImV2ZW50TmFtZSIsImxpc3RlbmVyVHlwZSIsImxpc3RlbmVyIiwicHJldiIsIm5ld05vZGUiLCJwYXNzaXZlIiwiZGVmaW5lRXZlbnRBdHRyaWJ1dGUiLCJldmVudFRhcmdldFByb3RvdHlwZSIsImRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0IiwiZXZlbnROYW1lcyIsIkN1c3RvbUV2ZW50VGFyZ2V0IiwiRXZlbnRUYXJnZXQiLCJNYXAiLCJBcnJheSIsImlzQXJyYXkiLCJvcHRpb25zSXNPYmoiLCJjYXB0dXJlIiwiZGlzcGF0Y2hFdmVudCIsIndyYXBwZWRFdmVudCIsImhhbmRsZUV2ZW50IiwiQWJvcnRTaWduYWwiLCJhYm9ydGVkRmxhZ3MiLCJjcmVhdGVBYm9ydFNpZ25hbCIsImFib3J0U2lnbmFsIiwiQWJvcnRDb250cm9sbGVyJDEiLCJzaWduYWxzIiwiZ2V0U2lnbmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native/lib/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/node-fetch-native/lib/index.cjs ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst nodeFetch = __webpack_require__(/*! ../dist/index.cjs */ \"(rsc)/./node_modules/node-fetch-native/dist/index.cjs\");\nfunction fetch(input, options) {\n    return nodeFetch.fetch(input, options);\n}\nfor(const key in nodeFetch){\n    fetch[key] = nodeFetch[key];\n}\nmodule.exports = fetch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvbGliL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsWUFBWUMsbUJBQU9BLENBQUMsZ0ZBQW1CO0FBRTdDLFNBQVNDLE1BQU9DLEtBQUssRUFBRUMsT0FBTztJQUM1QixPQUFPSixVQUFVRSxLQUFLLENBQUNDLE9BQU9DO0FBQ2hDO0FBRUEsSUFBSyxNQUFNQyxPQUFPTCxVQUFXO0lBQzNCRSxLQUFLLENBQUNHLElBQUksR0FBR0wsU0FBUyxDQUFDSyxJQUFJO0FBQzdCO0FBRUFDLE9BQU9DLE9BQU8sR0FBR0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maW5peC8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoLW5hdGl2ZS9saWIvaW5kZXguY2pzPzA3NGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgbm9kZUZldGNoID0gcmVxdWlyZShcIi4uL2Rpc3QvaW5kZXguY2pzXCIpO1xuXG5mdW5jdGlvbiBmZXRjaCAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5vZGVGZXRjaC5mZXRjaChpbnB1dCwgb3B0aW9ucyk7XG59XG5cbmZvciAoY29uc3Qga2V5IGluIG5vZGVGZXRjaCkge1xuICBmZXRjaFtrZXldID0gbm9kZUZldGNoW2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmV0Y2g7XG4iXSwibmFtZXMiOlsibm9kZUZldGNoIiwicmVxdWlyZSIsImZldGNoIiwiaW5wdXQiLCJvcHRpb25zIiwia2V5IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native/lib/index.cjs\n");

/***/ })

};
;